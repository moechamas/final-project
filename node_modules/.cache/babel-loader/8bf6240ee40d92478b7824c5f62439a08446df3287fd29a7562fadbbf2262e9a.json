{"ast":null,"code":"const jose = require('jose');\nconst {\n  assertIssuerConfiguration\n} = require('./assert');\nconst {\n  random\n} = require('./generators');\nconst now = require('./unix_timestamp');\nconst request = require('./request');\nconst instance = require('./weak_cache');\nconst merge = require('./merge');\nconst formUrlEncode = value => encodeURIComponent(value).replace(/%20/g, '+');\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n  if (!alg) {\n    assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n  }\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    const key = await this.joseSecret();\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg = Array.isArray(supported) && supported.find(signAlg => key.algorithms('sign').has(signAlg));\n    }\n    return jose.JWS.sign(payload, key, {\n      alg,\n      typ: 'JWT'\n    });\n  }\n  const keystore = instance(this).get('keystore');\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n  if (!alg) {\n    const algs = new Set();\n    keystore.all().forEach(key => {\n      key.algorithms('sign').forEach(Set.prototype.add.bind(algs));\n    });\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg = Array.isArray(supported) && supported.find(signAlg => algs.has(signAlg));\n  }\n  const key = keystore.get({\n    alg,\n    use: 'sig'\n  });\n  if (!key) {\n    throw new TypeError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n  }\n  return jose.JWS.sign(payload, key, {\n    alg,\n    typ: 'JWT',\n    kid: key.kid.startsWith('DONOTUSE.') ? undefined : key.kid\n  });\n}\nasync function authFor(endpoint, {\n  clientAssertionPayload\n} = {}) {\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return {\n        form: {\n          client_id: this.client_id\n        }\n      };\n    case 'client_secret_post':\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_post client authentication method requires a client_secret');\n      }\n      return {\n        form: {\n          client_id: this.client_id,\n          client_secret: this.client_secret\n        }\n      };\n    case 'private_key_jwt':\n    case 'client_secret_jwt':\n      {\n        const timestamp = now();\n        const mTLS = endpoint === 'token' && this.tls_client_certificate_bound_access_tokens;\n        const audience = [...new Set([this.issuer.issuer, this.issuer.token_endpoint, this.issuer[`${endpoint}_endpoint`], mTLS && this.issuer.mtls_endpoint_aliases ? this.issuer.mtls_endpoint_aliases.token_endpoint : undefined].filter(Boolean))];\n        const assertion = await clientAssertion.call(this, endpoint, {\n          iat: timestamp,\n          exp: timestamp + 60,\n          jti: random(),\n          iss: this.client_id,\n          sub: this.client_id,\n          aud: audience,\n          ...clientAssertionPayload\n        });\n        return {\n          form: {\n            client_id: this.client_id,\n            client_assertion: assertion,\n            client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'\n          }\n        };\n      }\n    default:\n      {\n        // client_secret_basic\n        // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n        // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n        // > The client identifier is encoded using the\n        // > \"application/x-www-form-urlencoded\" encoding algorithm per\n        // > Appendix B, and the encoded value is used as the username; the client\n        // > password is encoded using the same algorithm and used as the\n        // > password.\n        if (!this.client_secret) {\n          throw new TypeError('client_secret_basic client authentication method requires a client_secret');\n        }\n        const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n        const value = Buffer.from(encoded).toString('base64');\n        return {\n          headers: {\n            Authorization: `Basic ${value}`\n          }\n        };\n      }\n  }\n}\nfunction resolveResponseType() {\n  const {\n    length,\n    0: value\n  } = this.response_types;\n  if (length === 1) {\n    return value;\n  }\n  return undefined;\n}\nfunction resolveRedirectUri() {\n  const {\n    length,\n    0: value\n  } = this.redirect_uris || [];\n  if (length === 1) {\n    return value;\n  }\n  return undefined;\n}\nasync function authenticatedPost(endpoint, opts, {\n  clientAssertionPayload,\n  endpointAuthMethod = endpoint,\n  DPoP\n} = {}) {\n  const auth = await authFor.call(this, endpointAuthMethod, {\n    clientAssertionPayload\n  });\n  const requestOpts = merge(opts, auth);\n  const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') || endpoint === 'token' && this.tls_client_certificate_bound_access_tokens;\n  let targetUrl;\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n  if ('form' in requestOpts) {\n    for (const [key, value] of Object.entries(requestOpts.form)) {\n      // eslint-disable-line no-restricted-syntax, max-len\n      if (typeof value === 'undefined') {\n        delete requestOpts.form[key];\n      }\n    }\n  }\n  return request.call(this, {\n    ...requestOpts,\n    method: 'POST',\n    url: targetUrl\n  }, {\n    mTLS,\n    DPoP\n  });\n}\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost\n};","map":{"version":3,"names":["jose","require","assertIssuerConfiguration","random","now","request","instance","merge","formUrlEncode","value","encodeURIComponent","replace","clientAssertion","endpoint","payload","alg","issuer","key","joseSecret","supported","Array","isArray","find","signAlg","algorithms","has","JWS","sign","typ","keystore","get","TypeError","algs","Set","all","forEach","prototype","add","bind","use","kid","startsWith","undefined","authFor","clientAssertionPayload","authMethod","form","client_id","client_secret","timestamp","mTLS","tls_client_certificate_bound_access_tokens","audience","token_endpoint","mtls_endpoint_aliases","filter","Boolean","assertion","call","iat","exp","jti","iss","sub","aud","client_assertion","client_assertion_type","encoded","Buffer","from","toString","headers","Authorization","resolveResponseType","length","response_types","resolveRedirectUri","redirect_uris","authenticatedPost","opts","endpointAuthMethod","DPoP","auth","requestOpts","includes","targetUrl","Object","entries","method","url","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/openid-client/lib/helpers/client.js"],"sourcesContent":["const jose = require('jose');\n\nconst { assertIssuerConfiguration } = require('./assert');\nconst { random } = require('./generators');\nconst now = require('./unix_timestamp');\nconst request = require('./request');\nconst instance = require('./weak_cache');\nconst merge = require('./merge');\n\nconst formUrlEncode = (value) => encodeURIComponent(value).replace(/%20/g, '+');\n\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n  if (!alg) {\n    assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n  }\n\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    const key = await this.joseSecret();\n\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg = Array.isArray(supported) && supported.find((signAlg) => key.algorithms('sign').has(signAlg));\n    }\n\n    return jose.JWS.sign(payload, key, { alg, typ: 'JWT' });\n  }\n\n  const keystore = instance(this).get('keystore');\n\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n\n  if (!alg) {\n    const algs = new Set();\n\n    keystore.all().forEach((key) => {\n      key.algorithms('sign').forEach(Set.prototype.add.bind(algs));\n    });\n\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg = Array.isArray(supported) && supported.find((signAlg) => algs.has(signAlg));\n  }\n\n  const key = keystore.get({ alg, use: 'sig' });\n  if (!key) {\n    throw new TypeError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n  }\n  return jose.JWS.sign(payload, key, { alg, typ: 'JWT', kid: key.kid.startsWith('DONOTUSE.') ? undefined : key.kid });\n}\n\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return { form: { client_id: this.client_id } };\n    case 'client_secret_post':\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_post client authentication method requires a client_secret');\n      }\n      return { form: { client_id: this.client_id, client_secret: this.client_secret } };\n    case 'private_key_jwt':\n    case 'client_secret_jwt': {\n      const timestamp = now();\n\n      const mTLS = endpoint === 'token' && this.tls_client_certificate_bound_access_tokens;\n      const audience = [...new Set([\n        this.issuer.issuer,\n        this.issuer.token_endpoint,\n        this.issuer[`${endpoint}_endpoint`],\n        mTLS && this.issuer.mtls_endpoint_aliases\n          ? this.issuer.mtls_endpoint_aliases.token_endpoint : undefined,\n      ].filter(Boolean))];\n\n      const assertion = await clientAssertion.call(this, endpoint, {\n        iat: timestamp,\n        exp: timestamp + 60,\n        jti: random(),\n        iss: this.client_id,\n        sub: this.client_id,\n        aud: audience,\n        ...clientAssertionPayload,\n      });\n\n      return {\n        form: {\n          client_id: this.client_id,\n          client_assertion: assertion,\n          client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n        },\n      };\n    }\n    default: { // client_secret_basic\n      // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n      // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n      // > The client identifier is encoded using the\n      // > \"application/x-www-form-urlencoded\" encoding algorithm per\n      // > Appendix B, and the encoded value is used as the username; the client\n      // > password is encoded using the same algorithm and used as the\n      // > password.\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_basic client authentication method requires a client_secret');\n      }\n      const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n      const value = Buffer.from(encoded).toString('base64');\n      return { headers: { Authorization: `Basic ${value}` } };\n    }\n  }\n}\n\nfunction resolveResponseType() {\n  const { length, 0: value } = this.response_types;\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction resolveRedirectUri() {\n  const { length, 0: value } = this.redirect_uris || [];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nasync function authenticatedPost(endpoint, opts, {\n  clientAssertionPayload, endpointAuthMethod = endpoint, DPoP,\n} = {}) {\n  const auth = await authFor.call(this, endpointAuthMethod, { clientAssertionPayload });\n  const requestOpts = merge(opts, auth);\n\n  const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth')\n    || (endpoint === 'token' && this.tls_client_certificate_bound_access_tokens);\n\n  let targetUrl;\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n\n  if ('form' in requestOpts) {\n    for (const [key, value] of Object.entries(requestOpts.form)) { // eslint-disable-line no-restricted-syntax, max-len\n      if (typeof value === 'undefined') {\n        delete requestOpts.form[key];\n      }\n    }\n  }\n\n  return request.call(this, {\n    ...requestOpts,\n    method: 'POST',\n    url: targetUrl,\n  }, { mTLS, DPoP });\n}\n\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}