{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RequestSender = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst HttpClient_js_1 = require(\"./net/HttpClient.js\");\nconst MAX_RETRY_AFTER_WAIT = 60;\nclass RequestSender {\n  constructor(stripe, maxBufferedRequestMetric) {\n    this._stripe = stripe;\n    this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n  }\n  _addHeadersDirectlyToObject(obj, headers) {\n    // For convenience, make some headers easily accessible on\n    // lastResponse.\n    // NOTE: Stripe responds with lowercase header names/keys.\n    obj.requestId = headers['request-id'];\n    obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n    obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n    obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n  }\n  _makeResponseEvent(requestEvent, statusCode, headers) {\n    const requestEndTime = Date.now();\n    const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n    return (0, utils_js_1.removeNullish)({\n      api_version: headers['stripe-version'],\n      account: headers['stripe-account'],\n      idempotency_key: headers['idempotency-key'],\n      method: requestEvent.method,\n      path: requestEvent.path,\n      status: statusCode,\n      request_id: this._getRequestId(headers),\n      elapsed: requestDurationMs,\n      request_start_time: requestEvent.request_start_time,\n      request_end_time: requestEndTime\n    });\n  }\n  _getRequestId(headers) {\n    return headers['request-id'];\n  }\n  /**\n   * Used by methods with spec.streaming === true. For these methods, we do not\n   * buffer successful responses into memory or do parse them into stripe\n   * objects, we delegate that all of that to the user and pass back the raw\n   * http.Response object to the callback.\n   *\n   * (Unsuccessful responses shouldn't make it here, they should\n   * still be buffered/parsed and handled by _jsonResponseHandler -- see\n   * makeRequest)\n   */\n  _streamingResponseHandler(requestEvent, usage, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const streamCompleteCallback = () => {\n        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n        this._stripe._emitter.emit('response', responseEvent);\n        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);\n      };\n      const stream = res.toStream(streamCompleteCallback);\n      // This is here for backwards compatibility, as the stream is a raw\n      // HTTP response in Node and the legacy behavior was to mutate this\n      // response.\n      this._addHeadersDirectlyToObject(stream, headers);\n      return callback(null, stream);\n    };\n  }\n  /**\n   * Default handler for Stripe responses. Buffers the response into memory,\n   * parses the JSON and returns it (i.e. passes it to the callback) if there\n   * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n   */\n  _jsonResponseHandler(requestEvent, usage, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const requestId = this._getRequestId(headers);\n      const statusCode = res.getStatusCode();\n      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n      this._stripe._emitter.emit('response', responseEvent);\n      res.toJSON().then(jsonResponse => {\n        if (jsonResponse.error) {\n          let err;\n          // Convert OAuth error responses into a standard format\n          // so that the rest of the error logic can be shared\n          if (typeof jsonResponse.error === 'string') {\n            jsonResponse.error = {\n              type: jsonResponse.error,\n              message: jsonResponse.error_description\n            };\n          }\n          jsonResponse.error.headers = headers;\n          jsonResponse.error.statusCode = statusCode;\n          jsonResponse.error.requestId = requestId;\n          if (statusCode === 401) {\n            err = new Error_js_1.StripeAuthenticationError(jsonResponse.error);\n          } else if (statusCode === 403) {\n            err = new Error_js_1.StripePermissionError(jsonResponse.error);\n          } else if (statusCode === 429) {\n            err = new Error_js_1.StripeRateLimitError(jsonResponse.error);\n          } else {\n            err = Error_js_1.StripeError.generate(jsonResponse.error);\n          }\n          throw err;\n        }\n        return jsonResponse;\n      }, e => {\n        throw new Error_js_1.StripeAPIError({\n          message: 'Invalid JSON received from the Stripe API',\n          exception: e,\n          requestId: headers['request-id']\n        });\n      }).then(jsonResponse => {\n        this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);\n        // Expose raw response object.\n        const rawResponse = res.getRawResponse();\n        this._addHeadersDirectlyToObject(rawResponse, headers);\n        Object.defineProperty(jsonResponse, 'lastResponse', {\n          enumerable: false,\n          writable: false,\n          value: rawResponse\n        });\n        callback(null, jsonResponse);\n      }, e => callback(e, null));\n    };\n  }\n  static _generateConnectionErrorMessage(requestRetries) {\n    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n  }\n  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  static _shouldRetry(res, numRetries, maxRetries, error) {\n    if (error && numRetries === 0 && HttpClient_js_1.HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n      return true;\n    }\n    // Do not retry if we are out of retries.\n    if (numRetries >= maxRetries) {\n      return false;\n    }\n    // Retry on connection error.\n    if (!res) {\n      return true;\n    }\n    // The API may ask us not to retry (e.g., if doing so would be a no-op)\n    // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n    if (res.getHeaders()['stripe-should-retry'] === 'false') {\n      return false;\n    }\n    if (res.getHeaders()['stripe-should-retry'] === 'true') {\n      return true;\n    }\n    // Retry on conflict errors.\n    if (res.getStatusCode() === 409) {\n      return true;\n    }\n    // Retry on 500, 503, and other internal errors.\n    //\n    // Note that we expect the stripe-should-retry header to be false\n    // in most cases when a 500 is returned, since our idempotency framework\n    // would typically replay it anyway.\n    if (res.getStatusCode() >= 500) {\n      return true;\n    }\n    return false;\n  }\n  _getSleepTimeInMS(numRetries, retryAfter = null) {\n    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n    // Apply exponential backoff with initialNetworkRetryDelay on the\n    // number of numRetries so far as inputs. Do not allow the number to exceed\n    // maxNetworkRetryDelay.\n    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n    // Apply some jitter by randomizing the value in the range of\n    // (sleepSeconds / 2) to (sleepSeconds).\n    sleepSeconds *= 0.5 * (1 + Math.random());\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n    return sleepSeconds * 1000;\n  }\n  // Max retries can be set on a per request basis. Favor those over the global setting\n  _getMaxNetworkRetries(settings = {}) {\n    return settings.maxNetworkRetries !== undefined && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();\n  }\n  _defaultIdempotencyKey(method, settings) {\n    // If this is a POST and we allow multiple retries, ensure an idempotency key.\n    const maxRetries = this._getMaxNetworkRetries(settings);\n    if (method === 'POST' && maxRetries > 0) {\n      return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n    }\n    return null;\n  }\n  _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n    const defaultHeaders = {\n      // Use specified auth token or use default from this stripe instance:\n      Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n      Accept: 'application/json',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'User-Agent': this._getUserAgentString(),\n      'X-Stripe-Client-User-Agent': clientUserAgent,\n      'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n      'Stripe-Version': apiVersion,\n      'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n      'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings)\n    };\n    // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n    //   A user agent SHOULD send a Content-Length in a request message when\n    //   no Transfer-Encoding is sent and the request method defines a meaning\n    //   for an enclosed payload body.  For example, a Content-Length header\n    //   field is normally sent in a POST request even when the value is 0\n    //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n    //   Content-Length header field when the request message does not contain\n    //   a payload body and the method semantics do not anticipate such a\n    //   body.\n    //\n    // These method types are expected to have bodies and so we should always\n    // include a Content-Length.\n    const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n    // If a content length was specified, we always include it regardless of\n    // whether the method semantics anticipate such a body. This keeps us\n    // consistent with historical behavior. We do however want to warn on this\n    // and fix these cases as they are semantically incorrect.\n    if (methodHasPayload || contentLength) {\n      if (!methodHasPayload) {\n        (0, utils_js_1.emitWarning)(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n      }\n      defaultHeaders['Content-Length'] = contentLength;\n    }\n    return Object.assign((0, utils_js_1.removeNullish)(defaultHeaders),\n    // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n    (0, utils_js_1.normalizeHeaders)(userSuppliedHeaders));\n  }\n  _getUserAgentString() {\n    const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';\n    return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n  }\n  _getTelemetryHeader() {\n    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {\n      const metrics = this._stripe._prevRequestMetrics.shift();\n      return JSON.stringify({\n        last_request_metrics: metrics\n      });\n    }\n  }\n  _recordRequestMetrics(requestId, requestDurationMs, usage) {\n    if (this._stripe.getTelemetryEnabled() && requestId) {\n      if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n        (0, utils_js_1.emitWarning)('Request metrics buffer is full, dropping telemetry message.');\n      } else {\n        const m = {\n          request_id: requestId,\n          request_duration_ms: requestDurationMs\n        };\n        if (usage && usage.length > 0) {\n          m.usage = usage;\n        }\n        this._stripe._prevRequestMetrics.push(m);\n      }\n    }\n  }\n  _request(method, host, path, data, auth, options = {}, usage = [], callback, requestDataProcessor = null) {\n    let requestData;\n    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n    };\n    const makeRequest = (apiVersion, headers, numRetries) => {\n      // timeout can be set on a per-request basis. Favor that over the global setting\n      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField('timeout');\n      const req = this._stripe.getApiField('httpClient').makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n      const requestStartTime = Date.now();\n      // @ts-ignore\n      const requestEvent = (0, utils_js_1.removeNullish)({\n        api_version: apiVersion,\n        account: headers['Stripe-Account'],\n        idempotency_key: headers['Idempotency-Key'],\n        method,\n        path,\n        request_start_time: requestStartTime\n      });\n      const requestRetries = numRetries || 0;\n      const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n      this._stripe._emitter.emit('request', requestEvent);\n      req.then(res => {\n        if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries,\n          // @ts-ignore\n          res.getHeaders()['retry-after']);\n        } else if (options.streaming && res.getStatusCode() < 400) {\n          return this._streamingResponseHandler(requestEvent, usage, callback)(res);\n        } else {\n          return this._jsonResponseHandler(requestEvent, usage, callback)(res);\n        }\n      }).catch(error => {\n        if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n        } else {\n          const isTimeoutError = error.code && error.code === HttpClient_js_1.HttpClient.TIMEOUT_ERROR_CODE;\n          return callback(new Error_js_1.StripeConnectionError({\n            message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : RequestSender._generateConnectionErrorMessage(requestRetries),\n            // @ts-ignore\n            detail: error\n          }));\n        }\n      });\n    };\n    const prepareAndMakeRequest = (error, data) => {\n      if (error) {\n        return callback(error);\n      }\n      requestData = data;\n      this._stripe.getClientUserAgent(clientUserAgent => {\n        var _a, _b;\n        const apiVersion = this._stripe.getApiField('version');\n        const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n        makeRequest(apiVersion, headers, 0);\n      });\n    };\n    if (requestDataProcessor) {\n      requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n    } else {\n      prepareAndMakeRequest(null, (0, utils_js_1.stringifyRequestData)(data || {}));\n    }\n  }\n}\nexports.RequestSender = RequestSender;","map":{"version":3,"names":["Object","defineProperty","exports","value","RequestSender","Error_js_1","require","utils_js_1","HttpClient_js_1","MAX_RETRY_AFTER_WAIT","constructor","stripe","maxBufferedRequestMetric","_stripe","_maxBufferedRequestMetric","_addHeadersDirectlyToObject","obj","headers","requestId","stripeAccount","apiVersion","idempotencyKey","_makeResponseEvent","requestEvent","statusCode","requestEndTime","Date","now","requestDurationMs","request_start_time","removeNullish","api_version","account","idempotency_key","method","path","status","request_id","_getRequestId","elapsed","request_end_time","_streamingResponseHandler","usage","callback","res","getHeaders","streamCompleteCallback","responseEvent","getStatusCode","_emitter","emit","_recordRequestMetrics","stream","toStream","_jsonResponseHandler","toJSON","then","jsonResponse","error","err","type","message","error_description","StripeAuthenticationError","StripePermissionError","StripeRateLimitError","StripeError","generate","e","StripeAPIError","exception","rawResponse","getRawResponse","enumerable","writable","_generateConnectionErrorMessage","requestRetries","_shouldRetry","numRetries","maxRetries","HttpClient","CONNECTION_CLOSED_ERROR_CODES","includes","code","_getSleepTimeInMS","retryAfter","initialNetworkRetryDelay","getInitialNetworkRetryDelay","maxNetworkRetryDelay","getMaxNetworkRetryDelay","sleepSeconds","Math","min","pow","random","max","Number","isInteger","_getMaxNetworkRetries","settings","maxNetworkRetries","undefined","getMaxNetworkRetries","_defaultIdempotencyKey","_platformFunctions","uuid4","_makeHeaders","auth","contentLength","clientUserAgent","userSuppliedHeaders","userSuppliedSettings","defaultHeaders","Authorization","getApiField","Accept","_getUserAgentString","_getTelemetryHeader","methodHasPayload","emitWarning","assign","normalizeHeaders","packageVersion","getConstant","appInfo","_appInfo","getAppInfoAsString","trim","getTelemetryEnabled","_prevRequestMetrics","length","metrics","shift","JSON","stringify","last_request_metrics","m","request_duration_ms","push","_request","host","data","options","requestDataProcessor","requestData","retryRequest","requestFn","setTimeout","makeRequest","timeout","req","requestStartTime","streaming","catch","isTimeoutError","TIMEOUT_ERROR_CODE","StripeConnectionError","detail","prepareAndMakeRequest","getClientUserAgent","_a","_b","stringifyRequestData"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/stripe/cjs/RequestSender.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RequestSender = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst HttpClient_js_1 = require(\"./net/HttpClient.js\");\nconst MAX_RETRY_AFTER_WAIT = 60;\nclass RequestSender {\n    constructor(stripe, maxBufferedRequestMetric) {\n        this._stripe = stripe;\n        this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n    }\n    _addHeadersDirectlyToObject(obj, headers) {\n        // For convenience, make some headers easily accessible on\n        // lastResponse.\n        // NOTE: Stripe responds with lowercase header names/keys.\n        obj.requestId = headers['request-id'];\n        obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n        obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n        obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n    }\n    _makeResponseEvent(requestEvent, statusCode, headers) {\n        const requestEndTime = Date.now();\n        const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n        return (0, utils_js_1.removeNullish)({\n            api_version: headers['stripe-version'],\n            account: headers['stripe-account'],\n            idempotency_key: headers['idempotency-key'],\n            method: requestEvent.method,\n            path: requestEvent.path,\n            status: statusCode,\n            request_id: this._getRequestId(headers),\n            elapsed: requestDurationMs,\n            request_start_time: requestEvent.request_start_time,\n            request_end_time: requestEndTime,\n        });\n    }\n    _getRequestId(headers) {\n        return headers['request-id'];\n    }\n    /**\n     * Used by methods with spec.streaming === true. For these methods, we do not\n     * buffer successful responses into memory or do parse them into stripe\n     * objects, we delegate that all of that to the user and pass back the raw\n     * http.Response object to the callback.\n     *\n     * (Unsuccessful responses shouldn't make it here, they should\n     * still be buffered/parsed and handled by _jsonResponseHandler -- see\n     * makeRequest)\n     */\n    _streamingResponseHandler(requestEvent, usage, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const streamCompleteCallback = () => {\n                const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n                this._stripe._emitter.emit('response', responseEvent);\n                this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);\n            };\n            const stream = res.toStream(streamCompleteCallback);\n            // This is here for backwards compatibility, as the stream is a raw\n            // HTTP response in Node and the legacy behavior was to mutate this\n            // response.\n            this._addHeadersDirectlyToObject(stream, headers);\n            return callback(null, stream);\n        };\n    }\n    /**\n     * Default handler for Stripe responses. Buffers the response into memory,\n     * parses the JSON and returns it (i.e. passes it to the callback) if there\n     * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n     */\n    _jsonResponseHandler(requestEvent, usage, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const requestId = this._getRequestId(headers);\n            const statusCode = res.getStatusCode();\n            const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n            this._stripe._emitter.emit('response', responseEvent);\n            res\n                .toJSON()\n                .then((jsonResponse) => {\n                if (jsonResponse.error) {\n                    let err;\n                    // Convert OAuth error responses into a standard format\n                    // so that the rest of the error logic can be shared\n                    if (typeof jsonResponse.error === 'string') {\n                        jsonResponse.error = {\n                            type: jsonResponse.error,\n                            message: jsonResponse.error_description,\n                        };\n                    }\n                    jsonResponse.error.headers = headers;\n                    jsonResponse.error.statusCode = statusCode;\n                    jsonResponse.error.requestId = requestId;\n                    if (statusCode === 401) {\n                        err = new Error_js_1.StripeAuthenticationError(jsonResponse.error);\n                    }\n                    else if (statusCode === 403) {\n                        err = new Error_js_1.StripePermissionError(jsonResponse.error);\n                    }\n                    else if (statusCode === 429) {\n                        err = new Error_js_1.StripeRateLimitError(jsonResponse.error);\n                    }\n                    else {\n                        err = Error_js_1.StripeError.generate(jsonResponse.error);\n                    }\n                    throw err;\n                }\n                return jsonResponse;\n            }, (e) => {\n                throw new Error_js_1.StripeAPIError({\n                    message: 'Invalid JSON received from the Stripe API',\n                    exception: e,\n                    requestId: headers['request-id'],\n                });\n            })\n                .then((jsonResponse) => {\n                this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);\n                // Expose raw response object.\n                const rawResponse = res.getRawResponse();\n                this._addHeadersDirectlyToObject(rawResponse, headers);\n                Object.defineProperty(jsonResponse, 'lastResponse', {\n                    enumerable: false,\n                    writable: false,\n                    value: rawResponse,\n                });\n                callback(null, jsonResponse);\n            }, (e) => callback(e, null));\n        };\n    }\n    static _generateConnectionErrorMessage(requestRetries) {\n        return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n    }\n    // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n    static _shouldRetry(res, numRetries, maxRetries, error) {\n        if (error &&\n            numRetries === 0 &&\n            HttpClient_js_1.HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n            return true;\n        }\n        // Do not retry if we are out of retries.\n        if (numRetries >= maxRetries) {\n            return false;\n        }\n        // Retry on connection error.\n        if (!res) {\n            return true;\n        }\n        // The API may ask us not to retry (e.g., if doing so would be a no-op)\n        // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n        if (res.getHeaders()['stripe-should-retry'] === 'false') {\n            return false;\n        }\n        if (res.getHeaders()['stripe-should-retry'] === 'true') {\n            return true;\n        }\n        // Retry on conflict errors.\n        if (res.getStatusCode() === 409) {\n            return true;\n        }\n        // Retry on 500, 503, and other internal errors.\n        //\n        // Note that we expect the stripe-should-retry header to be false\n        // in most cases when a 500 is returned, since our idempotency framework\n        // would typically replay it anyway.\n        if (res.getStatusCode() >= 500) {\n            return true;\n        }\n        return false;\n    }\n    _getSleepTimeInMS(numRetries, retryAfter = null) {\n        const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n        const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n        // Apply exponential backoff with initialNetworkRetryDelay on the\n        // number of numRetries so far as inputs. Do not allow the number to exceed\n        // maxNetworkRetryDelay.\n        let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n        // Apply some jitter by randomizing the value in the range of\n        // (sleepSeconds / 2) to (sleepSeconds).\n        sleepSeconds *= 0.5 * (1 + Math.random());\n        // But never sleep less than the base sleep seconds.\n        sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n        // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n        if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n            sleepSeconds = Math.max(sleepSeconds, retryAfter);\n        }\n        return sleepSeconds * 1000;\n    }\n    // Max retries can be set on a per request basis. Favor those over the global setting\n    _getMaxNetworkRetries(settings = {}) {\n        return settings.maxNetworkRetries !== undefined &&\n            Number.isInteger(settings.maxNetworkRetries)\n            ? settings.maxNetworkRetries\n            : this._stripe.getMaxNetworkRetries();\n    }\n    _defaultIdempotencyKey(method, settings) {\n        // If this is a POST and we allow multiple retries, ensure an idempotency key.\n        const maxRetries = this._getMaxNetworkRetries(settings);\n        if (method === 'POST' && maxRetries > 0) {\n            return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n        }\n        return null;\n    }\n    _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n        const defaultHeaders = {\n            // Use specified auth token or use default from this stripe instance:\n            Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n            Accept: 'application/json',\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'User-Agent': this._getUserAgentString(),\n            'X-Stripe-Client-User-Agent': clientUserAgent,\n            'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n            'Stripe-Version': apiVersion,\n            'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n            'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings),\n        };\n        // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n        //   A user agent SHOULD send a Content-Length in a request message when\n        //   no Transfer-Encoding is sent and the request method defines a meaning\n        //   for an enclosed payload body.  For example, a Content-Length header\n        //   field is normally sent in a POST request even when the value is 0\n        //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n        //   Content-Length header field when the request message does not contain\n        //   a payload body and the method semantics do not anticipate such a\n        //   body.\n        //\n        // These method types are expected to have bodies and so we should always\n        // include a Content-Length.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        // If a content length was specified, we always include it regardless of\n        // whether the method semantics anticipate such a body. This keeps us\n        // consistent with historical behavior. We do however want to warn on this\n        // and fix these cases as they are semantically incorrect.\n        if (methodHasPayload || contentLength) {\n            if (!methodHasPayload) {\n                (0, utils_js_1.emitWarning)(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n            }\n            defaultHeaders['Content-Length'] = contentLength;\n        }\n        return Object.assign((0, utils_js_1.removeNullish)(defaultHeaders), \n        // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n        (0, utils_js_1.normalizeHeaders)(userSuppliedHeaders));\n    }\n    _getUserAgentString() {\n        const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n        const appInfo = this._stripe._appInfo\n            ? this._stripe.getAppInfoAsString()\n            : '';\n        return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n    }\n    _getTelemetryHeader() {\n        if (this._stripe.getTelemetryEnabled() &&\n            this._stripe._prevRequestMetrics.length > 0) {\n            const metrics = this._stripe._prevRequestMetrics.shift();\n            return JSON.stringify({\n                last_request_metrics: metrics,\n            });\n        }\n    }\n    _recordRequestMetrics(requestId, requestDurationMs, usage) {\n        if (this._stripe.getTelemetryEnabled() && requestId) {\n            if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n                (0, utils_js_1.emitWarning)('Request metrics buffer is full, dropping telemetry message.');\n            }\n            else {\n                const m = {\n                    request_id: requestId,\n                    request_duration_ms: requestDurationMs,\n                };\n                if (usage && usage.length > 0) {\n                    m.usage = usage;\n                }\n                this._stripe._prevRequestMetrics.push(m);\n            }\n        }\n    }\n    _request(method, host, path, data, auth, options = {}, usage = [], callback, requestDataProcessor = null) {\n        let requestData;\n        const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n            return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n        };\n        const makeRequest = (apiVersion, headers, numRetries) => {\n            // timeout can be set on a per-request basis. Favor that over the global setting\n            const timeout = options.settings &&\n                options.settings.timeout &&\n                Number.isInteger(options.settings.timeout) &&\n                options.settings.timeout >= 0\n                ? options.settings.timeout\n                : this._stripe.getApiField('timeout');\n            const req = this._stripe\n                .getApiField('httpClient')\n                .makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n            const requestStartTime = Date.now();\n            // @ts-ignore\n            const requestEvent = (0, utils_js_1.removeNullish)({\n                api_version: apiVersion,\n                account: headers['Stripe-Account'],\n                idempotency_key: headers['Idempotency-Key'],\n                method,\n                path,\n                request_start_time: requestStartTime,\n            });\n            const requestRetries = numRetries || 0;\n            const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n            this._stripe._emitter.emit('request', requestEvent);\n            req\n                .then((res) => {\n                if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, \n                    // @ts-ignore\n                    res.getHeaders()['retry-after']);\n                }\n                else if (options.streaming && res.getStatusCode() < 400) {\n                    return this._streamingResponseHandler(requestEvent, usage, callback)(res);\n                }\n                else {\n                    return this._jsonResponseHandler(requestEvent, usage, callback)(res);\n                }\n            })\n                .catch((error) => {\n                if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n                }\n                else {\n                    const isTimeoutError = error.code && error.code === HttpClient_js_1.HttpClient.TIMEOUT_ERROR_CODE;\n                    return callback(new Error_js_1.StripeConnectionError({\n                        message: isTimeoutError\n                            ? `Request aborted due to timeout being reached (${timeout}ms)`\n                            : RequestSender._generateConnectionErrorMessage(requestRetries),\n                        // @ts-ignore\n                        detail: error,\n                    }));\n                }\n            });\n        };\n        const prepareAndMakeRequest = (error, data) => {\n            if (error) {\n                return callback(error);\n            }\n            requestData = data;\n            this._stripe.getClientUserAgent((clientUserAgent) => {\n                var _a, _b;\n                const apiVersion = this._stripe.getApiField('version');\n                const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n                makeRequest(apiVersion, headers, 0);\n            });\n        };\n        if (requestDataProcessor) {\n            requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n        }\n        else {\n            prepareAndMakeRequest(null, (0, utils_js_1.stringifyRequestData)(data || {}));\n        }\n    }\n}\nexports.RequestSender = RequestSender;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}