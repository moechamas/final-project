{"ast":null,"code":"const isObject = require('../help/is_object');\nlet validateCrit = require('../help/validate_crit');\nconst {\n  JWEInvalid\n} = require('../errors');\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid);\nconst compactSerializer = (final, [recipient]) => {\n  return `${final.protected}.${recipient.encrypted_key}.${final.iv}.${final.ciphertext}.${final.tag}`;\n};\ncompactSerializer.validate = (protectedHeader, unprotectedHeader, aad, {\n  0: {\n    header\n  },\n  length\n}) => {\n  if (length !== 1 || aad || unprotectedHeader || header) {\n    throw new JWEInvalid('JWE Compact Serialization doesn\\'t support multiple recipients, JWE unprotected headers or AAD');\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\nconst flattenedSerializer = (final, [recipient]) => {\n  const {\n    header,\n    encrypted_key: encryptedKey\n  } = recipient;\n  return {\n    ...(final.protected ? {\n      protected: final.protected\n    } : undefined),\n    ...(final.unprotected ? {\n      unprotected: final.unprotected\n    } : undefined),\n    ...(header ? {\n      header\n    } : undefined),\n    ...(encryptedKey ? {\n      encrypted_key: encryptedKey\n    } : undefined),\n    ...(final.aad ? {\n      aad: final.aad\n    } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  };\n};\nflattenedSerializer.validate = (protectedHeader, unprotectedHeader, aad, {\n  0: {\n    header\n  },\n  length\n}) => {\n  if (length !== 1) {\n    throw new JWEInvalid('Flattened JWE JSON Serialization doesn\\'t support multiple recipients');\n  }\n  validateCrit(protectedHeader, {\n    ...unprotectedHeader,\n    ...header\n  }, protectedHeader ? protectedHeader.crit : undefined);\n};\nconst generalSerializer = (final, recipients) => {\n  const result = {\n    ...(final.protected ? {\n      protected: final.protected\n    } : undefined),\n    ...(final.unprotected ? {\n      unprotected: final.unprotected\n    } : undefined),\n    recipients: recipients.map(({\n      header,\n      encrypted_key: encryptedKey,\n      generatedHeader\n    }) => {\n      if (!header && !encryptedKey && !generatedHeader) {\n        return false;\n      }\n      return {\n        ...(header || generatedHeader ? {\n          header: {\n            ...header,\n            ...generatedHeader\n          }\n        } : undefined),\n        ...(encryptedKey ? {\n          encrypted_key: encryptedKey\n        } : undefined)\n      };\n    }).filter(Boolean),\n    ...(final.aad ? {\n      aad: final.aad\n    } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  };\n  if (!result.recipients.length) {\n    delete result.recipients;\n  }\n  return result;\n};\ngeneralSerializer.validate = (protectedHeader, unprotectedHeader, aad, recipients) => {\n  recipients.forEach(({\n    header\n  }) => {\n    validateCrit(protectedHeader, {\n      ...header,\n      ...unprotectedHeader\n    }, protectedHeader ? protectedHeader.crit : undefined);\n  });\n};\nconst isJSON = input => {\n  return isObject(input) && typeof input.ciphertext === 'string' && typeof input.iv === 'string' && typeof input.tag === 'string' && (input.unprotected === undefined || isObject(input.unprotected)) && (input.protected === undefined || typeof input.protected === 'string') && (input.aad === undefined || typeof input.aad === 'string');\n};\nconst isSingleRecipient = input => {\n  return (input.encrypted_key === undefined || typeof input.encrypted_key === 'string') && (input.header === undefined || isObject(input.header));\n};\nconst isValidRecipient = recipient => {\n  return isObject(recipient) && typeof recipient.encrypted_key === 'string' && (recipient.header === undefined || isObject(recipient.header));\n};\nconst isMultiRecipient = input => {\n  if (Array.isArray(input.recipients) && input.recipients.every(isValidRecipient)) {\n    return true;\n  }\n  return false;\n};\nconst detect = input => {\n  if (typeof input === 'string' && input.split('.').length === 5) {\n    return 'compact';\n  }\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general';\n    }\n    if (isSingleRecipient(input)) {\n      return 'flattened';\n    }\n  }\n  throw new JWEInvalid('JWE malformed or invalid serialization');\n};\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n};","map":{"version":3,"names":["isObject","require","validateCrit","JWEInvalid","bind","undefined","compactSerializer","final","recipient","protected","encrypted_key","iv","ciphertext","tag","validate","protectedHeader","unprotectedHeader","aad","header","length","crit","flattenedSerializer","encryptedKey","unprotected","generalSerializer","recipients","result","map","generatedHeader","filter","Boolean","forEach","isJSON","input","isSingleRecipient","isValidRecipient","isMultiRecipient","Array","isArray","every","detect","split","module","exports","compact","flattened","general"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/jose/lib/jwe/serializers.js"],"sourcesContent":["const isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\n\nconst { JWEInvalid } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid)\n\nconst compactSerializer = (final, [recipient]) => {\n  return `${final.protected}.${recipient.encrypted_key}.${final.iv}.${final.ciphertext}.${final.tag}`\n}\ncompactSerializer.validate = (protectedHeader, unprotectedHeader, aad, { 0: { header }, length }) => {\n  if (length !== 1 || aad || unprotectedHeader || header) {\n    throw new JWEInvalid('JWE Compact Serialization doesn\\'t support multiple recipients, JWE unprotected headers or AAD')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst flattenedSerializer = (final, [recipient]) => {\n  const { header, encrypted_key: encryptedKey } = recipient\n\n  return {\n    ...(final.protected ? { protected: final.protected } : undefined),\n    ...(final.unprotected ? { unprotected: final.unprotected } : undefined),\n    ...(header ? { header } : undefined),\n    ...(encryptedKey ? { encrypted_key: encryptedKey } : undefined),\n    ...(final.aad ? { aad: final.aad } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  }\n}\nflattenedSerializer.validate = (protectedHeader, unprotectedHeader, aad, { 0: { header }, length }) => {\n  if (length !== 1) {\n    throw new JWEInvalid('Flattened JWE JSON Serialization doesn\\'t support multiple recipients')\n  }\n  validateCrit(protectedHeader, { ...unprotectedHeader, ...header }, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst generalSerializer = (final, recipients) => {\n  const result = {\n    ...(final.protected ? { protected: final.protected } : undefined),\n    ...(final.unprotected ? { unprotected: final.unprotected } : undefined),\n    recipients: recipients.map(({ header, encrypted_key: encryptedKey, generatedHeader }) => {\n      if (!header && !encryptedKey && !generatedHeader) {\n        return false\n      }\n\n      return {\n        ...(header || generatedHeader ? { header: { ...header, ...generatedHeader } } : undefined),\n        ...(encryptedKey ? { encrypted_key: encryptedKey } : undefined)\n      }\n    }).filter(Boolean),\n    ...(final.aad ? { aad: final.aad } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  }\n\n  if (!result.recipients.length) {\n    delete result.recipients\n  }\n\n  return result\n}\ngeneralSerializer.validate = (protectedHeader, unprotectedHeader, aad, recipients) => {\n  recipients.forEach(({ header }) => {\n    validateCrit(protectedHeader, { ...header, ...unprotectedHeader }, protectedHeader ? protectedHeader.crit : undefined)\n  })\n}\n\nconst isJSON = (input) => {\n  return isObject(input) &&\n    typeof input.ciphertext === 'string' &&\n    typeof input.iv === 'string' &&\n    typeof input.tag === 'string' &&\n    (input.unprotected === undefined || isObject(input.unprotected)) &&\n    (input.protected === undefined || typeof input.protected === 'string') &&\n    (input.aad === undefined || typeof input.aad === 'string')\n}\n\nconst isSingleRecipient = (input) => {\n  return (input.encrypted_key === undefined || typeof input.encrypted_key === 'string') &&\n    (input.header === undefined || isObject(input.header))\n}\n\nconst isValidRecipient = (recipient) => {\n  return isObject(recipient) && typeof recipient.encrypted_key === 'string' && (recipient.header === undefined || isObject(recipient.header))\n}\n\nconst isMultiRecipient = (input) => {\n  if (Array.isArray(input.recipients) && input.recipients.every(isValidRecipient)) {\n    return true\n  }\n\n  return false\n}\n\nconst detect = (input) => {\n  if (typeof input === 'string' && input.split('.').length === 5) {\n    return 'compact'\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general'\n    }\n\n    if (isSingleRecipient(input)) {\n      return 'flattened'\n    }\n  }\n\n  throw new JWEInvalid('JWE malformed or invalid serialization')\n}\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}