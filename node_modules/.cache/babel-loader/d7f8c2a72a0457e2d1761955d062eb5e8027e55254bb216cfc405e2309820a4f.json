{"ast":null,"code":"/* eslint-disable max-classes-per-file */\n\nconst {\n  inspect\n} = require('util');\nconst url = require('url');\nconst AggregateError = require('aggregate-error');\nconst jose = require('jose');\nconst LRU = require('lru-cache');\nconst objectHash = require('object-hash');\nconst {\n  RPError\n} = require('./errors');\nconst getClient = require('./client');\nconst registry = require('./issuer_registry');\nconst processResponse = require('./helpers/process_response');\nconst webfingerNormalize = require('./helpers/webfinger_normalize');\nconst instance = require('./helpers/weak_cache');\nconst request = require('./helpers/request');\nconst {\n  assertIssuerConfiguration\n} = require('./helpers/assert');\nconst {\n  ISSUER_DEFAULTS,\n  OIDC_DISCOVERY,\n  OAUTH2_DISCOVERY,\n  WEBFINGER,\n  REL,\n  AAD_MULTITENANT_DISCOVERY\n} = require('./helpers/consts');\nconst AAD_MULTITENANT = Symbol('AAD_MULTITENANT');\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(meta = {}) {\n    const aadIssValidation = meta[AAD_MULTITENANT];\n    delete meta[AAD_MULTITENANT];\n    ['introspection', 'revocation'].forEach(endpoint => {\n      // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n      // are defined\n      if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {\n        if (meta.token_endpoint_auth_methods_supported) {\n          meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;\n        }\n        if (meta.token_endpoint_auth_signing_alg_values_supported) {\n          meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;\n        }\n      }\n    });\n    Object.entries(meta).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).get('metadata').get(key);\n          },\n          enumerable: true\n        });\n      }\n    });\n    instance(this).set('cache', new LRU({\n      max: 100\n    }));\n    registry.set(this.issuer, this);\n    const Client = getClient(this, aadIssValidation);\n    Object.defineProperties(this, {\n      Client: {\n        value: Client\n      },\n      FAPIClient: {\n        value: class FAPIClient extends Client {}\n      }\n    });\n  }\n\n  /**\n   * @name keystore\n   * @api public\n   */\n  async keystore(reload = false) {\n    assertIssuerConfiguration(this, 'jwks_uri');\n    const keystore = instance(this).get('keystore');\n    const cache = instance(this).get('cache');\n    if (reload || !keystore) {\n      cache.reset();\n      const response = await request.call(this, {\n        method: 'GET',\n        responseType: 'json',\n        url: this.jwks_uri\n      });\n      const jwks = processResponse(response);\n      const joseKeyStore = jose.JWKS.asKeyStore(jwks, {\n        ignoreErrors: true\n      });\n      cache.set('throttle', true, 60 * 1000);\n      instance(this).set('keystore', joseKeyStore);\n      return joseKeyStore;\n    }\n    return keystore;\n  }\n\n  /**\n   * @name queryKeyStore\n   * @api private\n   */\n  async queryKeyStore({\n    kid,\n    kty,\n    alg,\n    use,\n    key_ops: ops\n  }, {\n    allowMulti = false\n  } = {}) {\n    const cache = instance(this).get('cache');\n    const def = {\n      kid,\n      kty,\n      alg,\n      use,\n      key_ops: ops\n    };\n    const defHash = objectHash(def, {\n      algorithm: 'sha256',\n      ignoreUnknown: true,\n      unorderedArrays: true,\n      unorderedSets: true\n    });\n\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n    const keystore = await this.keystore(!freshJwksUri);\n    const keys = keystore.all(def);\n    if (keys.length === 0) {\n      throw new RPError({\n        printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n        jwks: keystore\n      });\n    }\n    if (!allowMulti && keys.length > 1 && !kid) {\n      throw new RPError({\n        printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n        jwks: keystore\n      });\n    }\n    cache.set(defHash, true);\n    return new jose.JWKS.KeyStore(keys);\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n\n  /**\n   * @name webfinger\n   * @api public\n   */\n  static async webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const {\n      host\n    } = url.parse(resource);\n    const webfingerUrl = `https://${host}${WEBFINGER}`;\n    const response = await request.call(this, {\n      method: 'GET',\n      url: webfingerUrl,\n      responseType: 'json',\n      searchParams: {\n        resource,\n        rel: REL\n      },\n      followRedirect: true\n    });\n    const body = processResponse(response);\n    const location = Array.isArray(body.links) && body.links.find(link => typeof link === 'object' && link.rel === REL && link.href);\n    if (!location) {\n      throw new RPError({\n        message: 'no issuer found in webfinger response',\n        body\n      });\n    }\n    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {\n      throw new RPError({\n        printf: ['invalid issuer location %s', location.href],\n        body\n      });\n    }\n    const expectedIssuer = location.href;\n    if (registry.has(expectedIssuer)) {\n      return registry.get(expectedIssuer);\n    }\n    const issuer = await this.discover(expectedIssuer);\n    if (issuer.issuer !== expectedIssuer) {\n      registry.delete(issuer.issuer);\n      throw new RPError('discovered issuer mismatch, expected %s, got: %s', expectedIssuer, issuer.issuer);\n    }\n    return issuer;\n  }\n\n  /**\n   * @name discover\n   * @api public\n   */\n  static async discover(uri) {\n    const parsed = url.parse(uri);\n    if (parsed.pathname.includes('/.well-known/')) {\n      const response = await request.call(this, {\n        method: 'GET',\n        responseType: 'json',\n        url: uri\n      });\n      const body = processResponse(response);\n      return new Issuer({\n        ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find(discoveryURL => uri.startsWith(discoveryURL))\n      });\n    }\n    const pathnames = [];\n    if (parsed.pathname.endsWith('/')) {\n      pathnames.push(`${parsed.pathname}${OIDC_DISCOVERY.substring(1)}`);\n    } else {\n      pathnames.push(`${parsed.pathname}${OIDC_DISCOVERY}`);\n    }\n    if (parsed.pathname === '/') {\n      pathnames.push(`${OAUTH2_DISCOVERY}`);\n    } else {\n      pathnames.push(`${OAUTH2_DISCOVERY}${parsed.pathname}`);\n    }\n    const errors = [];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const pathname of pathnames) {\n      try {\n        const wellKnownUri = url.format({\n          ...parsed,\n          pathname\n        });\n        // eslint-disable-next-line no-await-in-loop\n        const response = await request.call(this, {\n          method: 'GET',\n          responseType: 'json',\n          url: wellKnownUri\n        });\n        const body = processResponse(response);\n        return new Issuer({\n          ...ISSUER_DEFAULTS,\n          ...body,\n          [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find(discoveryURL => wellKnownUri.startsWith(discoveryURL))\n        });\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n    const err = new AggregateError(errors);\n    err.message = `Issuer.discover() failed.${err.message.split('\\n').filter(line => !line.startsWith('        at')).join('\\n')}`;\n    throw err;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`;\n  }\n}\nmodule.exports = Issuer;","map":{"version":3,"names":["inspect","require","url","AggregateError","jose","LRU","objectHash","RPError","getClient","registry","processResponse","webfingerNormalize","instance","request","assertIssuerConfiguration","ISSUER_DEFAULTS","OIDC_DISCOVERY","OAUTH2_DISCOVERY","WEBFINGER","REL","AAD_MULTITENANT_DISCOVERY","AAD_MULTITENANT","Symbol","Issuer","constructor","meta","aadIssValidation","forEach","endpoint","undefined","token_endpoint_auth_methods_supported","token_endpoint_auth_signing_alg_values_supported","Object","entries","key","value","get","set","defineProperty","enumerable","max","issuer","Client","defineProperties","FAPIClient","keystore","reload","cache","reset","response","call","method","responseType","jwks_uri","jwks","joseKeyStore","JWKS","asKeyStore","ignoreErrors","queryKeyStore","kid","kty","alg","use","key_ops","ops","allowMulti","def","defHash","algorithm","ignoreUnknown","unorderedArrays","unorderedSets","freshJwksUri","keys","all","length","printf","KeyStore","metadata","copy","webfinger","input","resource","host","parse","webfingerUrl","searchParams","rel","followRedirect","body","location","Array","isArray","links","find","link","href","message","startsWith","expectedIssuer","has","discover","delete","uri","parsed","pathname","includes","discoveryURL","pathnames","endsWith","push","substring","errors","wellKnownUri","format","err","split","filter","line","join","custom","name","depth","Infinity","colors","process","stdout","isTTY","compact","sorted","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/openid-client/lib/issuer.js"],"sourcesContent":["/* eslint-disable max-classes-per-file */\n\nconst { inspect } = require('util');\nconst url = require('url');\n\nconst AggregateError = require('aggregate-error');\nconst jose = require('jose');\nconst LRU = require('lru-cache');\nconst objectHash = require('object-hash');\n\nconst { RPError } = require('./errors');\nconst getClient = require('./client');\nconst registry = require('./issuer_registry');\nconst processResponse = require('./helpers/process_response');\nconst webfingerNormalize = require('./helpers/webfinger_normalize');\nconst instance = require('./helpers/weak_cache');\nconst request = require('./helpers/request');\nconst { assertIssuerConfiguration } = require('./helpers/assert');\nconst {\n  ISSUER_DEFAULTS, OIDC_DISCOVERY, OAUTH2_DISCOVERY, WEBFINGER, REL, AAD_MULTITENANT_DISCOVERY,\n} = require('./helpers/consts');\n\nconst AAD_MULTITENANT = Symbol('AAD_MULTITENANT');\n\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(meta = {}) {\n    const aadIssValidation = meta[AAD_MULTITENANT];\n    delete meta[AAD_MULTITENANT];\n\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n      // are defined\n      if (\n        meta[`${endpoint}_endpoint`]\n        && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined\n        && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined\n      ) {\n        if (meta.token_endpoint_auth_methods_supported) {\n          meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;\n        }\n        if (meta.token_endpoint_auth_signing_alg_values_supported) {\n          meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;\n        }\n      }\n    });\n\n    Object.entries(meta).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).get('metadata').get(key); },\n          enumerable: true,\n        });\n      }\n    });\n\n    instance(this).set('cache', new LRU({ max: 100 }));\n\n    registry.set(this.issuer, this);\n\n    const Client = getClient(this, aadIssValidation);\n\n    Object.defineProperties(this, {\n      Client: { value: Client },\n      FAPIClient: { value: class FAPIClient extends Client {} },\n    });\n  }\n\n  /**\n   * @name keystore\n   * @api public\n   */\n  async keystore(reload = false) {\n    assertIssuerConfiguration(this, 'jwks_uri');\n\n    const keystore = instance(this).get('keystore');\n    const cache = instance(this).get('cache');\n\n    if (reload || !keystore) {\n      cache.reset();\n      const response = await request.call(this, {\n        method: 'GET',\n        responseType: 'json',\n        url: this.jwks_uri,\n      });\n      const jwks = processResponse(response);\n\n      const joseKeyStore = jose.JWKS.asKeyStore(jwks, { ignoreErrors: true });\n      cache.set('throttle', true, 60 * 1000);\n      instance(this).set('keystore', joseKeyStore);\n      return joseKeyStore;\n    }\n\n    return keystore;\n  }\n\n  /**\n   * @name queryKeyStore\n   * @api private\n   */\n  async queryKeyStore({\n    kid, kty, alg, use, key_ops: ops,\n  }, { allowMulti = false } = {}) {\n    const cache = instance(this).get('cache');\n\n    const def = {\n      kid, kty, alg, use, key_ops: ops,\n    };\n\n    const defHash = objectHash(def, {\n      algorithm: 'sha256',\n      ignoreUnknown: true,\n      unorderedArrays: true,\n      unorderedSets: true,\n    });\n\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n\n    const keystore = await this.keystore(!freshJwksUri);\n    const keys = keystore.all(def);\n\n    if (keys.length === 0) {\n      throw new RPError({\n        printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n        jwks: keystore,\n      });\n    }\n\n    if (!allowMulti && keys.length > 1 && !kid) {\n      throw new RPError({\n        printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n        jwks: keystore,\n      });\n    }\n\n    cache.set(defHash, true);\n\n    return new jose.JWKS.KeyStore(keys);\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n\n  /**\n   * @name webfinger\n   * @api public\n   */\n  static async webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const { host } = url.parse(resource);\n    const webfingerUrl = `https://${host}${WEBFINGER}`;\n\n    const response = await request.call(this, {\n      method: 'GET',\n      url: webfingerUrl,\n      responseType: 'json',\n      searchParams: { resource, rel: REL },\n      followRedirect: true,\n    });\n    const body = processResponse(response);\n\n    const location = Array.isArray(body.links) && body.links.find((link) => typeof link === 'object' && link.rel === REL && link.href);\n\n    if (!location) {\n      throw new RPError({\n        message: 'no issuer found in webfinger response',\n        body,\n      });\n    }\n\n    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {\n      throw new RPError({\n        printf: ['invalid issuer location %s', location.href],\n        body,\n      });\n    }\n\n    const expectedIssuer = location.href;\n    if (registry.has(expectedIssuer)) {\n      return registry.get(expectedIssuer);\n    }\n\n    const issuer = await this.discover(expectedIssuer);\n\n    if (issuer.issuer !== expectedIssuer) {\n      registry.delete(issuer.issuer);\n      throw new RPError('discovered issuer mismatch, expected %s, got: %s', expectedIssuer, issuer.issuer);\n    }\n    return issuer;\n  }\n\n  /**\n   * @name discover\n   * @api public\n   */\n  static async discover(uri) {\n    const parsed = url.parse(uri);\n\n    if (parsed.pathname.includes('/.well-known/')) {\n      const response = await request.call(this, {\n        method: 'GET',\n        responseType: 'json',\n        url: uri,\n      });\n      const body = processResponse(response);\n      return new Issuer({\n        ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find(\n          (discoveryURL) => uri.startsWith(discoveryURL),\n        ),\n      });\n    }\n\n    const pathnames = [];\n    if (parsed.pathname.endsWith('/')) {\n      pathnames.push(`${parsed.pathname}${OIDC_DISCOVERY.substring(1)}`);\n    } else {\n      pathnames.push(`${parsed.pathname}${OIDC_DISCOVERY}`);\n    }\n    if (parsed.pathname === '/') {\n      pathnames.push(`${OAUTH2_DISCOVERY}`);\n    } else {\n      pathnames.push(`${OAUTH2_DISCOVERY}${parsed.pathname}`);\n    }\n\n    const errors = [];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const pathname of pathnames) {\n      try {\n        const wellKnownUri = url.format({ ...parsed, pathname });\n        // eslint-disable-next-line no-await-in-loop\n        const response = await request.call(this, {\n          method: 'GET',\n          responseType: 'json',\n          url: wellKnownUri,\n        });\n        const body = processResponse(response);\n        return new Issuer({\n          ...ISSUER_DEFAULTS,\n          ...body,\n          [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find(\n            (discoveryURL) => wellKnownUri.startsWith(discoveryURL),\n          ),\n        });\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n\n    const err = new AggregateError(errors);\n    err.message = `Issuer.discover() failed.${err.message.split('\\n')\n      .filter((line) => !line.startsWith('        at')).join('\\n')}`;\n    throw err;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n}\n\nmodule.exports = Issuer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}