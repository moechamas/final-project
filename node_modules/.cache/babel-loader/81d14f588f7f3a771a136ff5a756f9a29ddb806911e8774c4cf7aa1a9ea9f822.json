{"ast":null,"code":"/* eslint-disable max-classes-per-file */\n\nconst {\n  inspect\n} = require('util');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst {\n  strict: assert\n} = require('assert');\nconst querystring = require('querystring');\nconst url = require('url');\nconst {\n  ParseError\n} = require('got');\nconst jose = require('jose');\nconst tokenHash = require('oidc-token-hash');\nconst base64url = require('./helpers/base64url');\nconst defaults = require('./helpers/defaults');\nconst {\n  assertSigningAlgValuesSupport,\n  assertIssuerConfiguration\n} = require('./helpers/assert');\nconst pick = require('./helpers/pick');\nconst isPlainObject = require('./helpers/is_plain_object');\nconst processResponse = require('./helpers/process_response');\nconst TokenSet = require('./token_set');\nconst {\n  OPError,\n  RPError\n} = require('./errors');\nconst now = require('./helpers/unix_timestamp');\nconst {\n  random\n} = require('./helpers/generators');\nconst request = require('./helpers/request');\nconst {\n  CALLBACK_PROPERTIES,\n  CLIENT_DEFAULTS,\n  JWT_CONTENT,\n  CLOCK_TOLERANCE\n} = require('./helpers/consts');\nconst issuerRegistry = require('./issuer_registry');\nconst instance = require('./helpers/weak_cache');\nconst {\n  authenticatedPost,\n  resolveResponseType,\n  resolveRedirectUri\n} = require('./helpers/client');\nconst DeviceFlowHandle = require('./device_flow_handle');\nfunction pickCb(input) {\n  return pick(input, ...CALLBACK_PROPERTIES);\n}\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n  return `${tokenType} ${token}`;\n}\nfunction cleanUpClaims(claims) {\n  if (Object.keys(claims._claim_names).length === 0) {\n    delete claims._claim_names;\n  }\n  if (Object.keys(claims._claim_sources).length === 0) {\n    delete claims._claim_sources;\n  }\n}\nfunction assignClaim(target, source, sourceName, throwOnMissing = true) {\n  return ([claim, inSource]) => {\n    if (inSource === sourceName) {\n      if (throwOnMissing && source[claim] === undefined) {\n        throw new RPError(`expected claim \"${claim}\" in \"${sourceName}\"`);\n      } else if (source[claim] !== undefined) {\n        target[claim] = source[claim];\n      }\n      delete target._claim_names[claim];\n    }\n  };\n}\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: `missing required JWT property ${prop}`,\n      jwt\n    });\n  }\n}\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params\n  };\n  Object.entries(authParams).forEach(([key, value]) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n  return authParams;\n}\nasync function claimJWT(label, jwt) {\n  try {\n    const {\n      header,\n      payload\n    } = jose.JWT.decode(jwt, {\n      complete: true\n    });\n    const {\n      iss\n    } = payload;\n    if (header.alg === 'none') {\n      return payload;\n    }\n    let key;\n    if (!iss || iss === this.issuer.issuer) {\n      key = await this.issuer.queryKeyStore(header);\n    } else if (issuerRegistry.has(iss)) {\n      key = await issuerRegistry.get(iss).queryKeyStore(header);\n    } else {\n      const discovered = await this.issuer.constructor.discover(iss);\n      key = await discovered.queryKeyStore(header);\n    }\n    return jose.JWT.verify(jwt, key);\n  } catch (err) {\n    if (err instanceof RPError || err instanceof OPError || err.name === 'AggregateError') {\n      throw err;\n    } else {\n      throw new RPError({\n        printf: ['failed to validate the %s JWT (%s: %s)', label, err.name, err.message],\n        jwt\n      });\n    }\n  }\n}\nfunction getKeystore(jwks) {\n  if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some(k => !isPlainObject(k) || !('kty' in k))) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const jwk of jwks.keys) {\n    if (jwk.kid === undefined) {\n      jwk.kid = `DONOTUSE.${random()}`;\n    }\n  }\n  const keystore = jose.JWKS.asKeyStore(jwks);\n  if (keystore.all().some(key => key.type !== 'private')) {\n    throw new TypeError('jwks must only contain private keys');\n  }\n  return keystore;\n}\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) {\n    // if no explicit value was provided\n    checkBasicSupport(client, metadata, properties);\n  }\n\n  // :fp: c'mon people... RTFM\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\nclass BaseClient {}\nmodule.exports = (issuer, aadIssValidation = false) => class Client extends BaseClient {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, jwks, options) {\n    super();\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n    const properties = {\n      ...CLIENT_DEFAULTS,\n      ...metadata\n    };\n    handleCommonMistakes(this, metadata, properties);\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n    ['introspection', 'revocation'].forEach(endpoint => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n    Object.entries(properties).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).get('metadata').get(key);\n          },\n          enumerable: true\n        });\n      }\n    });\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      instance(this).set('keystore', keystore);\n    }\n    if (options !== undefined) {\n      instance(this).set('options', options);\n    }\n    this[CLOCK_TOLERANCE] = 0;\n  }\n\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n  authorizationUrl(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...target.query,\n      ...authorizationParams.call(this, params)\n    };\n    return url.format(target);\n  }\n\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n  authorizationPost(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs).map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n\n  /**\n   * @name endSessionUrl\n   * @api public\n   */\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n    const {\n      0: postLogout,\n      length\n    } = this.post_logout_redirect_uris || [];\n    const {\n      post_logout_redirect_uri = length === 1 ? postLogout : undefined\n    } = params;\n    let hint = params.id_token_hint;\n    if (hint instanceof TokenSet) {\n      if (!hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      hint = hint.id_token;\n    }\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...params,\n      ...target.query,\n      ...{\n        post_logout_redirect_uri,\n        id_token_hint: hint\n      }\n    };\n    Object.entries(target.query).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n    return url.format(target);\n  }\n\n  /**\n   * @name callbackParams\n   * @api public\n   */\n  callbackParams(input) {\n    // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n    const isString = typeof input === 'string';\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    }\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(url.parse(input.url, true).query);\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError('incoming message body missing, include a body parser prior to this method call');\n          }\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n              return pickCb(input.body);\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(url.parse(input, true).query);\n    }\n  }\n\n  /**\n   * @name callback\n   * @api public\n   */\n  async callback(redirectUri, parameters, checks = {}, {\n    exchangeBody,\n    clientAssertionPayload,\n    DPoP\n  } = {}) {\n    let params = pickCb(parameters);\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n    if (params.error) {\n      throw new OPError(params);\n    }\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type']\n    };\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n    if (params.code) {\n      const tokenset = await this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload,\n        DPoP\n      });\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n      return tokenset;\n    }\n    return new TokenSet(params);\n  }\n\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n  async oauthCallback(redirectUri, parameters, checks = {}, {\n    exchangeBody,\n    clientAssertionPayload,\n    DPoP\n  } = {}) {\n    let params = pickCb(parameters);\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n    if (params.error) {\n      throw new OPError(params);\n    }\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type']\n    };\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        }\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n    if (params.code) {\n      return this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload,\n        DPoP\n      });\n    }\n    return new TokenSet(params);\n  }\n\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n  async decryptIdToken(token) {\n    if (!this.id_token_encrypted_response_alg) {\n      return token;\n    }\n    let idToken = token;\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n    const expectedAlg = this.id_token_encrypted_response_alg;\n    const expectedEnc = this.id_token_encrypted_response_enc;\n    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n    return result;\n  }\n  async validateJWTUserinfo(body) {\n    const expectedAlg = this.userinfo_signed_response_alg;\n    return this.validateJWT(body, expectedAlg, []);\n  }\n\n  /**\n   * @name decryptJARM\n   * @api private\n   */\n  async decryptJARM(response) {\n    if (!this.authorization_encrypted_response_alg) {\n      return response;\n    }\n    const expectedAlg = this.authorization_encrypted_response_alg;\n    const expectedEnc = this.authorization_encrypted_response_enc;\n    return this.decryptJWE(response, expectedAlg, expectedEnc);\n  }\n\n  /**\n   * @name decryptJWTUserinfo\n   * @api private\n   */\n  async decryptJWTUserinfo(body) {\n    if (!this.userinfo_encrypted_response_alg) {\n      return body;\n    }\n    const expectedAlg = this.userinfo_encrypted_response_alg;\n    const expectedEnc = this.userinfo_encrypted_response_enc;\n    return this.decryptJWE(body, expectedAlg, expectedEnc);\n  }\n\n  /**\n   * @name decryptJWE\n   * @api private\n   */\n  async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {\n    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: jwe\n      });\n    }\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: jwe\n      });\n    }\n    let keyOrStore;\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      keyOrStore = instance(this).get('keystore');\n    } else {\n      keyOrStore = await this.joseSecret(expectedAlg === 'dir' ? expectedEnc : expectedAlg);\n    }\n    const payload = jose.JWE.decrypt(jwe, keyOrStore);\n    return payload.toString('utf8');\n  }\n\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n    const expectedAlg = this.id_token_signed_response_alg;\n    const isTokenSet = idToken instanceof TokenSet;\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n    idToken = String(idToken);\n    const timestamp = now();\n    const {\n      protected: header,\n      payload,\n      key\n    } = await this.validateJWT(idToken, expectedAlg);\n    if (maxAge || maxAge !== null && this.require_auth_time) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken\n        });\n      }\n      if (typeof payload.auth_time !== 'number') {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON numeric value',\n          jwt: idToken\n        });\n      }\n    }\n    if (maxAge && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n      throw new RPError({\n        printf: ['too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i', maxAge, payload.auth_time, timestamp - this[CLOCK_TOLERANCE]],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        auth_time: payload.auth_time,\n        jwt: idToken\n      });\n    }\n    if (nonce !== null && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken\n      });\n    }\n    const fapi = this.constructor.name === 'FAPIClient';\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken\n        });\n      }\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken\n        });\n      }\n      if (fapi) {\n        if (!payload.s_hash && (tokenSet.state || state)) {\n          throw new RPError({\n            message: 'missing required property s_hash',\n            jwt: idToken\n          });\n        }\n      }\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n        try {\n          tokenHash.validate({\n            claim: 's_hash',\n            source: 'state'\n          }, payload.s_hash, state, header.alg, key && key.crv);\n        } catch (err) {\n          throw new RPError({\n            message: err.message,\n            jwt: idToken\n          });\n        }\n      }\n    }\n    if (fapi && payload.iat < timestamp - 3600) {\n      throw new RPError({\n        printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        iat: payload.iat,\n        jwt: idToken\n      });\n    }\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'at_hash',\n          source: 'access_token'\n        }, payload.at_hash, tokenSet.access_token, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'c_hash',\n          source: 'code'\n        }, payload.c_hash, tokenSet.code, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n    return tokenSet;\n  }\n\n  /**\n   * @name validateJWT\n   * @api private\n   */\n  async validateJWT(jwt, expectedAlg, required = ['iss', 'sub', 'aud', 'exp', 'iat']) {\n    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n    const timestamp = now();\n    let header;\n    let payload;\n    try {\n      ({\n        header,\n        payload\n      } = jose.JWT.decode(jwt, {\n        complete: true\n      }));\n    } catch (err) {\n      throw new RPError({\n        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],\n        jwt\n      });\n    }\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt\n      });\n    }\n    if (isSelfIssued) {\n      required = [...required, 'sub_jwk']; // eslint-disable-line no-param-reassign\n    }\n    required.forEach(verifyPresence.bind(undefined, payload, jwt));\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n      if (aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt\n        });\n      }\n    }\n    if (payload.iat !== undefined) {\n      if (typeof payload.iat !== 'number') {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON numeric value',\n          jwt\n        });\n      }\n    }\n    if (payload.nbf !== undefined) {\n      if (typeof payload.nbf !== 'number') {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON numeric value',\n          jwt\n        });\n      }\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: ['JWT not active yet, now %i, nbf %i', timestamp + this[CLOCK_TOLERANCE], payload.nbf],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          nbf: payload.nbf,\n          jwt\n        });\n      }\n    }\n    if (payload.exp !== undefined) {\n      if (typeof payload.exp !== 'number') {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON numeric value',\n          jwt\n        });\n      }\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          exp: payload.exp,\n          jwt\n        });\n      }\n    }\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt\n          });\n        }\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: ['aud is missing the client_id, expected %s to be included in %j', this.client_id, payload.aud],\n            jwt\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt\n        });\n      }\n    }\n    if (payload.azp !== undefined) {\n      let {\n        additionalAuthorizedParties\n      } = instance(this).get('options') || {};\n      if (typeof additionalAuthorizedParties === 'string') {\n        additionalAuthorizedParties = [this.client_id, additionalAuthorizedParties];\n      } else if (Array.isArray(additionalAuthorizedParties)) {\n        additionalAuthorizedParties = [this.client_id, ...additionalAuthorizedParties];\n      } else {\n        additionalAuthorizedParties = [this.client_id];\n      }\n      if (!additionalAuthorizedParties.includes(payload.azp)) {\n        throw new RPError({\n          printf: ['azp mismatch, got: %s', payload.azp],\n          jwt\n        });\n      }\n    }\n    let key;\n    if (isSelfIssued) {\n      try {\n        assert(isPlainObject(payload.sub_jwk));\n        key = jose.JWK.asKey(payload.sub_jwk);\n        assert.equal(key.type, 'public');\n      } catch (err) {\n        throw new RPError({\n          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n          jwt\n        });\n      }\n      if (key.thumbprint !== payload.sub) {\n        throw new RPError({\n          message: 'failed to match the subject with sub_jwk',\n          jwt\n        });\n      }\n    } else if (header.alg.startsWith('HS')) {\n      key = await this.joseSecret();\n    } else if (header.alg !== 'none') {\n      key = await this.issuer.queryKeyStore(header);\n    }\n    if (!key && header.alg === 'none') {\n      return {\n        protected: header,\n        payload\n      };\n    }\n    try {\n      return {\n        ...jose.JWS.verify(jwt, key, {\n          complete: true\n        }),\n        payload\n      };\n    } catch (err) {\n      throw new RPError({\n        message: 'failed to validate JWT signature',\n        jwt\n      });\n    }\n  }\n\n  /**\n   * @name refresh\n   * @api public\n   */\n  async refresh(refreshToken, {\n    exchangeBody,\n    clientAssertionPayload,\n    DPoP\n  } = {}) {\n    let token = refreshToken;\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n      token = token.refresh_token;\n    }\n    const tokenset = await this.grant({\n      ...exchangeBody,\n      grant_type: 'refresh_token',\n      refresh_token: String(token)\n    }, {\n      clientAssertionPayload,\n      DPoP\n    });\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, null, 'token', null);\n      if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n        const expectedSub = refreshToken.claims().sub;\n        const actualSub = tokenset.claims().sub;\n        if (actualSub !== expectedSub) {\n          throw new RPError({\n            printf: ['sub mismatch, expected %s, got: %s', expectedSub, actualSub],\n            jwt: tokenset.id_token\n          });\n        }\n      }\n    }\n    return tokenset;\n  }\n  async requestResource(resourceUrl, accessToken, {\n    method,\n    headers,\n    body,\n    DPoP,\n    // eslint-disable-next-line no-nested-ternary\n    tokenType = DPoP ? 'DPoP' : accessToken instanceof TokenSet ? accessToken.token_type : 'Bearer'\n  } = {}) {\n    if (accessToken instanceof TokenSet) {\n      if (!accessToken.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n      accessToken = accessToken.access_token; // eslint-disable-line no-param-reassign\n    }\n    const requestOpts = {\n      headers: {\n        Authorization: authorizationHeaderValue(accessToken, tokenType),\n        ...headers\n      },\n      body\n    };\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n    return request.call(this, {\n      ...requestOpts,\n      responseType: 'buffer',\n      method,\n      url: resourceUrl\n    }, {\n      accessToken,\n      mTLS,\n      DPoP\n    });\n  }\n\n  /**\n   * @name userinfo\n   * @api public\n   */\n  async userinfo(accessToken, {\n    method = 'GET',\n    via = 'header',\n    tokenType,\n    params,\n    DPoP\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    const options = {\n      tokenType,\n      method: String(method).toUpperCase(),\n      DPoP\n    };\n    if (options.method !== 'GET' && options.method !== 'POST') {\n      throw new TypeError('#userinfo() method can only be POST or a GET');\n    }\n    if (via === 'query' && options.method !== 'GET') {\n      throw new TypeError('userinfo endpoints will only parse query strings for GET requests');\n    } else if (via === 'body' && options.method !== 'POST') {\n      throw new TypeError('can only send body on POST');\n    }\n    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n    if (jwt) {\n      options.headers = {\n        Accept: 'application/jwt'\n      };\n    } else {\n      options.headers = {\n        Accept: 'application/json'\n      };\n    }\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n    }\n    targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);\n\n    // when via is not header we clear the Authorization header and add either\n    // query string parameters or urlencoded body access_token parameter\n    if (via === 'query') {\n      options.headers.Authorization = undefined;\n      targetUrl.searchParams.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    } else if (via === 'body') {\n      options.headers.Authorization = undefined;\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.body = new url.URLSearchParams();\n      options.body.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    }\n\n    // handle additional parameters, GET via querystring, POST via urlencoded body\n    if (params) {\n      if (options.method === 'GET') {\n        Object.entries(params).forEach(([key, value]) => {\n          targetUrl.searchParams.append(key, value);\n        });\n      } else if (options.body) {\n        // POST && via body\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      } else {\n        // POST && via header\n        options.body = new url.URLSearchParams();\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      }\n    }\n    if (options.body) {\n      options.body = options.body.toString();\n    }\n    const response = await this.requestResource(targetUrl, accessToken, options);\n    let parsed = processResponse(response, {\n      bearer: true\n    });\n    if (jwt) {\n      if (!JWT_CONTENT.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response\n        });\n      }\n      const body = response.body.toString();\n      const userinfo = await this.decryptJWTUserinfo(body);\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo\n          });\n        }\n      } else {\n        ({\n          payload: parsed\n        } = await this.validateJWTUserinfo(userinfo));\n      }\n    } else {\n      try {\n        parsed = JSON.parse(response.body);\n      } catch (error) {\n        throw new ParseError(error, response);\n      }\n    }\n    if (accessToken instanceof TokenSet && accessToken.id_token) {\n      const expectedSub = accessToken.claims().sub;\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token\n        });\n      }\n    }\n    return parsed;\n  }\n\n  /**\n   * @name derivedKey\n   * @api private\n   */\n  async derivedKey(len) {\n    const cacheKey = `${len}_key`;\n    if (instance(this).has(cacheKey)) {\n      return instance(this).get(cacheKey);\n    }\n    const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false; // eslint-disable-line no-nested-ternary\n    if (!hash) {\n      throw new Error('unsupported symmetric encryption key derivation');\n    }\n    const derivedBuffer = crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);\n    const key = jose.JWK.asKey({\n      k: base64url.encode(derivedBuffer),\n      kty: 'oct'\n    });\n    instance(this).set(cacheKey, key);\n    return key;\n  }\n\n  /**\n   * @name joseSecret\n   * @api private\n   */\n  async joseSecret(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n    if (instance(this).has('jose_secret')) {\n      return instance(this).get('jose_secret');\n    }\n    const key = jose.JWK.asKey({\n      k: base64url.encode(this.client_secret),\n      kty: 'oct'\n    });\n    instance(this).set('jose_secret', key);\n    return key;\n  }\n\n  /**\n   * @name grant\n   * @api public\n   */\n  async grant(body, {\n    clientAssertionPayload,\n    DPoP\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(this, 'token', {\n      form: body,\n      responseType: 'json'\n    }, {\n      clientAssertionPayload,\n      DPoP\n    });\n    const responseBody = processResponse(response);\n    return new TokenSet(responseBody);\n  }\n\n  /**\n   * @name deviceAuthorization\n   * @api public\n   */\n  async deviceAuthorization(params = {}, {\n    exchangeBody,\n    clientAssertionPayload,\n    DPoP\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params\n    });\n    const response = await authenticatedPost.call(this, 'device_authorization', {\n      responseType: 'json',\n      form: body\n    }, {\n      clientAssertionPayload,\n      endpointAuthMethod: 'token'\n    });\n    const responseBody = processResponse(response);\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age,\n      DPoP\n    });\n  }\n\n  /**\n   * @name revoke\n   * @api public\n   */\n  async revoke(token, hint, {\n    revokeBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n    const form = {\n      ...revokeBody,\n      token\n    };\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n    const response = await authenticatedPost.call(this, 'revocation', {\n      form\n    }, {\n      clientAssertionPayload\n    });\n    processResponse(response, {\n      body: false\n    });\n  }\n\n  /**\n   * @name introspect\n   * @api public\n   */\n  async introspect(token, hint, {\n    introspectBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n    const form = {\n      ...introspectBody,\n      token\n    };\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n    const response = await authenticatedPost.call(this, 'introspection', {\n      form,\n      responseType: 'json'\n    }, {\n      clientAssertionPayload\n    });\n    const responseBody = processResponse(response);\n    return responseBody;\n  }\n\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n  async fetchDistributedClaims(claims, tokens = {}) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n    const distributedSources = Object.entries(claims._claim_sources).filter(([, value]) => value && value.endpoint);\n    await Promise.all(distributedSources.map(async ([sourceName, def]) => {\n      try {\n        const requestOpts = {\n          headers: {\n            Accept: 'application/jwt',\n            Authorization: authorizationHeaderValue(def.access_token || tokens[sourceName])\n          }\n        };\n        const response = await request.call(this, {\n          ...requestOpts,\n          method: 'GET',\n          url: def.endpoint\n        });\n        const body = processResponse(response, {\n          bearer: true\n        });\n        const decoded = await claimJWT.call(this, 'distributed', body);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName, false));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n    cleanUpClaims(claims);\n    return claims;\n  }\n\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n  async unpackAggregatedClaims(claims) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n    const aggregatedSources = Object.entries(claims._claim_sources).filter(([, value]) => value && value.JWT);\n    await Promise.all(aggregatedSources.map(async ([sourceName, def]) => {\n      try {\n        const decoded = await claimJWT.call(this, 'aggregated', def.JWT);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n    cleanUpClaims(claims);\n    return claims;\n  }\n\n  /**\n   * @name register\n   * @api public\n   */\n  static async register(metadata, options = {}) {\n    const {\n      initialAccessToken,\n      jwks,\n      ...clientOptions\n    } = options;\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n    if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n      const keystore = getKeystore.call(this, jwks);\n      metadata.jwks = keystore.toJWKS(false);\n      // eslint-disable-next-line no-restricted-syntax\n      for (const jwk of metadata.jwks.keys) {\n        if (jwk.kid.startsWith('DONOTUSE.')) {\n          delete jwk.kid;\n        }\n      }\n    }\n    const response = await request.call(this, {\n      headers: initialAccessToken ? {\n        Authorization: authorizationHeaderValue(initialAccessToken)\n      } : undefined,\n      responseType: 'json',\n      json: metadata,\n      url: this.issuer.registration_endpoint,\n      method: 'POST'\n    });\n    const responseBody = processResponse(response, {\n      statusCode: 201,\n      bearer: true\n    });\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n\n  /**\n   * @name fromUri\n   * @api public\n   */\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      responseType: 'json',\n      headers: {\n        Authorization: authorizationHeaderValue(registrationAccessToken)\n      }\n    });\n    const responseBody = processResponse(response, {\n      bearer: true\n    });\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  /**\n   * @name requestObject\n   * @api public\n   */\n  async requestObject(requestObject = {}, {\n    sign: signingAlgorithm = this.request_object_signing_alg || 'none',\n    encrypt: {\n      alg: eKeyManagement = this.request_object_encryption_alg,\n      enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256'\n    } = {}\n  } = {}) {\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n    let signed;\n    let key;\n    const fapi = this.constructor.name === 'FAPIClient';\n    const unix = now();\n    const header = {\n      alg: signingAlgorithm,\n      typ: 'oauth-authz-req+jwt'\n    };\n    const payload = JSON.stringify(defaults({}, requestObject, {\n      iss: this.client_id,\n      aud: this.issuer.issuer,\n      client_id: this.client_id,\n      jti: random(),\n      iat: unix,\n      exp: unix + 300,\n      ...(fapi ? {\n        nbf: unix\n      } : undefined)\n    }));\n    if (signingAlgorithm === 'none') {\n      signed = [base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.');\n    } else {\n      const symmetric = signingAlgorithm.startsWith('HS');\n      if (symmetric) {\n        key = await this.joseSecret();\n      } else {\n        const keystore = instance(this).get('keystore');\n        if (!keystore) {\n          throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);\n        }\n        key = keystore.get({\n          alg: signingAlgorithm,\n          use: 'sig'\n        });\n        if (!key) {\n          throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n        }\n      }\n      signed = jose.JWS.sign(payload, key, {\n        ...header,\n        kid: symmetric || key.kid.startsWith('DONOTUSE.') ? undefined : key.kid\n      });\n    }\n    if (!eKeyManagement) {\n      return signed;\n    }\n    const fields = {\n      alg: eKeyManagement,\n      enc: eContentEncryption,\n      cty: 'oauth-authz-req+jwt'\n    };\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      [key] = await this.issuer.queryKeyStore({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc'\n      }, {\n        allowMulti: true\n      });\n    } else {\n      key = await this.joseSecret(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n    return jose.JWE.encrypt(signed, key, {\n      ...fields,\n      kid: key.kty === 'oct' ? undefined : key.kid\n    });\n  }\n\n  /**\n   * @name pushedAuthorizationRequest\n   * @api public\n   */\n  async pushedAuthorizationRequest(params = {}, {\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');\n    const body = {\n      ...('request' in params ? params : authorizationParams.call(this, params)),\n      client_id: this.client_id\n    };\n    const response = await authenticatedPost.call(this, 'pushed_authorization_request', {\n      responseType: 'json',\n      form: body\n    }, {\n      clientAssertionPayload,\n      endpointAuthMethod: 'token'\n    });\n    const responseBody = processResponse(response, {\n      statusCode: 201\n    });\n    if (!('expires_in' in responseBody)) {\n      throw new RPError({\n        message: 'expected expires_in in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    if (typeof responseBody.expires_in !== 'number') {\n      throw new RPError({\n        message: 'invalid expires_in value in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    if (!('request_uri' in responseBody)) {\n      throw new RPError({\n        message: 'expected request_uri in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    if (typeof responseBody.request_uri !== 'string') {\n      throw new RPError({\n        message: 'invalid request_uri value in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    return responseBody;\n  }\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  static get issuer() {\n    return issuer;\n  }\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  get issuer() {\n    // eslint-disable-line class-methods-use-this\n    return issuer;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`;\n  }\n};\n\n/**\n * @name validateJARM\n * @api private\n */\nasync function validateJARM(response) {\n  const expectedAlg = this.authorization_signed_response_alg;\n  const {\n    payload\n  } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);\n  return pickCb(payload);\n}\nObject.defineProperty(BaseClient.prototype, 'validateJARM', {\n  enumerable: true,\n  configurable: true,\n  value(...args) {\n    process.emitWarning(\"The JARM API implements an OIDF implementer's draft. Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.\", 'DraftWarning');\n    Object.defineProperty(BaseClient.prototype, 'validateJARM', {\n      enumerable: true,\n      configurable: true,\n      value: validateJARM\n    });\n    return this.validateJARM(...args);\n  }\n});\n\n/**\n * @name dpopProof\n * @api private\n */\nfunction dpopProof(payload, jwk, accessToken) {\n  if (!isPlainObject(payload)) {\n    throw new TypeError('payload must be a plain object');\n  }\n  let key;\n  try {\n    key = jose.JWK.asKey(jwk);\n    assert(key.type === 'private');\n  } catch (err) {\n    throw new TypeError('\"DPoP\" option must be an asymmetric private key to sign the DPoP Proof JWT with');\n  }\n  let {\n    alg\n  } = key;\n  if (!alg && this.issuer.dpop_signing_alg_values_supported) {\n    const algs = key.algorithms('sign');\n    alg = this.issuer.dpop_signing_alg_values_supported.find(a => algs.has(a));\n  }\n  if (!alg) {\n    [alg] = key.algorithms('sign');\n  }\n  return jose.JWS.sign({\n    iat: now(),\n    jti: random(),\n    ath: accessToken ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest()) : undefined,\n    ...payload\n  }, jwk, {\n    alg,\n    typ: 'dpop+jwt',\n    jwk: pick(key, 'kty', 'crv', 'x', 'y', 'e', 'n')\n  });\n}\nObject.defineProperty(BaseClient.prototype, 'dpopProof', {\n  enumerable: true,\n  configurable: true,\n  value(...args) {\n    process.emitWarning('The DPoP APIs implements an IETF draft (https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-03.html). Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.', 'DraftWarning');\n    Object.defineProperty(BaseClient.prototype, 'dpopProof', {\n      enumerable: true,\n      configurable: true,\n      value: dpopProof\n    });\n    return this.dpopProof(...args);\n  }\n});\nmodule.exports.BaseClient = BaseClient;","map":{"version":3,"names":["inspect","require","stdhttp","crypto","strict","assert","querystring","url","ParseError","jose","tokenHash","base64url","defaults","assertSigningAlgValuesSupport","assertIssuerConfiguration","pick","isPlainObject","processResponse","TokenSet","OPError","RPError","now","random","request","CALLBACK_PROPERTIES","CLIENT_DEFAULTS","JWT_CONTENT","CLOCK_TOLERANCE","issuerRegistry","instance","authenticatedPost","resolveResponseType","resolveRedirectUri","DeviceFlowHandle","pickCb","input","authorizationHeaderValue","token","tokenType","cleanUpClaims","claims","Object","keys","_claim_names","length","_claim_sources","assignClaim","target","source","sourceName","throwOnMissing","claim","inSource","undefined","verifyPresence","payload","jwt","prop","message","authorizationParams","params","authParams","client_id","scope","response_type","call","redirect_uri","entries","forEach","key","value","JSON","stringify","Array","isArray","String","claimJWT","label","header","JWT","decode","complete","iss","alg","issuer","queryKeyStore","has","get","discovered","constructor","discover","verify","err","name","printf","getKeystore","jwks","some","k","TypeError","jwk","kid","keystore","JWKS","asKeyStore","all","type","checkBasicSupport","client","metadata","properties","supported","token_endpoint_auth_methods_supported","includes","token_endpoint_auth_method","handleCommonMistakes","redirect_uris","response_types","getDefaultsForEndpoint","endpoint","tokenEndpointAuthMethod","tokenEndpointAuthSigningAlg","token_endpoint_auth_signing_alg","eam","easa","BaseClient","module","exports","aadIssValidation","Client","options","set","defineProperty","enumerable","authorizationUrl","parse","authorization_endpoint","search","query","format","authorizationPost","inputs","formInputs","map","join","endSessionUrl","postLogout","post_logout_redirect_uris","post_logout_redirect_uri","hint","id_token_hint","id_token","end_session_endpoint","callbackParams","isIncomingMessage","IncomingMessage","method","isString","body","Buffer","isBuffer","toString","callback","redirectUri","parameters","checks","exchangeBody","clientAssertionPayload","DPoP","jarm","decrypted","decryptJARM","response","validateJARM","default_max_age","max_age","state","error","RESPONSE_TYPE_REQUIRED_PARAMS","code","split","access_token","param","tokenset","decryptIdToken","validateIdToken","nonce","grant","grant_type","code_verifier","session_state","oauthCallback","id_token_encrypted_response_alg","idToken","expectedAlg","expectedEnc","id_token_encrypted_response_enc","result","decryptJWE","validateJWTUserinfo","userinfo_signed_response_alg","validateJWT","authorization_encrypted_response_alg","authorization_encrypted_response_enc","decryptJWTUserinfo","userinfo_encrypted_response_alg","userinfo_encrypted_response_enc","jwe","enc","keyOrStore","match","joseSecret","JWE","decrypt","tokenSet","returnedBy","maxAge","id_token_signed_response_alg","isTokenSet","timestamp","protected","require_auth_time","auth_time","tolerance","fapi","at_hash","c_hash","s_hash","validate","crv","iat","required","isSelfIssued","bind","expectedIss","replace","tid","nbf","exp","aud","azp","additionalAuthorizedParties","sub_jwk","JWK","asKey","equal","thumbprint","sub","startsWith","JWS","refresh","refreshToken","refresh_token","expectedSub","actualSub","requestResource","resourceUrl","accessToken","headers","token_type","requestOpts","Authorization","mTLS","tls_client_certificate_bound_access_tokens","responseType","userinfo","via","toUpperCase","Accept","targetUrl","mtls_endpoint_aliases","userinfo_endpoint","URL","searchParams","append","URLSearchParams","parsed","bearer","test","derivedKey","len","cacheKey","hash","Error","derivedBuffer","createHash","update","client_secret","digest","slice","encode","kty","parseInt","RegExp","$1","$2","form","responseBody","deviceAuthorization","endpointAuthMethod","revoke","revokeBody","token_type_hint","introspect","introspectBody","fetchDistributedClaims","tokens","distributedSources","filter","Promise","def","decoded","src","unpackAggregatedClaims","aggregatedSources","register","initialAccessToken","clientOptions","jwks_uri","toJWKS","json","registration_endpoint","statusCode","copy","fromUri","registrationClientUri","registrationAccessToken","requestObject","sign","signingAlgorithm","request_object_signing_alg","encrypt","eKeyManagement","request_object_encryption_alg","eContentEncryption","request_object_encryption_enc","signed","unix","typ","jti","symmetric","use","fields","cty","allowMulti","pushedAuthorizationRequest","expires_in","request_uri","custom","depth","Infinity","colors","process","stdout","isTTY","compact","sorted","authorization_signed_response_alg","prototype","configurable","args","emitWarning","dpopProof","dpop_signing_alg_values_supported","algs","algorithms","find","a","ath"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/openid-client/lib/client.js"],"sourcesContent":["/* eslint-disable max-classes-per-file */\n\nconst { inspect } = require('util');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst { strict: assert } = require('assert');\nconst querystring = require('querystring');\nconst url = require('url');\n\nconst { ParseError } = require('got');\nconst jose = require('jose');\nconst tokenHash = require('oidc-token-hash');\n\nconst base64url = require('./helpers/base64url');\nconst defaults = require('./helpers/defaults');\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = require('./helpers/assert');\nconst pick = require('./helpers/pick');\nconst isPlainObject = require('./helpers/is_plain_object');\nconst processResponse = require('./helpers/process_response');\nconst TokenSet = require('./token_set');\nconst { OPError, RPError } = require('./errors');\nconst now = require('./helpers/unix_timestamp');\nconst { random } = require('./helpers/generators');\nconst request = require('./helpers/request');\nconst {\n  CALLBACK_PROPERTIES, CLIENT_DEFAULTS, JWT_CONTENT, CLOCK_TOLERANCE,\n} = require('./helpers/consts');\nconst issuerRegistry = require('./issuer_registry');\nconst instance = require('./helpers/weak_cache');\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = require('./helpers/client');\nconst DeviceFlowHandle = require('./device_flow_handle');\n\nfunction pickCb(input) {\n  return pick(input, ...CALLBACK_PROPERTIES);\n}\n\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n  return `${tokenType} ${token}`;\n}\n\nfunction cleanUpClaims(claims) {\n  if (Object.keys(claims._claim_names).length === 0) {\n    delete claims._claim_names;\n  }\n  if (Object.keys(claims._claim_sources).length === 0) {\n    delete claims._claim_sources;\n  }\n}\n\nfunction assignClaim(target, source, sourceName, throwOnMissing = true) {\n  return ([claim, inSource]) => {\n    if (inSource === sourceName) {\n      if (throwOnMissing && source[claim] === undefined) {\n        throw new RPError(`expected claim \"${claim}\" in \"${sourceName}\"`);\n      } else if (source[claim] !== undefined) {\n        target[claim] = source[claim];\n      }\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: `missing required JWT property ${prop}`,\n      jwt,\n    });\n  }\n}\n\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params,\n  };\n\n  Object.entries(authParams).forEach(([key, value]) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n\n  return authParams;\n}\n\nasync function claimJWT(label, jwt) {\n  try {\n    const { header, payload } = jose.JWT.decode(jwt, { complete: true });\n    const { iss } = payload;\n\n    if (header.alg === 'none') {\n      return payload;\n    }\n\n    let key;\n    if (!iss || iss === this.issuer.issuer) {\n      key = await this.issuer.queryKeyStore(header);\n    } else if (issuerRegistry.has(iss)) {\n      key = await issuerRegistry.get(iss).queryKeyStore(header);\n    } else {\n      const discovered = await this.issuer.constructor.discover(iss);\n      key = await discovered.queryKeyStore(header);\n    }\n    return jose.JWT.verify(jwt, key);\n  } catch (err) {\n    if (err instanceof RPError || err instanceof OPError || err.name === 'AggregateError') {\n      throw err;\n    } else {\n      throw new RPError({\n        printf: ['failed to validate the %s JWT (%s: %s)', label, err.name, err.message],\n        jwt,\n      });\n    }\n  }\n}\n\nfunction getKeystore(jwks) {\n  if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k) => !isPlainObject(k) || !('kty' in k))) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const jwk of jwks.keys) {\n    if (jwk.kid === undefined) {\n      jwk.kid = `DONOTUSE.${random()}`;\n    }\n  }\n\n  const keystore = jose.JWKS.asKeyStore(jwks);\n  if (keystore.all().some((key) => key.type !== 'private')) {\n    throw new TypeError('jwks must only contain private keys');\n  }\n  return keystore;\n}\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) { // if no explicit value was provided\n    checkBasicSupport(client, metadata, properties);\n  }\n\n  // :fp: c'mon people... RTFM\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nclass BaseClient {}\n\nmodule.exports = (issuer, aadIssValidation = false) => class Client extends BaseClient {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, jwks, options) {\n    super();\n\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n\n    const properties = { ...CLIENT_DEFAULTS, ...metadata };\n\n    handleCommonMistakes(this, metadata, properties);\n\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n\n    Object.entries(properties).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).get('metadata').get(key); },\n          enumerable: true,\n        });\n      }\n    });\n\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      instance(this).set('keystore', keystore);\n    }\n\n    if (options !== undefined) {\n      instance(this).set('options', options);\n    }\n\n    this[CLOCK_TOLERANCE] = 0;\n  }\n\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n  authorizationUrl(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...target.query,\n      ...authorizationParams.call(this, params),\n    };\n    return url.format(target);\n  }\n\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n  authorizationPost(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs)\n      .map((name) => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n\n  /**\n   * @name endSessionUrl\n   * @api public\n   */\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n\n    const {\n      0: postLogout,\n      length,\n    } = this.post_logout_redirect_uris || [];\n\n    const {\n      post_logout_redirect_uri = length === 1 ? postLogout : undefined,\n    } = params;\n\n    let hint = params.id_token_hint;\n\n    if (hint instanceof TokenSet) {\n      if (!hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      hint = hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...params,\n      ...target.query,\n      ...{\n        post_logout_redirect_uri,\n        id_token_hint: hint,\n      },\n    };\n\n    Object.entries(target.query).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n\n    return url.format(target);\n  }\n\n  /**\n   * @name callbackParams\n   * @api public\n   */\n  callbackParams(input) { // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage\n      || (input && input.method && input.url);\n    const isString = typeof input === 'string';\n\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    }\n\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(url.parse(input.url, true).query);\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError('incoming message body missing, include a body parser prior to this method call');\n          }\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n\n              return pickCb(input.body);\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(url.parse(input, true).query);\n    }\n  }\n\n  /**\n   * @name callback\n   * @api public\n   */\n  async callback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload, DPoP } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) { // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) { // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);\n\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n      }, { clientAssertionPayload, DPoP });\n\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n  async oauthCallback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload, DPoP } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) { // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) { // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      return this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n      }, { clientAssertionPayload, DPoP });\n    }\n\n    return new TokenSet(params);\n  }\n\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n  async decryptIdToken(token) {\n    if (!this.id_token_encrypted_response_alg) {\n      return token;\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this.id_token_encrypted_response_alg;\n    const expectedEnc = this.id_token_encrypted_response_enc;\n\n    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n\n    return result;\n  }\n\n  async validateJWTUserinfo(body) {\n    const expectedAlg = this.userinfo_signed_response_alg;\n\n    return this.validateJWT(body, expectedAlg, []);\n  }\n\n  /**\n   * @name decryptJARM\n   * @api private\n   */\n  async decryptJARM(response) {\n    if (!this.authorization_encrypted_response_alg) {\n      return response;\n    }\n\n    const expectedAlg = this.authorization_encrypted_response_alg;\n    const expectedEnc = this.authorization_encrypted_response_enc;\n\n    return this.decryptJWE(response, expectedAlg, expectedEnc);\n  }\n\n  /**\n   * @name decryptJWTUserinfo\n   * @api private\n   */\n  async decryptJWTUserinfo(body) {\n    if (!this.userinfo_encrypted_response_alg) {\n      return body;\n    }\n\n    const expectedAlg = this.userinfo_encrypted_response_alg;\n    const expectedEnc = this.userinfo_encrypted_response_enc;\n\n    return this.decryptJWE(body, expectedAlg, expectedEnc);\n  }\n\n  /**\n   * @name decryptJWE\n   * @api private\n   */\n  async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {\n    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: jwe,\n      });\n    }\n\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: jwe,\n      });\n    }\n\n    let keyOrStore;\n\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      keyOrStore = instance(this).get('keystore');\n    } else {\n      keyOrStore = await this.joseSecret(expectedAlg === 'dir' ? expectedEnc : expectedAlg);\n    }\n\n    const payload = jose.JWE.decrypt(jwe, keyOrStore);\n    return payload.toString('utf8');\n  }\n\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = this.id_token_signed_response_alg;\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n\n    const timestamp = now();\n    const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n\n    if (maxAge || (maxAge !== null && this.require_auth_time)) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken,\n        });\n      }\n      if (typeof payload.auth_time !== 'number') {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON numeric value',\n          jwt: idToken,\n        });\n      }\n    }\n\n    if (maxAge && (payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE])) {\n      throw new RPError({\n        printf: ['too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i', maxAge, payload.auth_time, timestamp - this[CLOCK_TOLERANCE]],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        auth_time: payload.auth_time,\n        jwt: idToken,\n      });\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken,\n      });\n    }\n\n    const fapi = this.constructor.name === 'FAPIClient';\n\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken,\n        });\n      }\n\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken,\n        });\n      }\n\n      if (fapi) {\n        if (!payload.s_hash && (tokenSet.state || state)) {\n          throw new RPError({\n            message: 'missing required property s_hash',\n            jwt: idToken,\n          });\n        }\n      }\n\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n\n        try {\n          tokenHash.validate({ claim: 's_hash', source: 'state' }, payload.s_hash, state, header.alg, key && key.crv);\n        } catch (err) {\n          throw new RPError({ message: err.message, jwt: idToken });\n        }\n      }\n    }\n\n    if (fapi && payload.iat < timestamp - 3600) {\n      throw new RPError({\n        printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        iat: payload.iat,\n        jwt: idToken,\n      });\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate({ claim: 'at_hash', source: 'access_token' }, payload.at_hash, tokenSet.access_token, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate({ claim: 'c_hash', source: 'code' }, payload.c_hash, tokenSet.code, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    return tokenSet;\n  }\n\n  /**\n   * @name validateJWT\n   * @api private\n   */\n  async validateJWT(jwt, expectedAlg, required = ['iss', 'sub', 'aud', 'exp', 'iat']) {\n    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n    const timestamp = now();\n    let header;\n    let payload;\n    try {\n      ({ header, payload } = jose.JWT.decode(jwt, { complete: true }));\n    } catch (err) {\n      throw new RPError({\n        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],\n        jwt,\n      });\n    }\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt,\n      });\n    }\n\n    if (isSelfIssued) {\n      required = [...required, 'sub_jwk']; // eslint-disable-line no-param-reassign\n    }\n\n    required.forEach(verifyPresence.bind(undefined, payload, jwt));\n\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n\n      if (aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      if (typeof payload.iat !== 'number') {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n    }\n\n    if (payload.nbf !== undefined) {\n      if (typeof payload.nbf !== 'number') {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: ['JWT not active yet, now %i, nbf %i', timestamp + this[CLOCK_TOLERANCE], payload.nbf],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          nbf: payload.nbf,\n          jwt,\n        });\n      }\n    }\n\n    if (payload.exp !== undefined) {\n      if (typeof payload.exp !== 'number') {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          exp: payload.exp,\n          jwt,\n        });\n      }\n    }\n\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt,\n          });\n        }\n\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: ['aud is missing the client_id, expected %s to be included in %j', this.client_id, payload.aud],\n            jwt,\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      let { additionalAuthorizedParties } = instance(this).get('options') || {};\n\n      if (typeof additionalAuthorizedParties === 'string') {\n        additionalAuthorizedParties = [this.client_id, additionalAuthorizedParties];\n      } else if (Array.isArray(additionalAuthorizedParties)) {\n        additionalAuthorizedParties = [this.client_id, ...additionalAuthorizedParties];\n      } else {\n        additionalAuthorizedParties = [this.client_id];\n      }\n\n      if (!additionalAuthorizedParties.includes(payload.azp)) {\n        throw new RPError({\n          printf: ['azp mismatch, got: %s', payload.azp],\n          jwt,\n        });\n      }\n    }\n\n    let key;\n\n    if (isSelfIssued) {\n      try {\n        assert(isPlainObject(payload.sub_jwk));\n        key = jose.JWK.asKey(payload.sub_jwk);\n        assert.equal(key.type, 'public');\n      } catch (err) {\n        throw new RPError({\n          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n          jwt,\n        });\n      }\n      if (key.thumbprint !== payload.sub) {\n        throw new RPError({\n          message: 'failed to match the subject with sub_jwk',\n          jwt,\n        });\n      }\n    } else if (header.alg.startsWith('HS')) {\n      key = await this.joseSecret();\n    } else if (header.alg !== 'none') {\n      key = await this.issuer.queryKeyStore(header);\n    }\n\n    if (!key && header.alg === 'none') {\n      return { protected: header, payload };\n    }\n\n    try {\n      return {\n        ...jose.JWS.verify(jwt, key, { complete: true }),\n        payload,\n      };\n    } catch (err) {\n      throw new RPError({\n        message: 'failed to validate JWT signature',\n        jwt,\n      });\n    }\n  }\n\n  /**\n   * @name refresh\n   * @api public\n   */\n  async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n      token = token.refresh_token;\n    }\n\n    const tokenset = await this.grant({\n      ...exchangeBody,\n      grant_type: 'refresh_token',\n      refresh_token: String(token),\n    }, { clientAssertionPayload, DPoP });\n\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, null, 'token', null);\n\n      if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n        const expectedSub = refreshToken.claims().sub;\n        const actualSub = tokenset.claims().sub;\n        if (actualSub !== expectedSub) {\n          throw new RPError({\n            printf: ['sub mismatch, expected %s, got: %s', expectedSub, actualSub],\n            jwt: tokenset.id_token,\n          });\n        }\n      }\n    }\n\n    return tokenset;\n  }\n\n  async requestResource(\n    resourceUrl,\n    accessToken,\n    {\n      method,\n      headers,\n      body,\n      DPoP,\n      // eslint-disable-next-line no-nested-ternary\n      tokenType = DPoP ? 'DPoP' : accessToken instanceof TokenSet ? accessToken.token_type : 'Bearer',\n    } = {},\n  ) {\n    if (accessToken instanceof TokenSet) {\n      if (!accessToken.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n      accessToken = accessToken.access_token; // eslint-disable-line no-param-reassign\n    }\n\n    const requestOpts = {\n      headers: {\n        Authorization: authorizationHeaderValue(accessToken, tokenType),\n        ...headers,\n      },\n      body,\n    };\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    return request.call(this, {\n      ...requestOpts,\n      responseType: 'buffer',\n      method,\n      url: resourceUrl,\n    }, { accessToken, mTLS, DPoP });\n  }\n\n  /**\n   * @name userinfo\n   * @api public\n   */\n  async userinfo(accessToken, {\n    method = 'GET', via = 'header', tokenType, params, DPoP,\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    const options = {\n      tokenType,\n      method: String(method).toUpperCase(),\n      DPoP,\n    };\n\n    if (options.method !== 'GET' && options.method !== 'POST') {\n      throw new TypeError('#userinfo() method can only be POST or a GET');\n    }\n\n    if (via === 'query' && options.method !== 'GET') {\n      throw new TypeError('userinfo endpoints will only parse query strings for GET requests');\n    } else if (via === 'body' && options.method !== 'POST') {\n      throw new TypeError('can only send body on POST');\n    }\n\n    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n\n    if (jwt) {\n      options.headers = { Accept: 'application/jwt' };\n    } else {\n      options.headers = { Accept: 'application/json' };\n    }\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n    }\n\n    targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);\n\n    // when via is not header we clear the Authorization header and add either\n    // query string parameters or urlencoded body access_token parameter\n    if (via === 'query') {\n      options.headers.Authorization = undefined;\n      targetUrl.searchParams.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    } else if (via === 'body') {\n      options.headers.Authorization = undefined;\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.body = new url.URLSearchParams();\n      options.body.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    }\n\n    // handle additional parameters, GET via querystring, POST via urlencoded body\n    if (params) {\n      if (options.method === 'GET') {\n        Object.entries(params).forEach(([key, value]) => {\n          targetUrl.searchParams.append(key, value);\n        });\n      } else if (options.body) { // POST && via body\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      } else { // POST && via header\n        options.body = new url.URLSearchParams();\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      }\n    }\n\n    if (options.body) {\n      options.body = options.body.toString();\n    }\n\n    const response = await this.requestResource(targetUrl, accessToken, options);\n\n    let parsed = processResponse(response, { bearer: true });\n\n    if (jwt) {\n      if (!JWT_CONTENT.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response,\n        });\n      }\n\n      const body = response.body.toString();\n      const userinfo = await this.decryptJWTUserinfo(body);\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo,\n          });\n        }\n      } else {\n        ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n      }\n    } else {\n      try {\n        parsed = JSON.parse(response.body);\n      } catch (error) {\n        throw new ParseError(error, response);\n      }\n    }\n\n    if (accessToken instanceof TokenSet && accessToken.id_token) {\n      const expectedSub = accessToken.claims().sub;\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token,\n        });\n      }\n    }\n\n    return parsed;\n  }\n\n  /**\n   * @name derivedKey\n   * @api private\n   */\n  async derivedKey(len) {\n    const cacheKey = `${len}_key`;\n    if (instance(this).has(cacheKey)) {\n      return instance(this).get(cacheKey);\n    }\n\n    const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false; // eslint-disable-line no-nested-ternary\n    if (!hash) {\n      throw new Error('unsupported symmetric encryption key derivation');\n    }\n\n    const derivedBuffer = crypto.createHash(hash)\n      .update(this.client_secret)\n      .digest()\n      .slice(0, len / 8);\n\n    const key = jose.JWK.asKey({ k: base64url.encode(derivedBuffer), kty: 'oct' });\n    instance(this).set(cacheKey, key);\n\n    return key;\n  }\n\n  /**\n   * @name joseSecret\n   * @api private\n   */\n  async joseSecret(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n\n    if (instance(this).has('jose_secret')) {\n      return instance(this).get('jose_secret');\n    }\n\n    const key = jose.JWK.asKey({ k: base64url.encode(this.client_secret), kty: 'oct' });\n    instance(this).set('jose_secret', key);\n\n    return key;\n  }\n\n  /**\n   * @name grant\n   * @api public\n   */\n  async grant(body, { clientAssertionPayload, DPoP } = {}) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(\n      this,\n      'token',\n      {\n        form: body,\n        responseType: 'json',\n      },\n      { clientAssertionPayload, DPoP },\n    );\n    const responseBody = processResponse(response);\n\n    return new TokenSet(responseBody);\n  }\n\n  /**\n   * @name deviceAuthorization\n   * @api public\n   */\n  async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params,\n    });\n\n    const response = await authenticatedPost.call(\n      this,\n      'device_authorization',\n      {\n        responseType: 'json',\n        form: body,\n      },\n      { clientAssertionPayload, endpointAuthMethod: 'token' },\n    );\n    const responseBody = processResponse(response);\n\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age,\n      DPoP,\n    });\n  }\n\n  /**\n   * @name revoke\n   * @api public\n   */\n  async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const form = { ...revokeBody, token };\n\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'revocation', {\n        form,\n      }, { clientAssertionPayload },\n    );\n    processResponse(response, { body: false });\n  }\n\n  /**\n   * @name introspect\n   * @api public\n   */\n  async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const form = { ...introspectBody, token };\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'introspection',\n      { form, responseType: 'json' },\n      { clientAssertionPayload },\n    );\n\n    const responseBody = processResponse(response);\n\n    return responseBody;\n  }\n\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n  async fetchDistributedClaims(claims, tokens = {}) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const distributedSources = Object.entries(claims._claim_sources)\n      .filter(([, value]) => value && value.endpoint);\n\n    await Promise.all(distributedSources.map(async ([sourceName, def]) => {\n      try {\n        const requestOpts = {\n          headers: {\n            Accept: 'application/jwt',\n            Authorization: authorizationHeaderValue(def.access_token || tokens[sourceName]),\n          },\n        };\n\n        const response = await request.call(this, {\n          ...requestOpts,\n          method: 'GET',\n          url: def.endpoint,\n        });\n        const body = processResponse(response, { bearer: true });\n\n        const decoded = await claimJWT.call(this, 'distributed', body);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(\n          assignClaim(claims, decoded, sourceName, false),\n        );\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n\n    cleanUpClaims(claims);\n    return claims;\n  }\n\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n  async unpackAggregatedClaims(claims) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const aggregatedSources = Object.entries(claims._claim_sources)\n      .filter(([, value]) => value && value.JWT);\n\n    await Promise.all(aggregatedSources.map(async ([sourceName, def]) => {\n      try {\n        const decoded = await claimJWT.call(this, 'aggregated', def.JWT);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n\n    cleanUpClaims(claims);\n    return claims;\n  }\n\n  /**\n   * @name register\n   * @api public\n   */\n  static async register(metadata, options = {}) {\n    const { initialAccessToken, jwks, ...clientOptions } = options;\n\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n      const keystore = getKeystore.call(this, jwks);\n      metadata.jwks = keystore.toJWKS(false);\n      // eslint-disable-next-line no-restricted-syntax\n      for (const jwk of metadata.jwks.keys) {\n        if (jwk.kid.startsWith('DONOTUSE.')) {\n          delete jwk.kid;\n        }\n      }\n    }\n\n    const response = await request.call(this, {\n      headers: initialAccessToken ? {\n        Authorization: authorizationHeaderValue(initialAccessToken),\n      } : undefined,\n      responseType: 'json',\n      json: metadata,\n      url: this.issuer.registration_endpoint,\n      method: 'POST',\n    });\n    const responseBody = processResponse(response, { statusCode: 201, bearer: true });\n\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n\n  /**\n   * @name fromUri\n   * @api public\n   */\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      responseType: 'json',\n      headers: { Authorization: authorizationHeaderValue(registrationAccessToken) },\n    });\n    const responseBody = processResponse(response, { bearer: true });\n\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  /**\n   * @name requestObject\n   * @api public\n   */\n  async requestObject(requestObject = {}, {\n    sign: signingAlgorithm = this.request_object_signing_alg || 'none',\n    encrypt: {\n      alg: eKeyManagement = this.request_object_encryption_alg,\n      enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256',\n    } = {},\n  } = {}) {\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n\n    let signed;\n    let key;\n\n    const fapi = this.constructor.name === 'FAPIClient';\n    const unix = now();\n    const header = { alg: signingAlgorithm, typ: 'oauth-authz-req+jwt' };\n    const payload = JSON.stringify(defaults({}, requestObject, {\n      iss: this.client_id,\n      aud: this.issuer.issuer,\n      client_id: this.client_id,\n      jti: random(),\n      iat: unix,\n      exp: unix + 300,\n      ...(fapi ? { nbf: unix } : undefined),\n    }));\n\n    if (signingAlgorithm === 'none') {\n      signed = [\n        base64url.encode(JSON.stringify(header)),\n        base64url.encode(payload),\n        '',\n      ].join('.');\n    } else {\n      const symmetric = signingAlgorithm.startsWith('HS');\n      if (symmetric) {\n        key = await this.joseSecret();\n      } else {\n        const keystore = instance(this).get('keystore');\n\n        if (!keystore) {\n          throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);\n        }\n        key = keystore.get({ alg: signingAlgorithm, use: 'sig' });\n        if (!key) {\n          throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n        }\n      }\n\n      signed = jose.JWS.sign(payload, key, {\n        ...header,\n        kid: symmetric || key.kid.startsWith('DONOTUSE.') ? undefined : key.kid,\n      });\n    }\n\n    if (!eKeyManagement) {\n      return signed;\n    }\n\n    const fields = { alg: eKeyManagement, enc: eContentEncryption, cty: 'oauth-authz-req+jwt' };\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      [key] = await this.issuer.queryKeyStore({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc',\n      }, { allowMulti: true });\n    } else {\n      key = await this.joseSecret(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n\n    return jose.JWE.encrypt(signed, key, {\n      ...fields,\n      kid: key.kty === 'oct' ? undefined : key.kid,\n    });\n  }\n\n  /**\n   * @name pushedAuthorizationRequest\n   * @api public\n   */\n  async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');\n\n    const body = {\n      ...('request' in params ? params : authorizationParams.call(this, params)),\n      client_id: this.client_id,\n    };\n\n    const response = await authenticatedPost.call(\n      this,\n      'pushed_authorization_request',\n      {\n        responseType: 'json',\n        form: body,\n      },\n      { clientAssertionPayload, endpointAuthMethod: 'token' },\n    );\n    const responseBody = processResponse(response, { statusCode: 201 });\n\n    if (!('expires_in' in responseBody)) {\n      throw new RPError({\n        message: 'expected expires_in in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (typeof responseBody.expires_in !== 'number') {\n      throw new RPError({\n        message: 'invalid expires_in value in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (!('request_uri' in responseBody)) {\n      throw new RPError({\n        message: 'expected request_uri in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (typeof responseBody.request_uri !== 'string') {\n      throw new RPError({\n        message: 'invalid request_uri value in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n\n    return responseBody;\n  }\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  static get issuer() {\n    return issuer;\n  }\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  get issuer() { // eslint-disable-line class-methods-use-this\n    return issuer;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n};\n\n/**\n * @name validateJARM\n * @api private\n */\nasync function validateJARM(response) {\n  const expectedAlg = this.authorization_signed_response_alg;\n  const { payload } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);\n  return pickCb(payload);\n}\n\nObject.defineProperty(BaseClient.prototype, 'validateJARM', {\n  enumerable: true,\n  configurable: true,\n  value(...args) {\n    process.emitWarning(\n      \"The JARM API implements an OIDF implementer's draft. Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.\",\n      'DraftWarning',\n    );\n    Object.defineProperty(BaseClient.prototype, 'validateJARM', {\n      enumerable: true,\n      configurable: true,\n      value: validateJARM,\n    });\n    return this.validateJARM(...args);\n  },\n});\n\n/**\n * @name dpopProof\n * @api private\n */\nfunction dpopProof(payload, jwk, accessToken) {\n  if (!isPlainObject(payload)) {\n    throw new TypeError('payload must be a plain object');\n  }\n\n  let key;\n  try {\n    key = jose.JWK.asKey(jwk);\n    assert(key.type === 'private');\n  } catch (err) {\n    throw new TypeError('\"DPoP\" option must be an asymmetric private key to sign the DPoP Proof JWT with');\n  }\n\n  let { alg } = key;\n\n  if (!alg && this.issuer.dpop_signing_alg_values_supported) {\n    const algs = key.algorithms('sign');\n    alg = this.issuer.dpop_signing_alg_values_supported.find((a) => algs.has(a));\n  }\n\n  if (!alg) {\n    [alg] = key.algorithms('sign');\n  }\n\n  return jose.JWS.sign({\n    iat: now(),\n    jti: random(),\n    ath: accessToken ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest()) : undefined,\n    ...payload,\n  }, jwk, {\n    alg,\n    typ: 'dpop+jwt',\n    jwk: pick(key, 'kty', 'crv', 'x', 'y', 'e', 'n'),\n  });\n}\n\nObject.defineProperty(BaseClient.prototype, 'dpopProof', {\n  enumerable: true,\n  configurable: true,\n  value(...args) {\n    process.emitWarning(\n      'The DPoP APIs implements an IETF draft (https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-03.html). Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.',\n      'DraftWarning',\n    );\n    Object.defineProperty(BaseClient.prototype, 'dpopProof', {\n      enumerable: true,\n      configurable: true,\n      value: dpopProof,\n    });\n    return this.dpopProof(...args);\n  },\n});\n\nmodule.exports.BaseClient = BaseClient;\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA;AAAQ,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AACnC,MAAMC,OAAO,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC/B,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAM;EAAEG,MAAM,EAAEC;AAAO,CAAC,GAAGJ,OAAO,CAAC,QAAQ,CAAC;AAC5C,MAAMK,WAAW,GAAGL,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMM,GAAG,GAAGN,OAAO,CAAC,KAAK,CAAC;AAE1B,MAAM;EAAEO;AAAW,CAAC,GAAGP,OAAO,CAAC,KAAK,CAAC;AACrC,MAAMQ,IAAI,GAAGR,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMS,SAAS,GAAGT,OAAO,CAAC,iBAAiB,CAAC;AAE5C,MAAMU,SAAS,GAAGV,OAAO,CAAC,qBAAqB,CAAC;AAChD,MAAMW,QAAQ,GAAGX,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAM;EAAEY,6BAA6B;EAAEC;AAA0B,CAAC,GAAGb,OAAO,CAAC,kBAAkB,CAAC;AAChG,MAAMc,IAAI,GAAGd,OAAO,CAAC,gBAAgB,CAAC;AACtC,MAAMe,aAAa,GAAGf,OAAO,CAAC,2BAA2B,CAAC;AAC1D,MAAMgB,eAAe,GAAGhB,OAAO,CAAC,4BAA4B,CAAC;AAC7D,MAAMiB,QAAQ,GAAGjB,OAAO,CAAC,aAAa,CAAC;AACvC,MAAM;EAAEkB,OAAO;EAAEC;AAAQ,CAAC,GAAGnB,OAAO,CAAC,UAAU,CAAC;AAChD,MAAMoB,GAAG,GAAGpB,OAAO,CAAC,0BAA0B,CAAC;AAC/C,MAAM;EAAEqB;AAAO,CAAC,GAAGrB,OAAO,CAAC,sBAAsB,CAAC;AAClD,MAAMsB,OAAO,GAAGtB,OAAO,CAAC,mBAAmB,CAAC;AAC5C,MAAM;EACJuB,mBAAmB;EAAEC,eAAe;EAAEC,WAAW;EAAEC;AACrD,CAAC,GAAG1B,OAAO,CAAC,kBAAkB,CAAC;AAC/B,MAAM2B,cAAc,GAAG3B,OAAO,CAAC,mBAAmB,CAAC;AACnD,MAAM4B,QAAQ,GAAG5B,OAAO,CAAC,sBAAsB,CAAC;AAChD,MAAM;EAAE6B,iBAAiB;EAAEC,mBAAmB;EAAEC;AAAmB,CAAC,GAAG/B,OAAO,CAAC,kBAAkB,CAAC;AAClG,MAAMgC,gBAAgB,GAAGhC,OAAO,CAAC,sBAAsB,CAAC;AAExD,SAASiC,MAAMA,CAACC,KAAK,EAAE;EACrB,OAAOpB,IAAI,CAACoB,KAAK,EAAE,GAAGX,mBAAmB,CAAC;AAC5C;AAEA,SAASY,wBAAwBA,CAACC,KAAK,EAAEC,SAAS,GAAG,QAAQ,EAAE;EAC7D,OAAQ,GAAEA,SAAU,IAAGD,KAAM,EAAC;AAChC;AAEA,SAASE,aAAaA,CAACC,MAAM,EAAE;EAC7B,IAAIC,MAAM,CAACC,IAAI,CAACF,MAAM,CAACG,YAAY,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;IACjD,OAAOJ,MAAM,CAACG,YAAY;EAC5B;EACA,IAAIF,MAAM,CAACC,IAAI,CAACF,MAAM,CAACK,cAAc,CAAC,CAACD,MAAM,KAAK,CAAC,EAAE;IACnD,OAAOJ,MAAM,CAACK,cAAc;EAC9B;AACF;AAEA,SAASC,WAAWA,CAACC,MAAM,EAAEC,MAAM,EAAEC,UAAU,EAAEC,cAAc,GAAG,IAAI,EAAE;EACtE,OAAO,CAAC,CAACC,KAAK,EAAEC,QAAQ,CAAC,KAAK;IAC5B,IAAIA,QAAQ,KAAKH,UAAU,EAAE;MAC3B,IAAIC,cAAc,IAAIF,MAAM,CAACG,KAAK,CAAC,KAAKE,SAAS,EAAE;QACjD,MAAM,IAAIjC,OAAO,CAAE,mBAAkB+B,KAAM,SAAQF,UAAW,GAAE,CAAC;MACnE,CAAC,MAAM,IAAID,MAAM,CAACG,KAAK,CAAC,KAAKE,SAAS,EAAE;QACtCN,MAAM,CAACI,KAAK,CAAC,GAAGH,MAAM,CAACG,KAAK,CAAC;MAC/B;MACA,OAAOJ,MAAM,CAACJ,YAAY,CAACQ,KAAK,CAAC;IACnC;EACF,CAAC;AACH;AAEA,SAASG,cAAcA,CAACC,OAAO,EAAEC,GAAG,EAAEC,IAAI,EAAE;EAC1C,IAAIF,OAAO,CAACE,IAAI,CAAC,KAAKJ,SAAS,EAAE;IAC/B,MAAM,IAAIjC,OAAO,CAAC;MAChBsC,OAAO,EAAG,iCAAgCD,IAAK,EAAC;MAChDD;IACF,CAAC,CAAC;EACJ;AACF;AAEA,SAASG,mBAAmBA,CAACC,MAAM,EAAE;EACnC,MAAMC,UAAU,GAAG;IACjBC,SAAS,EAAE,IAAI,CAACA,SAAS;IACzBC,KAAK,EAAE,QAAQ;IACfC,aAAa,EAAEjC,mBAAmB,CAACkC,IAAI,CAAC,IAAI,CAAC;IAC7CC,YAAY,EAAElC,kBAAkB,CAACiC,IAAI,CAAC,IAAI,CAAC;IAC3C,GAAGL;EACL,CAAC;EAEDnB,MAAM,CAAC0B,OAAO,CAACN,UAAU,CAAC,CAACO,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;IACnD,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKjB,SAAS,EAAE;MACzC,OAAOQ,UAAU,CAACQ,GAAG,CAAC;IACxB,CAAC,MAAM,IAAIA,GAAG,KAAK,QAAQ,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;MACxDT,UAAU,CAACQ,GAAG,CAAC,GAAGE,IAAI,CAACC,SAAS,CAACF,KAAK,CAAC;IACzC,CAAC,MAAM,IAAID,GAAG,KAAK,UAAU,IAAII,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,EAAE;MACrDT,UAAU,CAACQ,GAAG,CAAC,GAAGC,KAAK;IACzB,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MACpCT,UAAU,CAACQ,GAAG,CAAC,GAAGM,MAAM,CAACL,KAAK,CAAC;IACjC;EACF,CAAC,CAAC;EAEF,OAAOT,UAAU;AACnB;AAEA,eAAee,QAAQA,CAACC,KAAK,EAAErB,GAAG,EAAE;EAClC,IAAI;IACF,MAAM;MAAEsB,MAAM;MAAEvB;IAAQ,CAAC,GAAG9C,IAAI,CAACsE,GAAG,CAACC,MAAM,CAACxB,GAAG,EAAE;MAAEyB,QAAQ,EAAE;IAAK,CAAC,CAAC;IACpE,MAAM;MAAEC;IAAI,CAAC,GAAG3B,OAAO;IAEvB,IAAIuB,MAAM,CAACK,GAAG,KAAK,MAAM,EAAE;MACzB,OAAO5B,OAAO;IAChB;IAEA,IAAIc,GAAG;IACP,IAAI,CAACa,GAAG,IAAIA,GAAG,KAAK,IAAI,CAACE,MAAM,CAACA,MAAM,EAAE;MACtCf,GAAG,GAAG,MAAM,IAAI,CAACe,MAAM,CAACC,aAAa,CAACP,MAAM,CAAC;IAC/C,CAAC,MAAM,IAAIlD,cAAc,CAAC0D,GAAG,CAACJ,GAAG,CAAC,EAAE;MAClCb,GAAG,GAAG,MAAMzC,cAAc,CAAC2D,GAAG,CAACL,GAAG,CAAC,CAACG,aAAa,CAACP,MAAM,CAAC;IAC3D,CAAC,MAAM;MACL,MAAMU,UAAU,GAAG,MAAM,IAAI,CAACJ,MAAM,CAACK,WAAW,CAACC,QAAQ,CAACR,GAAG,CAAC;MAC9Db,GAAG,GAAG,MAAMmB,UAAU,CAACH,aAAa,CAACP,MAAM,CAAC;IAC9C;IACA,OAAOrE,IAAI,CAACsE,GAAG,CAACY,MAAM,CAACnC,GAAG,EAAEa,GAAG,CAAC;EAClC,CAAC,CAAC,OAAOuB,GAAG,EAAE;IACZ,IAAIA,GAAG,YAAYxE,OAAO,IAAIwE,GAAG,YAAYzE,OAAO,IAAIyE,GAAG,CAACC,IAAI,KAAK,gBAAgB,EAAE;MACrF,MAAMD,GAAG;IACX,CAAC,MAAM;MACL,MAAM,IAAIxE,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,wCAAwC,EAAEjB,KAAK,EAAEe,GAAG,CAACC,IAAI,EAAED,GAAG,CAAClC,OAAO,CAAC;QAChFF;MACF,CAAC,CAAC;IACJ;EACF;AACF;AAEA,SAASuC,WAAWA,CAACC,IAAI,EAAE;EACzB,IAAI,CAAChF,aAAa,CAACgF,IAAI,CAAC,IAAI,CAACvB,KAAK,CAACC,OAAO,CAACsB,IAAI,CAACtD,IAAI,CAAC,IAAIsD,IAAI,CAACtD,IAAI,CAACuD,IAAI,CAAEC,CAAC,IAAK,CAAClF,aAAa,CAACkF,CAAC,CAAC,IAAI,EAAE,KAAK,IAAIA,CAAC,CAAC,CAAC,EAAE;IAClH,MAAM,IAAIC,SAAS,CAAC,kDAAkD,CAAC;EACzE;;EAEA;EACA,KAAK,MAAMC,GAAG,IAAIJ,IAAI,CAACtD,IAAI,EAAE;IAC3B,IAAI0D,GAAG,CAACC,GAAG,KAAKhD,SAAS,EAAE;MACzB+C,GAAG,CAACC,GAAG,GAAI,YAAW/E,MAAM,CAAC,CAAE,EAAC;IAClC;EACF;EAEA,MAAMgF,QAAQ,GAAG7F,IAAI,CAAC8F,IAAI,CAACC,UAAU,CAACR,IAAI,CAAC;EAC3C,IAAIM,QAAQ,CAACG,GAAG,CAAC,CAAC,CAACR,IAAI,CAAE5B,GAAG,IAAKA,GAAG,CAACqC,IAAI,KAAK,SAAS,CAAC,EAAE;IACxD,MAAM,IAAIP,SAAS,CAAC,qCAAqC,CAAC;EAC5D;EACA,OAAOG,QAAQ;AACjB;;AAEA;AACA;AACA;AACA,SAASK,iBAAiBA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,UAAU,EAAE;EACvD,IAAI;IACF,MAAMC,SAAS,GAAGH,MAAM,CAACxB,MAAM,CAAC4B,qCAAqC;IACrE,IAAI,CAACD,SAAS,CAACE,QAAQ,CAACH,UAAU,CAACI,0BAA0B,CAAC,EAAE;MAC9D,IAAIH,SAAS,CAACE,QAAQ,CAAC,oBAAoB,CAAC,EAAE;QAC5CH,UAAU,CAACI,0BAA0B,GAAG,oBAAoB;MAC9D;IACF;EACF,CAAC,CAAC,OAAOtB,GAAG,EAAE,CAAC;AACjB;AAEA,SAASuB,oBAAoBA,CAACP,MAAM,EAAEC,QAAQ,EAAEC,UAAU,EAAE;EAC1D,IAAI,CAACD,QAAQ,CAACK,0BAA0B,EAAE;IAAE;IAC1CP,iBAAiB,CAACC,MAAM,EAAEC,QAAQ,EAAEC,UAAU,CAAC;EACjD;;EAEA;EACA,IAAID,QAAQ,CAAC3C,YAAY,EAAE;IACzB,IAAI2C,QAAQ,CAACO,aAAa,EAAE;MAC1B,MAAM,IAAIjB,SAAS,CAAC,mDAAmD,CAAC;IAC1E;IACAW,UAAU,CAACM,aAAa,GAAG,CAACP,QAAQ,CAAC3C,YAAY,CAAC;IAClD,OAAO4C,UAAU,CAAC5C,YAAY;EAChC;EAEA,IAAI2C,QAAQ,CAAC7C,aAAa,EAAE;IAC1B,IAAI6C,QAAQ,CAACQ,cAAc,EAAE;MAC3B,MAAM,IAAIlB,SAAS,CAAC,qDAAqD,CAAC;IAC5E;IACAW,UAAU,CAACO,cAAc,GAAG,CAACR,QAAQ,CAAC7C,aAAa,CAAC;IACpD,OAAO8C,UAAU,CAAC9C,aAAa;EACjC;AACF;AAEA,SAASsD,sBAAsBA,CAACC,QAAQ,EAAEnC,MAAM,EAAE0B,UAAU,EAAE;EAC5D,IAAI,CAAC1B,MAAM,CAAE,GAAEmC,QAAS,WAAU,CAAC,EAAE;EAErC,MAAMC,uBAAuB,GAAGV,UAAU,CAACI,0BAA0B;EACrE,MAAMO,2BAA2B,GAAGX,UAAU,CAACY,+BAA+B;EAE9E,MAAMC,GAAG,GAAI,GAAEJ,QAAS,uBAAsB;EAC9C,MAAMK,IAAI,GAAI,GAAEL,QAAS,4BAA2B;EAEpD,IAAIT,UAAU,CAACa,GAAG,CAAC,KAAKtE,SAAS,IAAIyD,UAAU,CAACc,IAAI,CAAC,KAAKvE,SAAS,EAAE;IACnE,IAAImE,uBAAuB,KAAKnE,SAAS,EAAE;MACzCyD,UAAU,CAACa,GAAG,CAAC,GAAGH,uBAAuB;IAC3C;IACA,IAAIC,2BAA2B,KAAKpE,SAAS,EAAE;MAC7CyD,UAAU,CAACc,IAAI,CAAC,GAAGH,2BAA2B;IAChD;EACF;AACF;AAEA,MAAMI,UAAU,CAAC;AAEjBC,MAAM,CAACC,OAAO,GAAG,CAAC3C,MAAM,EAAE4C,gBAAgB,GAAG,KAAK,KAAK,MAAMC,MAAM,SAASJ,UAAU,CAAC;EACrF;AACF;AACA;AACA;EACEpC,WAAWA,CAACoB,QAAQ,GAAG,CAAC,CAAC,EAAEb,IAAI,EAAEkC,OAAO,EAAE;IACxC,KAAK,CAAC,CAAC;IAEP,IAAI,OAAOrB,QAAQ,CAAC/C,SAAS,KAAK,QAAQ,IAAI,CAAC+C,QAAQ,CAAC/C,SAAS,EAAE;MACjE,MAAM,IAAIqC,SAAS,CAAC,uBAAuB,CAAC;IAC9C;IAEA,MAAMW,UAAU,GAAG;MAAE,GAAGrF,eAAe;MAAE,GAAGoF;IAAS,CAAC;IAEtDM,oBAAoB,CAAC,IAAI,EAAEN,QAAQ,EAAEC,UAAU,CAAC;IAEhDjG,6BAA6B,CAAC,OAAO,EAAE,IAAI,CAACuE,MAAM,EAAE0B,UAAU,CAAC;IAE/D,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC1C,OAAO,CAAEmD,QAAQ,IAAK;MACpDD,sBAAsB,CAACC,QAAQ,EAAE,IAAI,CAACnC,MAAM,EAAE0B,UAAU,CAAC;MACzDjG,6BAA6B,CAAC0G,QAAQ,EAAE,IAAI,CAACnC,MAAM,EAAE0B,UAAU,CAAC;IAClE,CAAC,CAAC;IAEFrE,MAAM,CAAC0B,OAAO,CAAC2C,UAAU,CAAC,CAAC1C,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;MACnDzC,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAAC,UAAU,CAAC,CAAC4C,GAAG,CAAC9D,GAAG,EAAEC,KAAK,CAAC;MAC9C,IAAI,CAAC,IAAI,CAACD,GAAG,CAAC,EAAE;QACd5B,MAAM,CAAC2F,cAAc,CAAC,IAAI,EAAE/D,GAAG,EAAE;UAC/BkB,GAAGA,CAAA,EAAG;YAAE,OAAO1D,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAAC,UAAU,CAAC,CAACA,GAAG,CAAClB,GAAG,CAAC;UAAE,CAAC;UACzDgE,UAAU,EAAE;QACd,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IAEF,IAAIrC,IAAI,KAAK3C,SAAS,EAAE;MACtB,MAAMiD,QAAQ,GAAGP,WAAW,CAAC9B,IAAI,CAAC,IAAI,EAAE+B,IAAI,CAAC;MAC7CnE,QAAQ,CAAC,IAAI,CAAC,CAACsG,GAAG,CAAC,UAAU,EAAE7B,QAAQ,CAAC;IAC1C;IAEA,IAAI4B,OAAO,KAAK7E,SAAS,EAAE;MACzBxB,QAAQ,CAAC,IAAI,CAAC,CAACsG,GAAG,CAAC,SAAS,EAAED,OAAO,CAAC;IACxC;IAEA,IAAI,CAACvG,eAAe,CAAC,GAAG,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;EACE2G,gBAAgBA,CAAC1E,MAAM,GAAG,CAAC,CAAC,EAAE;IAC5B,IAAI,CAAC5C,aAAa,CAAC4C,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAIuC,SAAS,CAAC,+BAA+B,CAAC;IACtD;IACArF,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,wBAAwB,CAAC;IAChE,MAAMrC,MAAM,GAAGxC,GAAG,CAACgI,KAAK,CAAC,IAAI,CAACnD,MAAM,CAACoD,sBAAsB,EAAE,IAAI,CAAC;IAClEzF,MAAM,CAAC0F,MAAM,GAAG,IAAI;IACpB1F,MAAM,CAAC2F,KAAK,GAAG;MACb,GAAG3F,MAAM,CAAC2F,KAAK;MACf,GAAG/E,mBAAmB,CAACM,IAAI,CAAC,IAAI,EAAEL,MAAM;IAC1C,CAAC;IACD,OAAOrD,GAAG,CAACoI,MAAM,CAAC5F,MAAM,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;EACE6F,iBAAiBA,CAAChF,MAAM,GAAG,CAAC,CAAC,EAAE;IAC7B,IAAI,CAAC5C,aAAa,CAAC4C,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAIuC,SAAS,CAAC,+BAA+B,CAAC;IACtD;IACA,MAAM0C,MAAM,GAAGlF,mBAAmB,CAACM,IAAI,CAAC,IAAI,EAAEL,MAAM,CAAC;IACrD,MAAMkF,UAAU,GAAGrG,MAAM,CAACC,IAAI,CAACmG,MAAM,CAAC,CACnCE,GAAG,CAAElD,IAAI,IAAM,8BAA6BA,IAAK,YAAWgD,MAAM,CAAChD,IAAI,CAAE,KAAI,CAAC,CAACmD,IAAI,CAAC,IAAI,CAAC;IAE5F,OAAQ;AACZ;AACA;AACA;AACA;AACA,gCAAgC,IAAI,CAAC5D,MAAM,CAACoD,sBAAuB;AACnE,MAAMM,UAAW;AACjB;AACA;AACA,QAAQ;EACN;;EAEA;AACF;AACA;AACA;EACEG,aAAaA,CAACrF,MAAM,GAAG,CAAC,CAAC,EAAE;IACzB9C,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,sBAAsB,CAAC;IAE9D,MAAM;MACJ,CAAC,EAAE8D,UAAU;MACbtG;IACF,CAAC,GAAG,IAAI,CAACuG,yBAAyB,IAAI,EAAE;IAExC,MAAM;MACJC,wBAAwB,GAAGxG,MAAM,KAAK,CAAC,GAAGsG,UAAU,GAAG7F;IACzD,CAAC,GAAGO,MAAM;IAEV,IAAIyF,IAAI,GAAGzF,MAAM,CAAC0F,aAAa;IAE/B,IAAID,IAAI,YAAYnI,QAAQ,EAAE;MAC5B,IAAI,CAACmI,IAAI,CAACE,QAAQ,EAAE;QAClB,MAAM,IAAIpD,SAAS,CAAC,kCAAkC,CAAC;MACzD;MACAkD,IAAI,GAAGA,IAAI,CAACE,QAAQ;IACtB;IAEA,MAAMxG,MAAM,GAAGxC,GAAG,CAACgI,KAAK,CAAC,IAAI,CAACnD,MAAM,CAACoE,oBAAoB,EAAE,IAAI,CAAC;IAChEzG,MAAM,CAAC0F,MAAM,GAAG,IAAI;IACpB1F,MAAM,CAAC2F,KAAK,GAAG;MACb,GAAG9E,MAAM;MACT,GAAGb,MAAM,CAAC2F,KAAK;MACf,GAAG;QACDU,wBAAwB;QACxBE,aAAa,EAAED;MACjB;IACF,CAAC;IAED5G,MAAM,CAAC0B,OAAO,CAACpB,MAAM,CAAC2F,KAAK,CAAC,CAACtE,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;MACrD,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKjB,SAAS,EAAE;QACzC,OAAON,MAAM,CAAC2F,KAAK,CAACrE,GAAG,CAAC;MAC1B;IACF,CAAC,CAAC;IAEF,OAAO9D,GAAG,CAACoI,MAAM,CAAC5F,MAAM,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;EACE0G,cAAcA,CAACtH,KAAK,EAAE;IAAE;IACtB,MAAMuH,iBAAiB,GAAGvH,KAAK,YAAYjC,OAAO,CAACyJ,eAAe,IAC5DxH,KAAK,IAAIA,KAAK,CAACyH,MAAM,IAAIzH,KAAK,CAAC5B,GAAI;IACzC,MAAMsJ,QAAQ,GAAG,OAAO1H,KAAK,KAAK,QAAQ;IAE1C,IAAI,CAAC0H,QAAQ,IAAI,CAACH,iBAAiB,EAAE;MACnC,MAAM,IAAIvD,SAAS,CAAC,+EAA+E,CAAC;IACtG;IAEA,IAAIuD,iBAAiB,EAAE;MACrB,QAAQvH,KAAK,CAACyH,MAAM;QAClB,KAAK,KAAK;UACR,OAAO1H,MAAM,CAAC3B,GAAG,CAACgI,KAAK,CAACpG,KAAK,CAAC5B,GAAG,EAAE,IAAI,CAAC,CAACmI,KAAK,CAAC;QACjD,KAAK,MAAM;UACT,IAAIvG,KAAK,CAAC2H,IAAI,KAAKzG,SAAS,EAAE;YAC5B,MAAM,IAAI8C,SAAS,CAAC,gFAAgF,CAAC;UACvG;UACA,QAAQ,OAAOhE,KAAK,CAAC2H,IAAI;YACvB,KAAK,QAAQ;YACb,KAAK,QAAQ;cACX,IAAIC,MAAM,CAACC,QAAQ,CAAC7H,KAAK,CAAC2H,IAAI,CAAC,EAAE;gBAC/B,OAAO5H,MAAM,CAAC5B,WAAW,CAACiI,KAAK,CAACpG,KAAK,CAAC2H,IAAI,CAACG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;cAChE;cACA,IAAI,OAAO9H,KAAK,CAAC2H,IAAI,KAAK,QAAQ,EAAE;gBAClC,OAAO5H,MAAM,CAAC5B,WAAW,CAACiI,KAAK,CAACpG,KAAK,CAAC2H,IAAI,CAAC,CAAC;cAC9C;cAEA,OAAO5H,MAAM,CAACC,KAAK,CAAC2H,IAAI,CAAC;YAC3B;cACE,MAAM,IAAI3D,SAAS,CAAC,qCAAqC,CAAC;UAC9D;QACF;UACE,MAAM,IAAIA,SAAS,CAAC,gCAAgC,CAAC;MACzD;IACF,CAAC,MAAM;MACL,OAAOjE,MAAM,CAAC3B,GAAG,CAACgI,KAAK,CAACpG,KAAK,EAAE,IAAI,CAAC,CAACuG,KAAK,CAAC;IAC7C;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMwB,QAAQA,CACZC,WAAW,EACXC,UAAU,EACVC,MAAM,GAAG,CAAC,CAAC,EACX;IAAEC,YAAY;IAAEC,sBAAsB;IAAEC;EAAK,CAAC,GAAG,CAAC,CAAC,EACnD;IACA,IAAI5G,MAAM,GAAG1B,MAAM,CAACkI,UAAU,CAAC;IAE/B,IAAIC,MAAM,CAACI,IAAI,IAAI,EAAE,UAAU,IAAIL,UAAU,CAAC,EAAE;MAC9C,MAAM,IAAIhJ,OAAO,CAAC;QAChBsC,OAAO,EAAE,0BAA0B;QACnC2G,MAAM;QACNzG;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI,UAAU,IAAIwG,UAAU,EAAE;MACnC,MAAMM,SAAS,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC/G,MAAM,CAACgH,QAAQ,CAAC;MACzDhH,MAAM,GAAG,MAAM,IAAI,CAACiH,YAAY,CAACH,SAAS,CAAC;IAC7C;IAEA,IAAI,IAAI,CAACI,eAAe,IAAI,CAACT,MAAM,CAACU,OAAO,EAAE;MAC3CV,MAAM,CAACU,OAAO,GAAG,IAAI,CAACD,eAAe;IACvC;IAEA,IAAIlH,MAAM,CAACoH,KAAK,IAAI,CAACX,MAAM,CAACW,KAAK,EAAE;MACjC,MAAM,IAAI7E,SAAS,CAAC,kCAAkC,CAAC;IACzD;IAEA,IAAI,CAACvC,MAAM,CAACoH,KAAK,IAAIX,MAAM,CAACW,KAAK,EAAE;MACjC,MAAM,IAAI5J,OAAO,CAAC;QAChBsC,OAAO,EAAE,iCAAiC;QAC1C2G,MAAM;QACNzG;MACF,CAAC,CAAC;IACJ;IAEA,IAAIyG,MAAM,CAACW,KAAK,KAAKpH,MAAM,CAACoH,KAAK,EAAE;MACjC,MAAM,IAAI5J,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,sCAAsC,EAAEuE,MAAM,CAACW,KAAK,EAAEpH,MAAM,CAACoH,KAAK,CAAC;QAC5EX,MAAM;QACNzG;MACF,CAAC,CAAC;IACJ;IAEA,IAAIA,MAAM,CAACqH,KAAK,EAAE;MAChB,MAAM,IAAI9J,OAAO,CAACyC,MAAM,CAAC;IAC3B;IAEA,MAAMsH,6BAA6B,GAAG;MACpCC,IAAI,EAAE,CAAC,MAAM,CAAC;MACd5B,QAAQ,EAAE,CAAC,UAAU,CAAC;MACtBlH,KAAK,EAAE,CAAC,cAAc,EAAE,YAAY;IACtC,CAAC;IAED,IAAIgI,MAAM,CAACrG,aAAa,EAAE;MACxB,KAAK,MAAM0C,IAAI,IAAI2D,MAAM,CAACrG,aAAa,CAACoH,KAAK,CAAC,GAAG,CAAC,EAAE;QAAE;QACpD,IAAI1E,IAAI,KAAK,MAAM,EAAE;UACnB,IAAI9C,MAAM,CAACuH,IAAI,IAAIvH,MAAM,CAAC2F,QAAQ,IAAI3F,MAAM,CAACyH,YAAY,EAAE;YACzD,MAAM,IAAIjK,OAAO,CAAC;cAChBsC,OAAO,EAAE,mDAAmD;cAC5D2G,MAAM;cACNzG;YACF,CAAC,CAAC;UACJ;QACF,CAAC,MAAM;UACL,KAAK,MAAM0H,KAAK,IAAIJ,6BAA6B,CAACxE,IAAI,CAAC,EAAE;YAAE;YACzD,IAAI,CAAC9C,MAAM,CAAC0H,KAAK,CAAC,EAAE;cAClB,MAAM,IAAIlK,OAAO,CAAC;gBAChBsC,OAAO,EAAG,GAAE4H,KAAM,wBAAuB;gBACzCjB,MAAM;gBACNzG;cACF,CAAC,CAAC;YACJ;UACF;QACF;MACF;IACF;IAEA,IAAIA,MAAM,CAAC2F,QAAQ,EAAE;MACnB,MAAMgC,QAAQ,GAAG,IAAIrK,QAAQ,CAAC0C,MAAM,CAAC;MACrC,MAAM,IAAI,CAAC4H,cAAc,CAACD,QAAQ,CAAC;MACnC,MAAM,IAAI,CAACE,eAAe,CAACF,QAAQ,EAAElB,MAAM,CAACqB,KAAK,EAAE,eAAe,EAAErB,MAAM,CAACU,OAAO,EAAEV,MAAM,CAACW,KAAK,CAAC;MAEjG,IAAI,CAACpH,MAAM,CAACuH,IAAI,EAAE;QAChB,OAAOI,QAAQ;MACjB;IACF;IAEA,IAAI3H,MAAM,CAACuH,IAAI,EAAE;MACf,MAAMI,QAAQ,GAAG,MAAM,IAAI,CAACI,KAAK,CAAC;QAChC,GAAGrB,YAAY;QACfsB,UAAU,EAAE,oBAAoB;QAChCT,IAAI,EAAEvH,MAAM,CAACuH,IAAI;QACjBjH,YAAY,EAAEiG,WAAW;QACzB0B,aAAa,EAAExB,MAAM,CAACwB;MACxB,CAAC,EAAE;QAAEtB,sBAAsB;QAAEC;MAAK,CAAC,CAAC;MAEpC,MAAM,IAAI,CAACgB,cAAc,CAACD,QAAQ,CAAC;MACnC,MAAM,IAAI,CAACE,eAAe,CAACF,QAAQ,EAAElB,MAAM,CAACqB,KAAK,EAAE,OAAO,EAAErB,MAAM,CAACU,OAAO,CAAC;MAE3E,IAAInH,MAAM,CAACkI,aAAa,EAAE;QACxBP,QAAQ,CAACO,aAAa,GAAGlI,MAAM,CAACkI,aAAa;MAC/C;MAEA,OAAOP,QAAQ;IACjB;IAEA,OAAO,IAAIrK,QAAQ,CAAC0C,MAAM,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;EACE,MAAMmI,aAAaA,CACjB5B,WAAW,EACXC,UAAU,EACVC,MAAM,GAAG,CAAC,CAAC,EACX;IAAEC,YAAY;IAAEC,sBAAsB;IAAEC;EAAK,CAAC,GAAG,CAAC,CAAC,EACnD;IACA,IAAI5G,MAAM,GAAG1B,MAAM,CAACkI,UAAU,CAAC;IAE/B,IAAIC,MAAM,CAACI,IAAI,IAAI,EAAE,UAAU,IAAIL,UAAU,CAAC,EAAE;MAC9C,MAAM,IAAIhJ,OAAO,CAAC;QAChBsC,OAAO,EAAE,0BAA0B;QACnC2G,MAAM;QACNzG;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI,UAAU,IAAIwG,UAAU,EAAE;MACnC,MAAMM,SAAS,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC/G,MAAM,CAACgH,QAAQ,CAAC;MACzDhH,MAAM,GAAG,MAAM,IAAI,CAACiH,YAAY,CAACH,SAAS,CAAC;IAC7C;IAEA,IAAI9G,MAAM,CAACoH,KAAK,IAAI,CAACX,MAAM,CAACW,KAAK,EAAE;MACjC,MAAM,IAAI7E,SAAS,CAAC,kCAAkC,CAAC;IACzD;IAEA,IAAI,CAACvC,MAAM,CAACoH,KAAK,IAAIX,MAAM,CAACW,KAAK,EAAE;MACjC,MAAM,IAAI5J,OAAO,CAAC;QAChBsC,OAAO,EAAE,iCAAiC;QAC1C2G,MAAM;QACNzG;MACF,CAAC,CAAC;IACJ;IAEA,IAAIyG,MAAM,CAACW,KAAK,KAAKpH,MAAM,CAACoH,KAAK,EAAE;MACjC,MAAM,IAAI5J,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,sCAAsC,EAAEuE,MAAM,CAACW,KAAK,EAAEpH,MAAM,CAACoH,KAAK,CAAC;QAC5EX,MAAM;QACNzG;MACF,CAAC,CAAC;IACJ;IAEA,IAAIA,MAAM,CAACqH,KAAK,EAAE;MAChB,MAAM,IAAI9J,OAAO,CAACyC,MAAM,CAAC;IAC3B;IAEA,MAAMsH,6BAA6B,GAAG;MACpCC,IAAI,EAAE,CAAC,MAAM,CAAC;MACd9I,KAAK,EAAE,CAAC,cAAc,EAAE,YAAY;IACtC,CAAC;IAED,IAAIgI,MAAM,CAACrG,aAAa,EAAE;MACxB,KAAK,MAAM0C,IAAI,IAAI2D,MAAM,CAACrG,aAAa,CAACoH,KAAK,CAAC,GAAG,CAAC,EAAE;QAAE;QACpD,IAAI1E,IAAI,KAAK,MAAM,EAAE;UACnB,IAAI9C,MAAM,CAACuH,IAAI,IAAIvH,MAAM,CAAC2F,QAAQ,IAAI3F,MAAM,CAACyH,YAAY,EAAE;YACzD,MAAM,IAAIjK,OAAO,CAAC;cAChBsC,OAAO,EAAE,mDAAmD;cAC5D2G,MAAM;cACNzG;YACF,CAAC,CAAC;UACJ;QACF;QAEA,IAAIsH,6BAA6B,CAACxE,IAAI,CAAC,EAAE;UACvC,KAAK,MAAM4E,KAAK,IAAIJ,6BAA6B,CAACxE,IAAI,CAAC,EAAE;YAAE;YACzD,IAAI,CAAC9C,MAAM,CAAC0H,KAAK,CAAC,EAAE;cAClB,MAAM,IAAIlK,OAAO,CAAC;gBAChBsC,OAAO,EAAG,GAAE4H,KAAM,wBAAuB;gBACzCjB,MAAM;gBACNzG;cACF,CAAC,CAAC;YACJ;UACF;QACF;MACF;IACF;IAEA,IAAIA,MAAM,CAACuH,IAAI,EAAE;MACf,OAAO,IAAI,CAACQ,KAAK,CAAC;QAChB,GAAGrB,YAAY;QACfsB,UAAU,EAAE,oBAAoB;QAChCT,IAAI,EAAEvH,MAAM,CAACuH,IAAI;QACjBjH,YAAY,EAAEiG,WAAW;QACzB0B,aAAa,EAAExB,MAAM,CAACwB;MACxB,CAAC,EAAE;QAAEtB,sBAAsB;QAAEC;MAAK,CAAC,CAAC;IACtC;IAEA,OAAO,IAAItJ,QAAQ,CAAC0C,MAAM,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;EACE,MAAM4H,cAAcA,CAACnJ,KAAK,EAAE;IAC1B,IAAI,CAAC,IAAI,CAAC2J,+BAA+B,EAAE;MACzC,OAAO3J,KAAK;IACd;IAEA,IAAI4J,OAAO,GAAG5J,KAAK;IAEnB,IAAI4J,OAAO,YAAY/K,QAAQ,EAAE;MAC/B,IAAI,CAAC+K,OAAO,CAAC1C,QAAQ,EAAE;QACrB,MAAM,IAAIpD,SAAS,CAAC,kCAAkC,CAAC;MACzD;MACA8F,OAAO,GAAGA,OAAO,CAAC1C,QAAQ;IAC5B;IAEA,MAAM2C,WAAW,GAAG,IAAI,CAACF,+BAA+B;IACxD,MAAMG,WAAW,GAAG,IAAI,CAACC,+BAA+B;IAExD,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACC,UAAU,CAACL,OAAO,EAAEC,WAAW,EAAEC,WAAW,CAAC;IAEvE,IAAI9J,KAAK,YAAYnB,QAAQ,EAAE;MAC7BmB,KAAK,CAACkH,QAAQ,GAAG8C,MAAM;MACvB,OAAOhK,KAAK;IACd;IAEA,OAAOgK,MAAM;EACf;EAEA,MAAME,mBAAmBA,CAACzC,IAAI,EAAE;IAC9B,MAAMoC,WAAW,GAAG,IAAI,CAACM,4BAA4B;IAErD,OAAO,IAAI,CAACC,WAAW,CAAC3C,IAAI,EAAEoC,WAAW,EAAE,EAAE,CAAC;EAChD;;EAEA;AACF;AACA;AACA;EACE,MAAMvB,WAAWA,CAACC,QAAQ,EAAE;IAC1B,IAAI,CAAC,IAAI,CAAC8B,oCAAoC,EAAE;MAC9C,OAAO9B,QAAQ;IACjB;IAEA,MAAMsB,WAAW,GAAG,IAAI,CAACQ,oCAAoC;IAC7D,MAAMP,WAAW,GAAG,IAAI,CAACQ,oCAAoC;IAE7D,OAAO,IAAI,CAACL,UAAU,CAAC1B,QAAQ,EAAEsB,WAAW,EAAEC,WAAW,CAAC;EAC5D;;EAEA;AACF;AACA;AACA;EACE,MAAMS,kBAAkBA,CAAC9C,IAAI,EAAE;IAC7B,IAAI,CAAC,IAAI,CAAC+C,+BAA+B,EAAE;MACzC,OAAO/C,IAAI;IACb;IAEA,MAAMoC,WAAW,GAAG,IAAI,CAACW,+BAA+B;IACxD,MAAMV,WAAW,GAAG,IAAI,CAACW,+BAA+B;IAExD,OAAO,IAAI,CAACR,UAAU,CAACxC,IAAI,EAAEoC,WAAW,EAAEC,WAAW,CAAC;EACxD;;EAEA;AACF;AACA;AACA;EACE,MAAMG,UAAUA,CAACS,GAAG,EAAEb,WAAW,EAAEC,WAAW,GAAG,eAAe,EAAE;IAChE,MAAMrH,MAAM,GAAGP,IAAI,CAACgE,KAAK,CAAC5H,SAAS,CAACqE,MAAM,CAAC+H,GAAG,CAAC3B,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAE9D,IAAItG,MAAM,CAACK,GAAG,KAAK+G,WAAW,EAAE;MAC9B,MAAM,IAAI9K,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,mDAAmD,EAAEoG,WAAW,EAAEpH,MAAM,CAACK,GAAG,CAAC;QACtF3B,GAAG,EAAEuJ;MACP,CAAC,CAAC;IACJ;IAEA,IAAIjI,MAAM,CAACkI,GAAG,KAAKb,WAAW,EAAE;MAC9B,MAAM,IAAI/K,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,mDAAmD,EAAEqG,WAAW,EAAErH,MAAM,CAACkI,GAAG,CAAC;QACtFxJ,GAAG,EAAEuJ;MACP,CAAC,CAAC;IACJ;IAEA,IAAIE,UAAU;IAEd,IAAIf,WAAW,CAACgB,KAAK,CAAC,eAAe,CAAC,EAAE;MACtCD,UAAU,GAAGpL,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAAC,UAAU,CAAC;IAC7C,CAAC,MAAM;MACL0H,UAAU,GAAG,MAAM,IAAI,CAACE,UAAU,CAACjB,WAAW,KAAK,KAAK,GAAGC,WAAW,GAAGD,WAAW,CAAC;IACvF;IAEA,MAAM3I,OAAO,GAAG9C,IAAI,CAAC2M,GAAG,CAACC,OAAO,CAACN,GAAG,EAAEE,UAAU,CAAC;IACjD,OAAO1J,OAAO,CAAC0G,QAAQ,CAAC,MAAM,CAAC;EACjC;;EAEA;AACF;AACA;AACA;EACE,MAAMwB,eAAeA,CAAC6B,QAAQ,EAAE5B,KAAK,EAAE6B,UAAU,EAAEC,MAAM,EAAExC,KAAK,EAAE;IAChE,IAAIiB,OAAO,GAAGqB,QAAQ;IAEtB,MAAMpB,WAAW,GAAG,IAAI,CAACuB,4BAA4B;IAErD,MAAMC,UAAU,GAAGzB,OAAO,YAAY/K,QAAQ;IAE9C,IAAIwM,UAAU,EAAE;MACd,IAAI,CAACzB,OAAO,CAAC1C,QAAQ,EAAE;QACrB,MAAM,IAAIpD,SAAS,CAAC,kCAAkC,CAAC;MACzD;MACA8F,OAAO,GAAGA,OAAO,CAAC1C,QAAQ;IAC5B;IAEA0C,OAAO,GAAGtH,MAAM,CAACsH,OAAO,CAAC;IAEzB,MAAM0B,SAAS,GAAGtM,GAAG,CAAC,CAAC;IACvB,MAAM;MAAEuM,SAAS,EAAE9I,MAAM;MAAEvB,OAAO;MAAEc;IAAI,CAAC,GAAG,MAAM,IAAI,CAACoI,WAAW,CAACR,OAAO,EAAEC,WAAW,CAAC;IAExF,IAAIsB,MAAM,IAAKA,MAAM,KAAK,IAAI,IAAI,IAAI,CAACK,iBAAkB,EAAE;MACzD,IAAI,CAACtK,OAAO,CAACuK,SAAS,EAAE;QACtB,MAAM,IAAI1M,OAAO,CAAC;UAChBsC,OAAO,EAAE,yCAAyC;UAClDF,GAAG,EAAEyI;QACP,CAAC,CAAC;MACJ;MACA,IAAI,OAAO1I,OAAO,CAACuK,SAAS,KAAK,QAAQ,EAAE;QACzC,MAAM,IAAI1M,OAAO,CAAC;UAChBsC,OAAO,EAAE,kDAAkD;UAC3DF,GAAG,EAAEyI;QACP,CAAC,CAAC;MACJ;IACF;IAEA,IAAIuB,MAAM,IAAKjK,OAAO,CAACuK,SAAS,GAAGN,MAAM,GAAGG,SAAS,GAAG,IAAI,CAAChM,eAAe,CAAE,EAAE;MAC9E,MAAM,IAAIP,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,qGAAqG,EAAE0H,MAAM,EAAEjK,OAAO,CAACuK,SAAS,EAAEH,SAAS,GAAG,IAAI,CAAChM,eAAe,CAAC,CAAC;QAC7KN,GAAG,EAAEsM,SAAS;QACdI,SAAS,EAAE,IAAI,CAACpM,eAAe,CAAC;QAChCmM,SAAS,EAAEvK,OAAO,CAACuK,SAAS;QAC5BtK,GAAG,EAAEyI;MACP,CAAC,CAAC;IACJ;IAEA,IAAIP,KAAK,KAAK,IAAI,KAAKnI,OAAO,CAACmI,KAAK,IAAIA,KAAK,KAAKrI,SAAS,CAAC,IAAIE,OAAO,CAACmI,KAAK,KAAKA,KAAK,EAAE;MACvF,MAAM,IAAItK,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,sCAAsC,EAAE4F,KAAK,EAAEnI,OAAO,CAACmI,KAAK,CAAC;QACtElI,GAAG,EAAEyI;MACP,CAAC,CAAC;IACJ;IAEA,MAAM+B,IAAI,GAAG,IAAI,CAACvI,WAAW,CAACI,IAAI,KAAK,YAAY;IAEnD,IAAI0H,UAAU,KAAK,eAAe,EAAE;MAClC,IAAI,CAAChK,OAAO,CAAC0K,OAAO,IAAIX,QAAQ,CAACjC,YAAY,EAAE;QAC7C,MAAM,IAAIjK,OAAO,CAAC;UAChBsC,OAAO,EAAE,mCAAmC;UAC5CF,GAAG,EAAEyI;QACP,CAAC,CAAC;MACJ;MAEA,IAAI,CAAC1I,OAAO,CAAC2K,MAAM,IAAIZ,QAAQ,CAACnC,IAAI,EAAE;QACpC,MAAM,IAAI/J,OAAO,CAAC;UAChBsC,OAAO,EAAE,kCAAkC;UAC3CF,GAAG,EAAEyI;QACP,CAAC,CAAC;MACJ;MAEA,IAAI+B,IAAI,EAAE;QACR,IAAI,CAACzK,OAAO,CAAC4K,MAAM,KAAKb,QAAQ,CAACtC,KAAK,IAAIA,KAAK,CAAC,EAAE;UAChD,MAAM,IAAI5J,OAAO,CAAC;YAChBsC,OAAO,EAAE,kCAAkC;YAC3CF,GAAG,EAAEyI;UACP,CAAC,CAAC;QACJ;MACF;MAEA,IAAI1I,OAAO,CAAC4K,MAAM,EAAE;QAClB,IAAI,CAACnD,KAAK,EAAE;UACV,MAAM,IAAI7E,SAAS,CAAC,4DAA4D,CAAC;QACnF;QAEA,IAAI;UACFzF,SAAS,CAAC0N,QAAQ,CAAC;YAAEjL,KAAK,EAAE,QAAQ;YAAEH,MAAM,EAAE;UAAQ,CAAC,EAAEO,OAAO,CAAC4K,MAAM,EAAEnD,KAAK,EAAElG,MAAM,CAACK,GAAG,EAAEd,GAAG,IAAIA,GAAG,CAACgK,GAAG,CAAC;QAC7G,CAAC,CAAC,OAAOzI,GAAG,EAAE;UACZ,MAAM,IAAIxE,OAAO,CAAC;YAAEsC,OAAO,EAAEkC,GAAG,CAAClC,OAAO;YAAEF,GAAG,EAAEyI;UAAQ,CAAC,CAAC;QAC3D;MACF;IACF;IAEA,IAAI+B,IAAI,IAAIzK,OAAO,CAAC+K,GAAG,GAAGX,SAAS,GAAG,IAAI,EAAE;MAC1C,MAAM,IAAIvM,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,gDAAgD,EAAE6H,SAAS,EAAEpK,OAAO,CAAC+K,GAAG,CAAC;QAClFjN,GAAG,EAAEsM,SAAS;QACdI,SAAS,EAAE,IAAI,CAACpM,eAAe,CAAC;QAChC2M,GAAG,EAAE/K,OAAO,CAAC+K,GAAG;QAChB9K,GAAG,EAAEyI;MACP,CAAC,CAAC;IACJ;IAEA,IAAIqB,QAAQ,CAACjC,YAAY,IAAI9H,OAAO,CAAC0K,OAAO,KAAK5K,SAAS,EAAE;MAC1D,IAAI;QACF3C,SAAS,CAAC0N,QAAQ,CAAC;UAAEjL,KAAK,EAAE,SAAS;UAAEH,MAAM,EAAE;QAAe,CAAC,EAAEO,OAAO,CAAC0K,OAAO,EAAEX,QAAQ,CAACjC,YAAY,EAAEvG,MAAM,CAACK,GAAG,EAAEd,GAAG,IAAIA,GAAG,CAACgK,GAAG,CAAC;MACtI,CAAC,CAAC,OAAOzI,GAAG,EAAE;QACZ,MAAM,IAAIxE,OAAO,CAAC;UAAEsC,OAAO,EAAEkC,GAAG,CAAClC,OAAO;UAAEF,GAAG,EAAEyI;QAAQ,CAAC,CAAC;MAC3D;IACF;IAEA,IAAIqB,QAAQ,CAACnC,IAAI,IAAI5H,OAAO,CAAC2K,MAAM,KAAK7K,SAAS,EAAE;MACjD,IAAI;QACF3C,SAAS,CAAC0N,QAAQ,CAAC;UAAEjL,KAAK,EAAE,QAAQ;UAAEH,MAAM,EAAE;QAAO,CAAC,EAAEO,OAAO,CAAC2K,MAAM,EAAEZ,QAAQ,CAACnC,IAAI,EAAErG,MAAM,CAACK,GAAG,EAAEd,GAAG,IAAIA,GAAG,CAACgK,GAAG,CAAC;MACpH,CAAC,CAAC,OAAOzI,GAAG,EAAE;QACZ,MAAM,IAAIxE,OAAO,CAAC;UAAEsC,OAAO,EAAEkC,GAAG,CAAClC,OAAO;UAAEF,GAAG,EAAEyI;QAAQ,CAAC,CAAC;MAC3D;IACF;IAEA,OAAOqB,QAAQ;EACjB;;EAEA;AACF;AACA;AACA;EACE,MAAMb,WAAWA,CAACjJ,GAAG,EAAE0I,WAAW,EAAEqC,QAAQ,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE;IAClF,MAAMC,YAAY,GAAG,IAAI,CAACpJ,MAAM,CAACA,MAAM,KAAK,wBAAwB;IACpE,MAAMuI,SAAS,GAAGtM,GAAG,CAAC,CAAC;IACvB,IAAIyD,MAAM;IACV,IAAIvB,OAAO;IACX,IAAI;MACF,CAAC;QAAEuB,MAAM;QAAEvB;MAAQ,CAAC,GAAG9C,IAAI,CAACsE,GAAG,CAACC,MAAM,CAACxB,GAAG,EAAE;QAAEyB,QAAQ,EAAE;MAAK,CAAC,CAAC;IACjE,CAAC,CAAC,OAAOW,GAAG,EAAE;MACZ,MAAM,IAAIxE,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,+BAA+B,EAAEF,GAAG,CAACC,IAAI,EAAED,GAAG,CAAClC,OAAO,CAAC;QAChEF;MACF,CAAC,CAAC;IACJ;IAEA,IAAIsB,MAAM,CAACK,GAAG,KAAK+G,WAAW,EAAE;MAC9B,MAAM,IAAI9K,OAAO,CAAC;QAChB0E,MAAM,EAAE,CAAC,mDAAmD,EAAEoG,WAAW,EAAEpH,MAAM,CAACK,GAAG,CAAC;QACtF3B;MACF,CAAC,CAAC;IACJ;IAEA,IAAIgL,YAAY,EAAE;MAChBD,QAAQ,GAAG,CAAC,GAAGA,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAC;IACvC;IAEAA,QAAQ,CAACnK,OAAO,CAACd,cAAc,CAACmL,IAAI,CAACpL,SAAS,EAAEE,OAAO,EAAEC,GAAG,CAAC,CAAC;IAE9D,IAAID,OAAO,CAAC2B,GAAG,KAAK7B,SAAS,EAAE;MAC7B,IAAIqL,WAAW,GAAG,IAAI,CAACtJ,MAAM,CAACA,MAAM;MAEpC,IAAI4C,gBAAgB,EAAE;QACpB0G,WAAW,GAAG,IAAI,CAACtJ,MAAM,CAACA,MAAM,CAACuJ,OAAO,CAAC,YAAY,EAAEpL,OAAO,CAACqL,GAAG,CAAC;MACrE;MAEA,IAAIrL,OAAO,CAAC2B,GAAG,KAAKwJ,WAAW,EAAE;QAC/B,MAAM,IAAItN,OAAO,CAAC;UAChB0E,MAAM,EAAE,CAAC,4CAA4C,EAAE4I,WAAW,EAAEnL,OAAO,CAAC2B,GAAG,CAAC;UAChF1B;QACF,CAAC,CAAC;MACJ;IACF;IAEA,IAAID,OAAO,CAAC+K,GAAG,KAAKjL,SAAS,EAAE;MAC7B,IAAI,OAAOE,OAAO,CAAC+K,GAAG,KAAK,QAAQ,EAAE;QACnC,MAAM,IAAIlN,OAAO,CAAC;UAChBsC,OAAO,EAAE,4CAA4C;UACrDF;QACF,CAAC,CAAC;MACJ;IACF;IAEA,IAAID,OAAO,CAACsL,GAAG,KAAKxL,SAAS,EAAE;MAC7B,IAAI,OAAOE,OAAO,CAACsL,GAAG,KAAK,QAAQ,EAAE;QACnC,MAAM,IAAIzN,OAAO,CAAC;UAChBsC,OAAO,EAAE,4CAA4C;UACrDF;QACF,CAAC,CAAC;MACJ;MACA,IAAID,OAAO,CAACsL,GAAG,GAAGlB,SAAS,GAAG,IAAI,CAAChM,eAAe,CAAC,EAAE;QACnD,MAAM,IAAIP,OAAO,CAAC;UAChB0E,MAAM,EAAE,CAAC,oCAAoC,EAAE6H,SAAS,GAAG,IAAI,CAAChM,eAAe,CAAC,EAAE4B,OAAO,CAACsL,GAAG,CAAC;UAC9FxN,GAAG,EAAEsM,SAAS;UACdI,SAAS,EAAE,IAAI,CAACpM,eAAe,CAAC;UAChCkN,GAAG,EAAEtL,OAAO,CAACsL,GAAG;UAChBrL;QACF,CAAC,CAAC;MACJ;IACF;IAEA,IAAID,OAAO,CAACuL,GAAG,KAAKzL,SAAS,EAAE;MAC7B,IAAI,OAAOE,OAAO,CAACuL,GAAG,KAAK,QAAQ,EAAE;QACnC,MAAM,IAAI1N,OAAO,CAAC;UAChBsC,OAAO,EAAE,4CAA4C;UACrDF;QACF,CAAC,CAAC;MACJ;MACA,IAAImK,SAAS,GAAG,IAAI,CAAChM,eAAe,CAAC,IAAI4B,OAAO,CAACuL,GAAG,EAAE;QACpD,MAAM,IAAI1N,OAAO,CAAC;UAChB0E,MAAM,EAAE,CAAC,6BAA6B,EAAE6H,SAAS,GAAG,IAAI,CAAChM,eAAe,CAAC,EAAE4B,OAAO,CAACuL,GAAG,CAAC;UACvFzN,GAAG,EAAEsM,SAAS;UACdI,SAAS,EAAE,IAAI,CAACpM,eAAe,CAAC;UAChCmN,GAAG,EAAEvL,OAAO,CAACuL,GAAG;UAChBtL;QACF,CAAC,CAAC;MACJ;IACF;IAEA,IAAID,OAAO,CAACwL,GAAG,KAAK1L,SAAS,EAAE;MAC7B,IAAIoB,KAAK,CAACC,OAAO,CAACnB,OAAO,CAACwL,GAAG,CAAC,EAAE;QAC9B,IAAIxL,OAAO,CAACwL,GAAG,CAACnM,MAAM,GAAG,CAAC,IAAI,CAACW,OAAO,CAACyL,GAAG,EAAE;UAC1C,MAAM,IAAI5N,OAAO,CAAC;YAChBsC,OAAO,EAAE,mCAAmC;YAC5CF;UACF,CAAC,CAAC;QACJ;QAEA,IAAI,CAACD,OAAO,CAACwL,GAAG,CAAC9H,QAAQ,CAAC,IAAI,CAACnD,SAAS,CAAC,EAAE;UACzC,MAAM,IAAI1C,OAAO,CAAC;YAChB0E,MAAM,EAAE,CAAC,gEAAgE,EAAE,IAAI,CAAChC,SAAS,EAAEP,OAAO,CAACwL,GAAG,CAAC;YACvGvL;UACF,CAAC,CAAC;QACJ;MACF,CAAC,MAAM,IAAID,OAAO,CAACwL,GAAG,KAAK,IAAI,CAACjL,SAAS,EAAE;QACzC,MAAM,IAAI1C,OAAO,CAAC;UAChB0E,MAAM,EAAE,CAAC,oCAAoC,EAAE,IAAI,CAAChC,SAAS,EAAEP,OAAO,CAACwL,GAAG,CAAC;UAC3EvL;QACF,CAAC,CAAC;MACJ;IACF;IAEA,IAAID,OAAO,CAACyL,GAAG,KAAK3L,SAAS,EAAE;MAC7B,IAAI;QAAE4L;MAA4B,CAAC,GAAGpN,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;MAEzE,IAAI,OAAO0J,2BAA2B,KAAK,QAAQ,EAAE;QACnDA,2BAA2B,GAAG,CAAC,IAAI,CAACnL,SAAS,EAAEmL,2BAA2B,CAAC;MAC7E,CAAC,MAAM,IAAIxK,KAAK,CAACC,OAAO,CAACuK,2BAA2B,CAAC,EAAE;QACrDA,2BAA2B,GAAG,CAAC,IAAI,CAACnL,SAAS,EAAE,GAAGmL,2BAA2B,CAAC;MAChF,CAAC,MAAM;QACLA,2BAA2B,GAAG,CAAC,IAAI,CAACnL,SAAS,CAAC;MAChD;MAEA,IAAI,CAACmL,2BAA2B,CAAChI,QAAQ,CAAC1D,OAAO,CAACyL,GAAG,CAAC,EAAE;QACtD,MAAM,IAAI5N,OAAO,CAAC;UAChB0E,MAAM,EAAE,CAAC,uBAAuB,EAAEvC,OAAO,CAACyL,GAAG,CAAC;UAC9CxL;QACF,CAAC,CAAC;MACJ;IACF;IAEA,IAAIa,GAAG;IAEP,IAAImK,YAAY,EAAE;MAChB,IAAI;QACFnO,MAAM,CAACW,aAAa,CAACuC,OAAO,CAAC2L,OAAO,CAAC,CAAC;QACtC7K,GAAG,GAAG5D,IAAI,CAAC0O,GAAG,CAACC,KAAK,CAAC7L,OAAO,CAAC2L,OAAO,CAAC;QACrC7O,MAAM,CAACgP,KAAK,CAAChL,GAAG,CAACqC,IAAI,EAAE,QAAQ,CAAC;MAClC,CAAC,CAAC,OAAOd,GAAG,EAAE;QACZ,MAAM,IAAIxE,OAAO,CAAC;UAChBsC,OAAO,EAAE,2DAA2D;UACpEF;QACF,CAAC,CAAC;MACJ;MACA,IAAIa,GAAG,CAACiL,UAAU,KAAK/L,OAAO,CAACgM,GAAG,EAAE;QAClC,MAAM,IAAInO,OAAO,CAAC;UAChBsC,OAAO,EAAE,0CAA0C;UACnDF;QACF,CAAC,CAAC;MACJ;IACF,CAAC,MAAM,IAAIsB,MAAM,CAACK,GAAG,CAACqK,UAAU,CAAC,IAAI,CAAC,EAAE;MACtCnL,GAAG,GAAG,MAAM,IAAI,CAAC8I,UAAU,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAIrI,MAAM,CAACK,GAAG,KAAK,MAAM,EAAE;MAChCd,GAAG,GAAG,MAAM,IAAI,CAACe,MAAM,CAACC,aAAa,CAACP,MAAM,CAAC;IAC/C;IAEA,IAAI,CAACT,GAAG,IAAIS,MAAM,CAACK,GAAG,KAAK,MAAM,EAAE;MACjC,OAAO;QAAEyI,SAAS,EAAE9I,MAAM;QAAEvB;MAAQ,CAAC;IACvC;IAEA,IAAI;MACF,OAAO;QACL,GAAG9C,IAAI,CAACgP,GAAG,CAAC9J,MAAM,CAACnC,GAAG,EAAEa,GAAG,EAAE;UAAEY,QAAQ,EAAE;QAAK,CAAC,CAAC;QAChD1B;MACF,CAAC;IACH,CAAC,CAAC,OAAOqC,GAAG,EAAE;MACZ,MAAM,IAAIxE,OAAO,CAAC;QAChBsC,OAAO,EAAE,kCAAkC;QAC3CF;MACF,CAAC,CAAC;IACJ;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMkM,OAAOA,CAACC,YAAY,EAAE;IAAErF,YAAY;IAAEC,sBAAsB;IAAEC;EAAK,CAAC,GAAG,CAAC,CAAC,EAAE;IAC/E,IAAInI,KAAK,GAAGsN,YAAY;IAExB,IAAItN,KAAK,YAAYnB,QAAQ,EAAE;MAC7B,IAAI,CAACmB,KAAK,CAACuN,aAAa,EAAE;QACxB,MAAM,IAAIzJ,SAAS,CAAC,uCAAuC,CAAC;MAC9D;MACA9D,KAAK,GAAGA,KAAK,CAACuN,aAAa;IAC7B;IAEA,MAAMrE,QAAQ,GAAG,MAAM,IAAI,CAACI,KAAK,CAAC;MAChC,GAAGrB,YAAY;MACfsB,UAAU,EAAE,eAAe;MAC3BgE,aAAa,EAAEjL,MAAM,CAACtC,KAAK;IAC7B,CAAC,EAAE;MAAEkI,sBAAsB;MAAEC;IAAK,CAAC,CAAC;IAEpC,IAAIe,QAAQ,CAAChC,QAAQ,EAAE;MACrB,MAAM,IAAI,CAACiC,cAAc,CAACD,QAAQ,CAAC;MACnC,MAAM,IAAI,CAACE,eAAe,CAACF,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC;MAEzD,IAAIoE,YAAY,YAAYzO,QAAQ,IAAIyO,YAAY,CAACpG,QAAQ,EAAE;QAC7D,MAAMsG,WAAW,GAAGF,YAAY,CAACnN,MAAM,CAAC,CAAC,CAAC+M,GAAG;QAC7C,MAAMO,SAAS,GAAGvE,QAAQ,CAAC/I,MAAM,CAAC,CAAC,CAAC+M,GAAG;QACvC,IAAIO,SAAS,KAAKD,WAAW,EAAE;UAC7B,MAAM,IAAIzO,OAAO,CAAC;YAChB0E,MAAM,EAAE,CAAC,oCAAoC,EAAE+J,WAAW,EAAEC,SAAS,CAAC;YACtEtM,GAAG,EAAE+H,QAAQ,CAAChC;UAChB,CAAC,CAAC;QACJ;MACF;IACF;IAEA,OAAOgC,QAAQ;EACjB;EAEA,MAAMwE,eAAeA,CACnBC,WAAW,EACXC,WAAW,EACX;IACErG,MAAM;IACNsG,OAAO;IACPpG,IAAI;IACJU,IAAI;IACJ;IACAlI,SAAS,GAAGkI,IAAI,GAAG,MAAM,GAAGyF,WAAW,YAAY/O,QAAQ,GAAG+O,WAAW,CAACE,UAAU,GAAG;EACzF,CAAC,GAAG,CAAC,CAAC,EACN;IACA,IAAIF,WAAW,YAAY/O,QAAQ,EAAE;MACnC,IAAI,CAAC+O,WAAW,CAAC5E,YAAY,EAAE;QAC7B,MAAM,IAAIlF,SAAS,CAAC,sCAAsC,CAAC;MAC7D;MACA8J,WAAW,GAAGA,WAAW,CAAC5E,YAAY,CAAC,CAAC;IAC1C;IAEA,MAAM+E,WAAW,GAAG;MAClBF,OAAO,EAAE;QACPG,aAAa,EAAEjO,wBAAwB,CAAC6N,WAAW,EAAE3N,SAAS,CAAC;QAC/D,GAAG4N;MACL,CAAC;MACDpG;IACF,CAAC;IAED,MAAMwG,IAAI,GAAG,CAAC,CAAC,IAAI,CAACC,0CAA0C;IAE9D,OAAOhP,OAAO,CAAC0C,IAAI,CAAC,IAAI,EAAE;MACxB,GAAGmM,WAAW;MACdI,YAAY,EAAE,QAAQ;MACtB5G,MAAM;MACNrJ,GAAG,EAAEyP;IACP,CAAC,EAAE;MAAEC,WAAW;MAAEK,IAAI;MAAE9F;IAAK,CAAC,CAAC;EACjC;;EAEA;AACF;AACA;AACA;EACE,MAAMiG,QAAQA,CAACR,WAAW,EAAE;IAC1BrG,MAAM,GAAG,KAAK;IAAE8G,GAAG,GAAG,QAAQ;IAAEpO,SAAS;IAAEsB,MAAM;IAAE4G;EACrD,CAAC,GAAG,CAAC,CAAC,EAAE;IACN1J,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,mBAAmB,CAAC;IAC3D,MAAM8C,OAAO,GAAG;MACd5F,SAAS;MACTsH,MAAM,EAAEjF,MAAM,CAACiF,MAAM,CAAC,CAAC+G,WAAW,CAAC,CAAC;MACpCnG;IACF,CAAC;IAED,IAAItC,OAAO,CAAC0B,MAAM,KAAK,KAAK,IAAI1B,OAAO,CAAC0B,MAAM,KAAK,MAAM,EAAE;MACzD,MAAM,IAAIzD,SAAS,CAAC,8CAA8C,CAAC;IACrE;IAEA,IAAIuK,GAAG,KAAK,OAAO,IAAIxI,OAAO,CAAC0B,MAAM,KAAK,KAAK,EAAE;MAC/C,MAAM,IAAIzD,SAAS,CAAC,mEAAmE,CAAC;IAC1F,CAAC,MAAM,IAAIuK,GAAG,KAAK,MAAM,IAAIxI,OAAO,CAAC0B,MAAM,KAAK,MAAM,EAAE;MACtD,MAAM,IAAIzD,SAAS,CAAC,4BAA4B,CAAC;IACnD;IAEA,MAAM3C,GAAG,GAAG,CAAC,EAAE,IAAI,CAACgJ,4BAA4B,IAAI,IAAI,CAACK,+BAA+B,CAAC;IAEzF,IAAIrJ,GAAG,EAAE;MACP0E,OAAO,CAACgI,OAAO,GAAG;QAAEU,MAAM,EAAE;MAAkB,CAAC;IACjD,CAAC,MAAM;MACL1I,OAAO,CAACgI,OAAO,GAAG;QAAEU,MAAM,EAAE;MAAmB,CAAC;IAClD;IAEA,MAAMN,IAAI,GAAG,CAAC,CAAC,IAAI,CAACC,0CAA0C;IAE9D,IAAIM,SAAS;IACb,IAAIP,IAAI,IAAI,IAAI,CAAClL,MAAM,CAAC0L,qBAAqB,EAAE;MAC7CD,SAAS,GAAG,IAAI,CAACzL,MAAM,CAAC0L,qBAAqB,CAACC,iBAAiB;IACjE;IAEAF,SAAS,GAAG,IAAItQ,GAAG,CAACyQ,GAAG,CAACH,SAAS,IAAI,IAAI,CAACzL,MAAM,CAAC2L,iBAAiB,CAAC;;IAEnE;IACA;IACA,IAAIL,GAAG,KAAK,OAAO,EAAE;MACnBxI,OAAO,CAACgI,OAAO,CAACG,aAAa,GAAGhN,SAAS;MACzCwN,SAAS,CAACI,YAAY,CAACC,MAAM,CAAC,cAAc,EAAEjB,WAAW,YAAY/O,QAAQ,GAAG+O,WAAW,CAAC5E,YAAY,GAAG4E,WAAW,CAAC;IACzH,CAAC,MAAM,IAAIS,GAAG,KAAK,MAAM,EAAE;MACzBxI,OAAO,CAACgI,OAAO,CAACG,aAAa,GAAGhN,SAAS;MACzC6E,OAAO,CAACgI,OAAO,CAAC,cAAc,CAAC,GAAG,mCAAmC;MACrEhI,OAAO,CAAC4B,IAAI,GAAG,IAAIvJ,GAAG,CAAC4Q,eAAe,CAAC,CAAC;MACxCjJ,OAAO,CAAC4B,IAAI,CAACoH,MAAM,CAAC,cAAc,EAAEjB,WAAW,YAAY/O,QAAQ,GAAG+O,WAAW,CAAC5E,YAAY,GAAG4E,WAAW,CAAC;IAC/G;;IAEA;IACA,IAAIrM,MAAM,EAAE;MACV,IAAIsE,OAAO,CAAC0B,MAAM,KAAK,KAAK,EAAE;QAC5BnH,MAAM,CAAC0B,OAAO,CAACP,MAAM,CAAC,CAACQ,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;UAC/CuM,SAAS,CAACI,YAAY,CAACC,MAAM,CAAC7M,GAAG,EAAEC,KAAK,CAAC;QAC3C,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI4D,OAAO,CAAC4B,IAAI,EAAE;QAAE;QACzBrH,MAAM,CAAC0B,OAAO,CAACP,MAAM,CAAC,CAACQ,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;UAC/C4D,OAAO,CAAC4B,IAAI,CAACoH,MAAM,CAAC7M,GAAG,EAAEC,KAAK,CAAC;QACjC,CAAC,CAAC;MACJ,CAAC,MAAM;QAAE;QACP4D,OAAO,CAAC4B,IAAI,GAAG,IAAIvJ,GAAG,CAAC4Q,eAAe,CAAC,CAAC;QACxCjJ,OAAO,CAACgI,OAAO,CAAC,cAAc,CAAC,GAAG,mCAAmC;QACrEzN,MAAM,CAAC0B,OAAO,CAACP,MAAM,CAAC,CAACQ,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;UAC/C4D,OAAO,CAAC4B,IAAI,CAACoH,MAAM,CAAC7M,GAAG,EAAEC,KAAK,CAAC;QACjC,CAAC,CAAC;MACJ;IACF;IAEA,IAAI4D,OAAO,CAAC4B,IAAI,EAAE;MAChB5B,OAAO,CAAC4B,IAAI,GAAG5B,OAAO,CAAC4B,IAAI,CAACG,QAAQ,CAAC,CAAC;IACxC;IAEA,MAAMW,QAAQ,GAAG,MAAM,IAAI,CAACmF,eAAe,CAACc,SAAS,EAAEZ,WAAW,EAAE/H,OAAO,CAAC;IAE5E,IAAIkJ,MAAM,GAAGnQ,eAAe,CAAC2J,QAAQ,EAAE;MAAEyG,MAAM,EAAE;IAAK,CAAC,CAAC;IAExD,IAAI7N,GAAG,EAAE;MACP,IAAI,CAAC9B,WAAW,CAAC4P,IAAI,CAAC1G,QAAQ,CAACsF,OAAO,CAAC,cAAc,CAAC,CAAC,EAAE;QACvD,MAAM,IAAI9O,OAAO,CAAC;UAChBsC,OAAO,EAAE,8DAA8D;UACvEkH;QACF,CAAC,CAAC;MACJ;MAEA,MAAMd,IAAI,GAAGc,QAAQ,CAACd,IAAI,CAACG,QAAQ,CAAC,CAAC;MACrC,MAAMwG,QAAQ,GAAG,MAAM,IAAI,CAAC7D,kBAAkB,CAAC9C,IAAI,CAAC;MACpD,IAAI,CAAC,IAAI,CAAC0C,4BAA4B,EAAE;QACtC,IAAI;UACF4E,MAAM,GAAG7M,IAAI,CAACgE,KAAK,CAACkI,QAAQ,CAAC;UAC7BpQ,MAAM,CAACW,aAAa,CAACoQ,MAAM,CAAC,CAAC;QAC/B,CAAC,CAAC,OAAOxL,GAAG,EAAE;UACZ,MAAM,IAAIxE,OAAO,CAAC;YAChBsC,OAAO,EAAE,8CAA8C;YACvDF,GAAG,EAAEiN;UACP,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL,CAAC;UAAElN,OAAO,EAAE6N;QAAO,CAAC,GAAG,MAAM,IAAI,CAAC7E,mBAAmB,CAACkE,QAAQ,CAAC;MACjE;IACF,CAAC,MAAM;MACL,IAAI;QACFW,MAAM,GAAG7M,IAAI,CAACgE,KAAK,CAACqC,QAAQ,CAACd,IAAI,CAAC;MACpC,CAAC,CAAC,OAAOmB,KAAK,EAAE;QACd,MAAM,IAAIzK,UAAU,CAACyK,KAAK,EAAEL,QAAQ,CAAC;MACvC;IACF;IAEA,IAAIqF,WAAW,YAAY/O,QAAQ,IAAI+O,WAAW,CAAC1G,QAAQ,EAAE;MAC3D,MAAMsG,WAAW,GAAGI,WAAW,CAACzN,MAAM,CAAC,CAAC,CAAC+M,GAAG;MAC5C,IAAI6B,MAAM,CAAC7B,GAAG,KAAKM,WAAW,EAAE;QAC9B,MAAM,IAAIzO,OAAO,CAAC;UAChB0E,MAAM,EAAE,CAAC,6CAA6C,EAAE+J,WAAW,EAAEuB,MAAM,CAAC7B,GAAG,CAAC;UAChFzF,IAAI,EAAEsH,MAAM;UACZ5N,GAAG,EAAEyM,WAAW,CAAC1G;QACnB,CAAC,CAAC;MACJ;IACF;IAEA,OAAO6H,MAAM;EACf;;EAEA;AACF;AACA;AACA;EACE,MAAMG,UAAUA,CAACC,GAAG,EAAE;IACpB,MAAMC,QAAQ,GAAI,GAAED,GAAI,MAAK;IAC7B,IAAI3P,QAAQ,CAAC,IAAI,CAAC,CAACyD,GAAG,CAACmM,QAAQ,CAAC,EAAE;MAChC,OAAO5P,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAACkM,QAAQ,CAAC;IACrC;IAEA,MAAMC,IAAI,GAAGF,GAAG,IAAI,GAAG,GAAG,QAAQ,GAAGA,GAAG,IAAI,GAAG,GAAG,QAAQ,GAAGA,GAAG,IAAI,GAAG,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC;IAC5F,IAAI,CAACE,IAAI,EAAE;MACT,MAAM,IAAIC,KAAK,CAAC,iDAAiD,CAAC;IACpE;IAEA,MAAMC,aAAa,GAAGzR,MAAM,CAAC0R,UAAU,CAACH,IAAI,CAAC,CAC1CI,MAAM,CAAC,IAAI,CAACC,aAAa,CAAC,CAC1BC,MAAM,CAAC,CAAC,CACRC,KAAK,CAAC,CAAC,EAAET,GAAG,GAAG,CAAC,CAAC;IAEpB,MAAMnN,GAAG,GAAG5D,IAAI,CAAC0O,GAAG,CAACC,KAAK,CAAC;MAAElJ,CAAC,EAAEvF,SAAS,CAACuR,MAAM,CAACN,aAAa,CAAC;MAAEO,GAAG,EAAE;IAAM,CAAC,CAAC;IAC9EtQ,QAAQ,CAAC,IAAI,CAAC,CAACsG,GAAG,CAACsJ,QAAQ,EAAEpN,GAAG,CAAC;IAEjC,OAAOA,GAAG;EACZ;;EAEA;AACF;AACA;AACA;EACE,MAAM8I,UAAUA,CAAChI,GAAG,EAAE;IACpB,IAAI,CAAC,IAAI,CAAC4M,aAAa,EAAE;MACvB,MAAM,IAAI5L,SAAS,CAAC,2BAA2B,CAAC;IAClD;IACA,IAAI,sBAAsB,CAACmL,IAAI,CAACnM,GAAG,CAAC,EAAE;MACpC,OAAO,IAAI,CAACoM,UAAU,CAACa,QAAQ,CAACC,MAAM,CAACC,EAAE,EAAE,EAAE,CAAC,CAAC;IACjD;IAEA,IAAI,iCAAiC,CAAChB,IAAI,CAACnM,GAAG,CAAC,EAAE;MAC/C,OAAO,IAAI,CAACoM,UAAU,CAACa,QAAQ,CAACC,MAAM,CAACE,EAAE,IAAIF,MAAM,CAACC,EAAE,EAAE,EAAE,CAAC,CAAC;IAC9D;IAEA,IAAIzQ,QAAQ,CAAC,IAAI,CAAC,CAACyD,GAAG,CAAC,aAAa,CAAC,EAAE;MACrC,OAAOzD,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAAC,aAAa,CAAC;IAC1C;IAEA,MAAMlB,GAAG,GAAG5D,IAAI,CAAC0O,GAAG,CAACC,KAAK,CAAC;MAAElJ,CAAC,EAAEvF,SAAS,CAACuR,MAAM,CAAC,IAAI,CAACH,aAAa,CAAC;MAAEI,GAAG,EAAE;IAAM,CAAC,CAAC;IACnFtQ,QAAQ,CAAC,IAAI,CAAC,CAACsG,GAAG,CAAC,aAAa,EAAE9D,GAAG,CAAC;IAEtC,OAAOA,GAAG;EACZ;;EAEA;AACF;AACA;AACA;EACE,MAAMsH,KAAKA,CAAC7B,IAAI,EAAE;IAAES,sBAAsB;IAAEC;EAAK,CAAC,GAAG,CAAC,CAAC,EAAE;IACvD1J,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,gBAAgB,CAAC;IACxD,MAAMwF,QAAQ,GAAG,MAAM9I,iBAAiB,CAACmC,IAAI,CAC3C,IAAI,EACJ,OAAO,EACP;MACEuO,IAAI,EAAE1I,IAAI;MACV0G,YAAY,EAAE;IAChB,CAAC,EACD;MAAEjG,sBAAsB;MAAEC;IAAK,CACjC,CAAC;IACD,MAAMiI,YAAY,GAAGxR,eAAe,CAAC2J,QAAQ,CAAC;IAE9C,OAAO,IAAI1J,QAAQ,CAACuR,YAAY,CAAC;EACnC;;EAEA;AACF;AACA;AACA;EACE,MAAMC,mBAAmBA,CAAC9O,MAAM,GAAG,CAAC,CAAC,EAAE;IAAE0G,YAAY;IAAEC,sBAAsB;IAAEC;EAAK,CAAC,GAAG,CAAC,CAAC,EAAE;IAC1F1J,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,+BAA+B,CAAC;IACvEtE,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,gBAAgB,CAAC;IAExD,MAAM0E,IAAI,GAAGnG,mBAAmB,CAACM,IAAI,CAAC,IAAI,EAAE;MAC1CH,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBI,YAAY,EAAE,IAAI;MAClBF,aAAa,EAAE,IAAI;MACnB,GAAGJ;IACL,CAAC,CAAC;IAEF,MAAMgH,QAAQ,GAAG,MAAM9I,iBAAiB,CAACmC,IAAI,CAC3C,IAAI,EACJ,sBAAsB,EACtB;MACEuM,YAAY,EAAE,MAAM;MACpBgC,IAAI,EAAE1I;IACR,CAAC,EACD;MAAES,sBAAsB;MAAEoI,kBAAkB,EAAE;IAAQ,CACxD,CAAC;IACD,MAAMF,YAAY,GAAGxR,eAAe,CAAC2J,QAAQ,CAAC;IAE9C,OAAO,IAAI3I,gBAAgB,CAAC;MAC1B2E,MAAM,EAAE,IAAI;MACZ0D,YAAY;MACZC,sBAAsB;MACtBK,QAAQ,EAAE6H,YAAY;MACtBjF,MAAM,EAAE5J,MAAM,CAACmH,OAAO;MACtBP;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;EACE,MAAMoI,MAAMA,CAACvQ,KAAK,EAAEgH,IAAI,EAAE;IAAEwJ,UAAU;IAAEtI;EAAuB,CAAC,GAAG,CAAC,CAAC,EAAE;IACrEzJ,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,qBAAqB,CAAC;IAC7D,IAAIiE,IAAI,KAAKhG,SAAS,IAAI,OAAOgG,IAAI,KAAK,QAAQ,EAAE;MAClD,MAAM,IAAIlD,SAAS,CAAC,uBAAuB,CAAC;IAC9C;IAEA,MAAMqM,IAAI,GAAG;MAAE,GAAGK,UAAU;MAAExQ;IAAM,CAAC;IAErC,IAAIgH,IAAI,EAAE;MACRmJ,IAAI,CAACM,eAAe,GAAGzJ,IAAI;IAC7B;IAEA,MAAMuB,QAAQ,GAAG,MAAM9I,iBAAiB,CAACmC,IAAI,CAC3C,IAAI,EACJ,YAAY,EAAE;MACZuO;IACF,CAAC,EAAE;MAAEjI;IAAuB,CAC9B,CAAC;IACDtJ,eAAe,CAAC2J,QAAQ,EAAE;MAAEd,IAAI,EAAE;IAAM,CAAC,CAAC;EAC5C;;EAEA;AACF;AACA;AACA;EACE,MAAMiJ,UAAUA,CAAC1Q,KAAK,EAAEgH,IAAI,EAAE;IAAE2J,cAAc;IAAEzI;EAAuB,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7EzJ,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,wBAAwB,CAAC;IAChE,IAAIiE,IAAI,KAAKhG,SAAS,IAAI,OAAOgG,IAAI,KAAK,QAAQ,EAAE;MAClD,MAAM,IAAIlD,SAAS,CAAC,uBAAuB,CAAC;IAC9C;IAEA,MAAMqM,IAAI,GAAG;MAAE,GAAGQ,cAAc;MAAE3Q;IAAM,CAAC;IACzC,IAAIgH,IAAI,EAAE;MACRmJ,IAAI,CAACM,eAAe,GAAGzJ,IAAI;IAC7B;IAEA,MAAMuB,QAAQ,GAAG,MAAM9I,iBAAiB,CAACmC,IAAI,CAC3C,IAAI,EACJ,eAAe,EACf;MAAEuO,IAAI;MAAEhC,YAAY,EAAE;IAAO,CAAC,EAC9B;MAAEjG;IAAuB,CAC3B,CAAC;IAED,MAAMkI,YAAY,GAAGxR,eAAe,CAAC2J,QAAQ,CAAC;IAE9C,OAAO6H,YAAY;EACrB;;EAEA;AACF;AACA;AACA;EACE,MAAMQ,sBAAsBA,CAACzQ,MAAM,EAAE0Q,MAAM,GAAG,CAAC,CAAC,EAAE;IAChD,IAAI,CAAClS,aAAa,CAACwB,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAI2D,SAAS,CAAC,wCAAwC,CAAC;IAC/D;IAEA,IAAI,CAACnF,aAAa,CAACwB,MAAM,CAACK,cAAc,CAAC,EAAE;MACzC,OAAOL,MAAM;IACf;IAEA,IAAI,CAACxB,aAAa,CAACwB,MAAM,CAACG,YAAY,CAAC,EAAE;MACvC,OAAOH,MAAM;IACf;IAEA,MAAM2Q,kBAAkB,GAAG1Q,MAAM,CAAC0B,OAAO,CAAC3B,MAAM,CAACK,cAAc,CAAC,CAC7DuQ,MAAM,CAAC,CAAC,GAAG9O,KAAK,CAAC,KAAKA,KAAK,IAAIA,KAAK,CAACiD,QAAQ,CAAC;IAEjD,MAAM8L,OAAO,CAAC5M,GAAG,CAAC0M,kBAAkB,CAACpK,GAAG,CAAC,OAAO,CAAC9F,UAAU,EAAEqQ,GAAG,CAAC,KAAK;MACpE,IAAI;QACF,MAAMlD,WAAW,GAAG;UAClBF,OAAO,EAAE;YACPU,MAAM,EAAE,iBAAiB;YACzBP,aAAa,EAAEjO,wBAAwB,CAACkR,GAAG,CAACjI,YAAY,IAAI6H,MAAM,CAACjQ,UAAU,CAAC;UAChF;QACF,CAAC;QAED,MAAM2H,QAAQ,GAAG,MAAMrJ,OAAO,CAAC0C,IAAI,CAAC,IAAI,EAAE;UACxC,GAAGmM,WAAW;UACdxG,MAAM,EAAE,KAAK;UACbrJ,GAAG,EAAE+S,GAAG,CAAC/L;QACX,CAAC,CAAC;QACF,MAAMuC,IAAI,GAAG7I,eAAe,CAAC2J,QAAQ,EAAE;UAAEyG,MAAM,EAAE;QAAK,CAAC,CAAC;QAExD,MAAMkC,OAAO,GAAG,MAAM3O,QAAQ,CAACX,IAAI,CAAC,IAAI,EAAE,aAAa,EAAE6F,IAAI,CAAC;QAC9D,OAAOtH,MAAM,CAACK,cAAc,CAACI,UAAU,CAAC;QACxCR,MAAM,CAAC0B,OAAO,CAAC3B,MAAM,CAACG,YAAY,CAAC,CAACyB,OAAO,CACzCtB,WAAW,CAACN,MAAM,EAAE+Q,OAAO,EAAEtQ,UAAU,EAAE,KAAK,CAChD,CAAC;MACH,CAAC,CAAC,OAAO2C,GAAG,EAAE;QACZA,GAAG,CAAC4N,GAAG,GAAGvQ,UAAU;QACpB,MAAM2C,GAAG;MACX;IACF,CAAC,CAAC,CAAC;IAEHrD,aAAa,CAACC,MAAM,CAAC;IACrB,OAAOA,MAAM;EACf;;EAEA;AACF;AACA;AACA;EACE,MAAMiR,sBAAsBA,CAACjR,MAAM,EAAE;IACnC,IAAI,CAACxB,aAAa,CAACwB,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAI2D,SAAS,CAAC,wCAAwC,CAAC;IAC/D;IAEA,IAAI,CAACnF,aAAa,CAACwB,MAAM,CAACK,cAAc,CAAC,EAAE;MACzC,OAAOL,MAAM;IACf;IAEA,IAAI,CAACxB,aAAa,CAACwB,MAAM,CAACG,YAAY,CAAC,EAAE;MACvC,OAAOH,MAAM;IACf;IAEA,MAAMkR,iBAAiB,GAAGjR,MAAM,CAAC0B,OAAO,CAAC3B,MAAM,CAACK,cAAc,CAAC,CAC5DuQ,MAAM,CAAC,CAAC,GAAG9O,KAAK,CAAC,KAAKA,KAAK,IAAIA,KAAK,CAACS,GAAG,CAAC;IAE5C,MAAMsO,OAAO,CAAC5M,GAAG,CAACiN,iBAAiB,CAAC3K,GAAG,CAAC,OAAO,CAAC9F,UAAU,EAAEqQ,GAAG,CAAC,KAAK;MACnE,IAAI;QACF,MAAMC,OAAO,GAAG,MAAM3O,QAAQ,CAACX,IAAI,CAAC,IAAI,EAAE,YAAY,EAAEqP,GAAG,CAACvO,GAAG,CAAC;QAChE,OAAOvC,MAAM,CAACK,cAAc,CAACI,UAAU,CAAC;QACxCR,MAAM,CAAC0B,OAAO,CAAC3B,MAAM,CAACG,YAAY,CAAC,CAACyB,OAAO,CAACtB,WAAW,CAACN,MAAM,EAAE+Q,OAAO,EAAEtQ,UAAU,CAAC,CAAC;MACvF,CAAC,CAAC,OAAO2C,GAAG,EAAE;QACZA,GAAG,CAAC4N,GAAG,GAAGvQ,UAAU;QACpB,MAAM2C,GAAG;MACX;IACF,CAAC,CAAC,CAAC;IAEHrD,aAAa,CAACC,MAAM,CAAC;IACrB,OAAOA,MAAM;EACf;;EAEA;AACF;AACA;AACA;EACE,aAAamR,QAAQA,CAAC9M,QAAQ,EAAEqB,OAAO,GAAG,CAAC,CAAC,EAAE;IAC5C,MAAM;MAAE0L,kBAAkB;MAAE5N,IAAI;MAAE,GAAG6N;IAAc,CAAC,GAAG3L,OAAO;IAE9DpH,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,uBAAuB,CAAC;IAE/D,IAAIY,IAAI,KAAK3C,SAAS,IAAI,EAAEwD,QAAQ,CAACb,IAAI,IAAIa,QAAQ,CAACiN,QAAQ,CAAC,EAAE;MAC/D,MAAMxN,QAAQ,GAAGP,WAAW,CAAC9B,IAAI,CAAC,IAAI,EAAE+B,IAAI,CAAC;MAC7Ca,QAAQ,CAACb,IAAI,GAAGM,QAAQ,CAACyN,MAAM,CAAC,KAAK,CAAC;MACtC;MACA,KAAK,MAAM3N,GAAG,IAAIS,QAAQ,CAACb,IAAI,CAACtD,IAAI,EAAE;QACpC,IAAI0D,GAAG,CAACC,GAAG,CAACmJ,UAAU,CAAC,WAAW,CAAC,EAAE;UACnC,OAAOpJ,GAAG,CAACC,GAAG;QAChB;MACF;IACF;IAEA,MAAMuE,QAAQ,GAAG,MAAMrJ,OAAO,CAAC0C,IAAI,CAAC,IAAI,EAAE;MACxCiM,OAAO,EAAE0D,kBAAkB,GAAG;QAC5BvD,aAAa,EAAEjO,wBAAwB,CAACwR,kBAAkB;MAC5D,CAAC,GAAGvQ,SAAS;MACbmN,YAAY,EAAE,MAAM;MACpBwD,IAAI,EAAEnN,QAAQ;MACdtG,GAAG,EAAE,IAAI,CAAC6E,MAAM,CAAC6O,qBAAqB;MACtCrK,MAAM,EAAE;IACV,CAAC,CAAC;IACF,MAAM6I,YAAY,GAAGxR,eAAe,CAAC2J,QAAQ,EAAE;MAAEsJ,UAAU,EAAE,GAAG;MAAE7C,MAAM,EAAE;IAAK,CAAC,CAAC;IAEjF,OAAO,IAAI,IAAI,CAACoB,YAAY,EAAEzM,IAAI,EAAE6N,aAAa,CAAC;EACpD;;EAEA;AACF;AACA;AACA;EACE,IAAIhN,QAAQA,CAAA,EAAG;IACb,MAAMsN,IAAI,GAAG,CAAC,CAAC;IACftS,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAAC,UAAU,CAAC,CAACnB,OAAO,CAAC,CAACE,KAAK,EAAED,GAAG,KAAK;MACrD8P,IAAI,CAAC9P,GAAG,CAAC,GAAGC,KAAK;IACnB,CAAC,CAAC;IACF,OAAO6P,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACE,aAAaC,OAAOA,CAACC,qBAAqB,EAAEC,uBAAuB,EAAEtO,IAAI,EAAE6N,aAAa,EAAE;IACxF,MAAMjJ,QAAQ,GAAG,MAAMrJ,OAAO,CAAC0C,IAAI,CAAC,IAAI,EAAE;MACxC2F,MAAM,EAAE,KAAK;MACbrJ,GAAG,EAAE8T,qBAAqB;MAC1B7D,YAAY,EAAE,MAAM;MACpBN,OAAO,EAAE;QAAEG,aAAa,EAAEjO,wBAAwB,CAACkS,uBAAuB;MAAE;IAC9E,CAAC,CAAC;IACF,MAAM7B,YAAY,GAAGxR,eAAe,CAAC2J,QAAQ,EAAE;MAAEyG,MAAM,EAAE;IAAK,CAAC,CAAC;IAEhE,OAAO,IAAI,IAAI,CAACoB,YAAY,EAAEzM,IAAI,EAAE6N,aAAa,CAAC;EACpD;;EAEA;AACF;AACA;AACA;EACE,MAAMU,aAAaA,CAACA,aAAa,GAAG,CAAC,CAAC,EAAE;IACtCC,IAAI,EAAEC,gBAAgB,GAAG,IAAI,CAACC,0BAA0B,IAAI,MAAM;IAClEC,OAAO,EAAE;MACPxP,GAAG,EAAEyP,cAAc,GAAG,IAAI,CAACC,6BAA6B;MACxD7H,GAAG,EAAE8H,kBAAkB,GAAG,IAAI,CAACC,6BAA6B,IAAI;IAClE,CAAC,GAAG,CAAC;EACP,CAAC,GAAG,CAAC,CAAC,EAAE;IACN,IAAI,CAAC/T,aAAa,CAACuT,aAAa,CAAC,EAAE;MACjC,MAAM,IAAIpO,SAAS,CAAC,sCAAsC,CAAC;IAC7D;IAEA,IAAI6O,MAAM;IACV,IAAI3Q,GAAG;IAEP,MAAM2J,IAAI,GAAG,IAAI,CAACvI,WAAW,CAACI,IAAI,KAAK,YAAY;IACnD,MAAMoP,IAAI,GAAG5T,GAAG,CAAC,CAAC;IAClB,MAAMyD,MAAM,GAAG;MAAEK,GAAG,EAAEsP,gBAAgB;MAAES,GAAG,EAAE;IAAsB,CAAC;IACpE,MAAM3R,OAAO,GAAGgB,IAAI,CAACC,SAAS,CAAC5D,QAAQ,CAAC,CAAC,CAAC,EAAE2T,aAAa,EAAE;MACzDrP,GAAG,EAAE,IAAI,CAACpB,SAAS;MACnBiL,GAAG,EAAE,IAAI,CAAC3J,MAAM,CAACA,MAAM;MACvBtB,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBqR,GAAG,EAAE7T,MAAM,CAAC,CAAC;MACbgN,GAAG,EAAE2G,IAAI;MACTnG,GAAG,EAAEmG,IAAI,GAAG,GAAG;MACf,IAAIjH,IAAI,GAAG;QAAEa,GAAG,EAAEoG;MAAK,CAAC,GAAG5R,SAAS;IACtC,CAAC,CAAC,CAAC;IAEH,IAAIoR,gBAAgB,KAAK,MAAM,EAAE;MAC/BO,MAAM,GAAG,CACPrU,SAAS,CAACuR,MAAM,CAAC3N,IAAI,CAACC,SAAS,CAACM,MAAM,CAAC,CAAC,EACxCnE,SAAS,CAACuR,MAAM,CAAC3O,OAAO,CAAC,EACzB,EAAE,CACH,CAACyF,IAAI,CAAC,GAAG,CAAC;IACb,CAAC,MAAM;MACL,MAAMoM,SAAS,GAAGX,gBAAgB,CAACjF,UAAU,CAAC,IAAI,CAAC;MACnD,IAAI4F,SAAS,EAAE;QACb/Q,GAAG,GAAG,MAAM,IAAI,CAAC8I,UAAU,CAAC,CAAC;MAC/B,CAAC,MAAM;QACL,MAAM7G,QAAQ,GAAGzE,QAAQ,CAAC,IAAI,CAAC,CAAC0D,GAAG,CAAC,UAAU,CAAC;QAE/C,IAAI,CAACe,QAAQ,EAAE;UACb,MAAM,IAAIH,SAAS,CAAE,yDAAwDsO,gBAAiB,EAAC,CAAC;QAClG;QACApQ,GAAG,GAAGiC,QAAQ,CAACf,GAAG,CAAC;UAAEJ,GAAG,EAAEsP,gBAAgB;UAAEY,GAAG,EAAE;QAAM,CAAC,CAAC;QACzD,IAAI,CAAChR,GAAG,EAAE;UACR,MAAM,IAAI8B,SAAS,CAAE,qCAAoCsO,gBAAiB,EAAC,CAAC;QAC9E;MACF;MAEAO,MAAM,GAAGvU,IAAI,CAACgP,GAAG,CAAC+E,IAAI,CAACjR,OAAO,EAAEc,GAAG,EAAE;QACnC,GAAGS,MAAM;QACTuB,GAAG,EAAE+O,SAAS,IAAI/Q,GAAG,CAACgC,GAAG,CAACmJ,UAAU,CAAC,WAAW,CAAC,GAAGnM,SAAS,GAAGgB,GAAG,CAACgC;MACtE,CAAC,CAAC;IACJ;IAEA,IAAI,CAACuO,cAAc,EAAE;MACnB,OAAOI,MAAM;IACf;IAEA,MAAMM,MAAM,GAAG;MAAEnQ,GAAG,EAAEyP,cAAc;MAAE5H,GAAG,EAAE8H,kBAAkB;MAAES,GAAG,EAAE;IAAsB,CAAC;IAE3F,IAAID,MAAM,CAACnQ,GAAG,CAAC+H,KAAK,CAAC,aAAa,CAAC,EAAE;MACnC,CAAC7I,GAAG,CAAC,GAAG,MAAM,IAAI,CAACe,MAAM,CAACC,aAAa,CAAC;QACtCF,GAAG,EAAEmQ,MAAM,CAACnQ,GAAG;QACf6H,GAAG,EAAEsI,MAAM,CAACtI,GAAG;QACfqI,GAAG,EAAE;MACP,CAAC,EAAE;QAAEG,UAAU,EAAE;MAAK,CAAC,CAAC;IAC1B,CAAC,MAAM;MACLnR,GAAG,GAAG,MAAM,IAAI,CAAC8I,UAAU,CAACmI,MAAM,CAACnQ,GAAG,KAAK,KAAK,GAAGmQ,MAAM,CAACtI,GAAG,GAAGsI,MAAM,CAACnQ,GAAG,CAAC;IAC7E;IAEA,OAAO1E,IAAI,CAAC2M,GAAG,CAACuH,OAAO,CAACK,MAAM,EAAE3Q,GAAG,EAAE;MACnC,GAAGiR,MAAM;MACTjP,GAAG,EAAEhC,GAAG,CAAC8N,GAAG,KAAK,KAAK,GAAG9O,SAAS,GAAGgB,GAAG,CAACgC;IAC3C,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;EACE,MAAMoP,0BAA0BA,CAAC7R,MAAM,GAAG,CAAC,CAAC,EAAE;IAAE2G;EAAuB,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7EzJ,yBAAyB,CAAC,IAAI,CAACsE,MAAM,EAAE,uCAAuC,CAAC;IAE/E,MAAM0E,IAAI,GAAG;MACX,IAAI,SAAS,IAAIlG,MAAM,GAAGA,MAAM,GAAGD,mBAAmB,CAACM,IAAI,CAAC,IAAI,EAAEL,MAAM,CAAC,CAAC;MAC1EE,SAAS,EAAE,IAAI,CAACA;IAClB,CAAC;IAED,MAAM8G,QAAQ,GAAG,MAAM9I,iBAAiB,CAACmC,IAAI,CAC3C,IAAI,EACJ,8BAA8B,EAC9B;MACEuM,YAAY,EAAE,MAAM;MACpBgC,IAAI,EAAE1I;IACR,CAAC,EACD;MAAES,sBAAsB;MAAEoI,kBAAkB,EAAE;IAAQ,CACxD,CAAC;IACD,MAAMF,YAAY,GAAGxR,eAAe,CAAC2J,QAAQ,EAAE;MAAEsJ,UAAU,EAAE;IAAI,CAAC,CAAC;IAEnE,IAAI,EAAE,YAAY,IAAIzB,YAAY,CAAC,EAAE;MACnC,MAAM,IAAIrR,OAAO,CAAC;QAChBsC,OAAO,EAAE,iEAAiE;QAC1EkH;MACF,CAAC,CAAC;IACJ;IACA,IAAI,OAAO6H,YAAY,CAACiD,UAAU,KAAK,QAAQ,EAAE;MAC/C,MAAM,IAAItU,OAAO,CAAC;QAChBsC,OAAO,EAAE,sEAAsE;QAC/EkH;MACF,CAAC,CAAC;IACJ;IACA,IAAI,EAAE,aAAa,IAAI6H,YAAY,CAAC,EAAE;MACpC,MAAM,IAAIrR,OAAO,CAAC;QAChBsC,OAAO,EAAE,kEAAkE;QAC3EkH;MACF,CAAC,CAAC;IACJ;IACA,IAAI,OAAO6H,YAAY,CAACkD,WAAW,KAAK,QAAQ,EAAE;MAChD,MAAM,IAAIvU,OAAO,CAAC;QAChBsC,OAAO,EAAE,uEAAuE;QAChFkH;MACF,CAAC,CAAC;IACJ;IAEA,OAAO6H,YAAY;EACrB;;EAEA;AACF;AACA;AACA;EACE,WAAWrN,MAAMA,CAAA,EAAG;IAClB,OAAOA,MAAM;EACf;;EAEA;AACF;AACA;AACA;EACE,IAAIA,MAAMA,CAAA,EAAG;IAAE;IACb,OAAOA,MAAM;EACf;;EAEA;EACA,CAACpF,OAAO,CAAC4V,MAAM,IAAI;IACjB,OAAQ,GAAE,IAAI,CAACnQ,WAAW,CAACI,IAAK,IAAG7F,OAAO,CAAC,IAAI,CAAC6G,QAAQ,EAAE;MACxDgP,KAAK,EAAEC,QAAQ;MACfC,MAAM,EAAEC,OAAO,CAACC,MAAM,CAACC,KAAK;MAC5BC,OAAO,EAAE,KAAK;MACdC,MAAM,EAAE;IACV,CAAC,CAAE,EAAC;EACN;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,eAAevL,YAAYA,CAACD,QAAQ,EAAE;EACpC,MAAMsB,WAAW,GAAG,IAAI,CAACmK,iCAAiC;EAC1D,MAAM;IAAE9S;EAAQ,CAAC,GAAG,MAAM,IAAI,CAACkJ,WAAW,CAAC7B,QAAQ,EAAEsB,WAAW,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;EACxF,OAAOhK,MAAM,CAACqB,OAAO,CAAC;AACxB;AAEAd,MAAM,CAAC2F,cAAc,CAACP,UAAU,CAACyO,SAAS,EAAE,cAAc,EAAE;EAC1DjO,UAAU,EAAE,IAAI;EAChBkO,YAAY,EAAE,IAAI;EAClBjS,KAAKA,CAAC,GAAGkS,IAAI,EAAE;IACbR,OAAO,CAACS,WAAW,CACjB,sRAAsR,EACtR,cACF,CAAC;IACDhU,MAAM,CAAC2F,cAAc,CAACP,UAAU,CAACyO,SAAS,EAAE,cAAc,EAAE;MAC1DjO,UAAU,EAAE,IAAI;MAChBkO,YAAY,EAAE,IAAI;MAClBjS,KAAK,EAAEuG;IACT,CAAC,CAAC;IACF,OAAO,IAAI,CAACA,YAAY,CAAC,GAAG2L,IAAI,CAAC;EACnC;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,SAASE,SAASA,CAACnT,OAAO,EAAE6C,GAAG,EAAE6J,WAAW,EAAE;EAC5C,IAAI,CAACjP,aAAa,CAACuC,OAAO,CAAC,EAAE;IAC3B,MAAM,IAAI4C,SAAS,CAAC,gCAAgC,CAAC;EACvD;EAEA,IAAI9B,GAAG;EACP,IAAI;IACFA,GAAG,GAAG5D,IAAI,CAAC0O,GAAG,CAACC,KAAK,CAAChJ,GAAG,CAAC;IACzB/F,MAAM,CAACgE,GAAG,CAACqC,IAAI,KAAK,SAAS,CAAC;EAChC,CAAC,CAAC,OAAOd,GAAG,EAAE;IACZ,MAAM,IAAIO,SAAS,CAAC,iFAAiF,CAAC;EACxG;EAEA,IAAI;IAAEhB;EAAI,CAAC,GAAGd,GAAG;EAEjB,IAAI,CAACc,GAAG,IAAI,IAAI,CAACC,MAAM,CAACuR,iCAAiC,EAAE;IACzD,MAAMC,IAAI,GAAGvS,GAAG,CAACwS,UAAU,CAAC,MAAM,CAAC;IACnC1R,GAAG,GAAG,IAAI,CAACC,MAAM,CAACuR,iCAAiC,CAACG,IAAI,CAAEC,CAAC,IAAKH,IAAI,CAACtR,GAAG,CAACyR,CAAC,CAAC,CAAC;EAC9E;EAEA,IAAI,CAAC5R,GAAG,EAAE;IACR,CAACA,GAAG,CAAC,GAAGd,GAAG,CAACwS,UAAU,CAAC,MAAM,CAAC;EAChC;EAEA,OAAOpW,IAAI,CAACgP,GAAG,CAAC+E,IAAI,CAAC;IACnBlG,GAAG,EAAEjN,GAAG,CAAC,CAAC;IACV8T,GAAG,EAAE7T,MAAM,CAAC,CAAC;IACb0V,GAAG,EAAE/G,WAAW,GAAGtP,SAAS,CAACuR,MAAM,CAAC/R,MAAM,CAAC0R,UAAU,CAAC,QAAQ,CAAC,CAACC,MAAM,CAAC7B,WAAW,CAAC,CAAC+B,MAAM,CAAC,CAAC,CAAC,GAAG3O,SAAS;IACzG,GAAGE;EACL,CAAC,EAAE6C,GAAG,EAAE;IACNjB,GAAG;IACH+P,GAAG,EAAE,UAAU;IACf9O,GAAG,EAAErF,IAAI,CAACsD,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;EACjD,CAAC,CAAC;AACJ;AAEA5B,MAAM,CAAC2F,cAAc,CAACP,UAAU,CAACyO,SAAS,EAAE,WAAW,EAAE;EACvDjO,UAAU,EAAE,IAAI;EAChBkO,YAAY,EAAE,IAAI;EAClBjS,KAAKA,CAAC,GAAGkS,IAAI,EAAE;IACbR,OAAO,CAACS,WAAW,CACjB,yUAAyU,EACzU,cACF,CAAC;IACDhU,MAAM,CAAC2F,cAAc,CAACP,UAAU,CAACyO,SAAS,EAAE,WAAW,EAAE;MACvDjO,UAAU,EAAE,IAAI;MAChBkO,YAAY,EAAE,IAAI;MAClBjS,KAAK,EAAEoS;IACT,CAAC,CAAC;IACF,OAAO,IAAI,CAACA,SAAS,CAAC,GAAGF,IAAI,CAAC;EAChC;AACF,CAAC,CAAC;AAEF1O,MAAM,CAACC,OAAO,CAACF,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}