{"ast":null,"code":"const {\n  strict: assert\n} = require('assert');\nconst {\n  createHash\n} = require('crypto');\nconst {\n  format\n} = require('util');\nconst shake256 = require('./shake256');\nlet encode;\nif (Buffer.isEncoding('base64url')) {\n  encode = input => input.toString('base64url');\n} else {\n  const fromBase64 = base64 => base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  encode = input => fromBase64(input.toString('base64'));\n}\n\n/** SPECIFICATION\n * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of\n * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm\n * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is\n * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode\n * them. The _hash value is a case sensitive string.\n */\n\n/**\n * @name getHash\n * @api private\n *\n * returns the sha length based off the JOSE alg heade value, defaults to sha256\n *\n * @param token {String} token value to generate the hash from\n * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)\n * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA\n */\nfunction getHash(alg, crv) {\n  switch (alg) {\n    case 'HS256':\n    case 'RS256':\n    case 'PS256':\n    case 'ES256':\n    case 'ES256K':\n      return createHash('sha256');\n    case 'HS384':\n    case 'RS384':\n    case 'PS384':\n    case 'ES384':\n      return createHash('sha384');\n    case 'HS512':\n    case 'RS512':\n    case 'PS512':\n    case 'ES512':\n      return createHash('sha512');\n    case 'EdDSA':\n      switch (crv) {\n        case 'Ed25519':\n          return createHash('sha512');\n        case 'Ed448':\n          if (!shake256) {\n            throw new TypeError('Ed448 *_hash calculation is not supported in your Node.js runtime version');\n          }\n          return createHash('shake256', {\n            outputLength: 114\n          });\n        default:\n          throw new TypeError('unrecognized or invalid EdDSA curve provided');\n      }\n    default:\n      throw new TypeError('unrecognized or invalid JWS algorithm provided');\n  }\n}\nfunction generate(token, alg, crv) {\n  const digest = getHash(alg, crv).update(token).digest();\n  return encode(digest.slice(0, digest.length / 2));\n}\nfunction validate(names, actual, source, alg, crv) {\n  if (typeof names.claim !== 'string' || !names.claim) {\n    throw new TypeError('names.claim must be a non-empty string');\n  }\n  if (typeof names.source !== 'string' || !names.source) {\n    throw new TypeError('names.source must be a non-empty string');\n  }\n  assert(typeof actual === 'string' && actual, `${names.claim} must be a non-empty string`);\n  assert(typeof source === 'string' && source, `${names.source} must be a non-empty string`);\n  let expected;\n  let msg;\n  try {\n    expected = generate(source, alg, crv);\n  } catch (err) {\n    msg = format('%s could not be validated (%s)', names.claim, err.message);\n  }\n  msg = msg || format('%s mismatch, expected %s, got: %s', names.claim, expected, actual);\n  assert.equal(expected, actual, msg);\n}\nmodule.exports = {\n  validate,\n  generate\n};","map":{"version":3,"names":["strict","assert","require","createHash","format","shake256","encode","Buffer","isEncoding","input","toString","fromBase64","base64","replace","getHash","alg","crv","TypeError","outputLength","generate","token","digest","update","slice","length","validate","names","actual","source","claim","expected","msg","err","message","equal","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/oidc-token-hash/lib/index.js"],"sourcesContent":["const { strict: assert } = require('assert');\nconst { createHash } = require('crypto');\nconst { format } = require('util');\n\nconst shake256 = require('./shake256');\n\nlet encode;\nif (Buffer.isEncoding('base64url')) {\n  encode = (input) => input.toString('base64url');\n} else {\n  const fromBase64 = (base64) => base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  encode = (input) => fromBase64(input.toString('base64'));\n}\n\n/** SPECIFICATION\n * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of\n * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm\n * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is\n * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode\n * them. The _hash value is a case sensitive string.\n */\n\n/**\n * @name getHash\n * @api private\n *\n * returns the sha length based off the JOSE alg heade value, defaults to sha256\n *\n * @param token {String} token value to generate the hash from\n * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)\n * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA\n */\nfunction getHash(alg, crv) {\n  switch (alg) {\n    case 'HS256':\n    case 'RS256':\n    case 'PS256':\n    case 'ES256':\n    case 'ES256K':\n      return createHash('sha256');\n\n    case 'HS384':\n    case 'RS384':\n    case 'PS384':\n    case 'ES384':\n      return createHash('sha384');\n\n    case 'HS512':\n    case 'RS512':\n    case 'PS512':\n    case 'ES512':\n      return createHash('sha512');\n\n    case 'EdDSA':\n      switch (crv) {\n        case 'Ed25519':\n          return createHash('sha512');\n        case 'Ed448':\n          if (!shake256) {\n            throw new TypeError('Ed448 *_hash calculation is not supported in your Node.js runtime version');\n          }\n\n          return createHash('shake256', { outputLength: 114 });\n        default:\n          throw new TypeError('unrecognized or invalid EdDSA curve provided');\n      }\n\n    default:\n      throw new TypeError('unrecognized or invalid JWS algorithm provided');\n  }\n}\n\nfunction generate(token, alg, crv) {\n  const digest = getHash(alg, crv).update(token).digest();\n  return encode(digest.slice(0, digest.length / 2));\n}\n\nfunction validate(names, actual, source, alg, crv) {\n  if (typeof names.claim !== 'string' || !names.claim) {\n    throw new TypeError('names.claim must be a non-empty string');\n  }\n\n  if (typeof names.source !== 'string' || !names.source) {\n    throw new TypeError('names.source must be a non-empty string');\n  }\n\n  assert(typeof actual === 'string' && actual, `${names.claim} must be a non-empty string`);\n  assert(typeof source === 'string' && source, `${names.source} must be a non-empty string`);\n\n  let expected;\n  let msg;\n  try {\n    expected = generate(source, alg, crv);\n  } catch (err) {\n    msg = format('%s could not be validated (%s)', names.claim, err.message);\n  }\n\n  msg = msg || format('%s mismatch, expected %s, got: %s', names.claim, expected, actual);\n\n  assert.equal(expected, actual, msg);\n}\n\nmodule.exports = {\n  validate,\n  generate,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}