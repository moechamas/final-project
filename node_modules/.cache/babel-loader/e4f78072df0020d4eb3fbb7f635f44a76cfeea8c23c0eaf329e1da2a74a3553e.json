{"ast":null,"code":"const MAX_OCTET = 0x80;\nconst CLASS_UNIVERSAL = 0;\nconst PRIMITIVE_BIT = 0x20;\nconst TAG_SEQ = 0x10;\nconst TAG_INT = 0x02;\nconst ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;\nconst ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\nconst getParamSize = keySize => (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);\nconst paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n};\nconst countPadding = (buf, start, stop) => {\n  let padding = 0;\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n  const needsSign = buf[start + padding] >= MAX_OCTET;\n  if (needsSign) {\n    --padding;\n  }\n  return padding;\n};\nmodule.exports.derToJose = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(`Unknown algorithm \"${alg}\"`);\n  }\n  const paramBytes = paramBytesForAlg[alg];\n\n  // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n  const maxEncodedParamLength = paramBytes + 1;\n  const inputLength = signature.length;\n  let offset = 0;\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n  let seqLength = signature[offset++];\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++];\n  }\n  if (inputLength - offset < seqLength) {\n    throw new Error(`\"seq\" specified length of ${seqLength}\", only ${inputLength - offset}\" remaining`);\n  }\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n  const rLength = signature[offset++];\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`);\n  }\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n  }\n  const rOffset = offset;\n  offset += rLength;\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n  const sLength = signature[offset++];\n  if (inputLength - offset !== sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`);\n  }\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n  }\n  const sOffset = offset;\n  offset += sLength;\n  if (offset !== inputLength) {\n    throw new Error(`Expected to consume entire buffer, but \"${inputLength - offset}\" bytes remain`);\n  }\n  const rPadding = paramBytes - rLength;\n  const sPadding = paramBytes - sLength;\n  const dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n  offset = paramBytes;\n  for (const o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n  return dst;\n};\nmodule.exports.joseToDer = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(`Unknown algorithm \"${alg}\"`);\n  }\n  const paramBytes = paramBytesForAlg[alg];\n  const signatureBytes = signature.length;\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`);\n  }\n  const rPadding = countPadding(signature, 0, paramBytes);\n  const sPadding = countPadding(signature, paramBytes, signature.length);\n  const rLength = paramBytes - rPadding;\n  const sLength = paramBytes - sPadding;\n  const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  const shortLength = rsBytes < MAX_OCTET;\n  const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n  let offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1; // eslint-disable-line no-tabs\n    // length, base 256\n    dst[offset++] = rsBytes & 0xff;\n  }\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, paramBytes);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes);\n  }\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, paramBytes);\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding);\n  }\n  return dst;\n};","map":{"version":3,"names":["MAX_OCTET","CLASS_UNIVERSAL","PRIMITIVE_BIT","TAG_SEQ","TAG_INT","ENCODED_TAG_SEQ","ENCODED_TAG_INT","getParamSize","keySize","paramBytesForAlg","ES256","ES256K","ES384","ES512","countPadding","buf","start","stop","padding","needsSign","module","exports","derToJose","signature","alg","Buffer","isBuffer","TypeError","Error","paramBytes","maxEncodedParamLength","inputLength","length","offset","seqLength","rLength","rOffset","sLength","sOffset","rPadding","sPadding","dst","allocUnsafe","copy","Math","max","o","joseToDer","signatureBytes","rsBytes","shortLength"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/jose/lib/help/ecdsa_signatures.js"],"sourcesContent":["const MAX_OCTET = 0x80\nconst CLASS_UNIVERSAL = 0\nconst PRIMITIVE_BIT = 0x20\nconst TAG_SEQ = 0x10\nconst TAG_INT = 0x02\nconst ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6)\nconst ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6)\n\nconst getParamSize = keySize => ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1)\n\nconst paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n}\n\nconst countPadding = (buf, start, stop) => {\n  let padding = 0\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding\n  }\n\n  const needsSign = buf[start + padding] >= MAX_OCTET\n  if (needsSign) {\n    --padding\n  }\n\n  return padding\n}\n\nmodule.exports.derToJose = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n  const maxEncodedParamLength = paramBytes + 1\n\n  const inputLength = signature.length\n\n  let offset = 0\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"')\n  }\n\n  let seqLength = signature[offset++]\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++]\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error(`\"seq\" specified length of ${seqLength}\", only ${inputLength - offset}\" remaining`)\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"')\n  }\n\n  const rLength = signature[offset++]\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`)\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const rOffset = offset\n  offset += rLength\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"')\n  }\n\n  const sLength = signature[offset++]\n\n  if (inputLength - offset !== sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`)\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const sOffset = offset\n  offset += sLength\n\n  if (offset !== inputLength) {\n    throw new Error(`Expected to consume entire buffer, but \"${inputLength - offset}\" bytes remain`)\n  }\n\n  const rPadding = paramBytes - rLength\n\n  const sPadding = paramBytes - sLength\n\n  const dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength)\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength)\n\n  offset = paramBytes\n\n  for (const o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength)\n\n  return dst\n}\n\nmodule.exports.joseToDer = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  const signatureBytes = signature.length\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`)\n  }\n\n  const rPadding = countPadding(signature, 0, paramBytes)\n  const sPadding = countPadding(signature, paramBytes, signature.length)\n  const rLength = paramBytes - rPadding\n  const sLength = paramBytes - sPadding\n\n  const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength\n\n  const shortLength = rsBytes < MAX_OCTET\n\n  const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes)\n\n  let offset = 0\n  dst[offset++] = ENCODED_TAG_SEQ\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET\t| 1 // eslint-disable-line no-tabs\n    // length, base 256\n    dst[offset++] = rsBytes & 0xff\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = rLength\n  if (rPadding < 0) {\n    dst[offset++] = 0\n    offset += signature.copy(dst, offset, 0, paramBytes)\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes)\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = sLength\n  if (sPadding < 0) {\n    dst[offset++] = 0\n    signature.copy(dst, offset, paramBytes)\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding)\n  }\n\n  return dst\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}