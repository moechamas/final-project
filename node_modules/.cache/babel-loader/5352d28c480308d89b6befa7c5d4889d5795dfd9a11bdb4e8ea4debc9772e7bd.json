{"ast":null,"code":"const {\n  inflateRawSync\n} = require('zlib');\nconst base64url = require('../help/base64url');\nconst getKey = require('../help/get_key');\nconst {\n  KeyStore\n} = require('../jwks');\nconst errors = require('../errors');\nconst {\n  check,\n  decrypt,\n  keyManagementDecrypt\n} = require('../jwa');\nconst JWK = require('../jwk');\nconst {\n  createSecretKey\n} = require('../help/key_object');\nconst generateCEK = require('./generate_cek');\nconst validateHeaders = require('./validate_headers');\nconst {\n  detect: resolveSerialization\n} = require('./serializers');\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened']);\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot);\n  }\n  const p2s = prot.p2s || unprotected.p2s || header.p2s;\n  const apu = prot.apu || unprotected.apu || header.apu;\n  const apv = prot.apv || unprotected.apv || header.apv;\n  const iv = prot.iv || unprotected.iv || header.iv;\n  const tag = prot.tag || unprotected.tag || header.tag;\n  return {\n    ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? {\n      p2s: base64url.decodeToBuffer(p2s)\n    } : undefined),\n    ...(typeof apu === 'string' ? {\n      apu: base64url.decodeToBuffer(apu)\n    } : undefined),\n    ...(typeof apv === 'string' ? {\n      apv: base64url.decodeToBuffer(apv)\n    } : undefined),\n    ...(typeof iv === 'string' ? {\n      iv: base64url.decodeToBuffer(iv)\n    } : undefined),\n    ...(typeof tag === 'string' ? {\n      tag: base64url.decodeToBuffer(tag)\n    } : undefined)\n  };\n};\nconst validateAlgorithms = (algorithms, option) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError(`\"${option}\" option must be an array of non-empty strings`);\n  }\n  if (!algorithms) {\n    return undefined;\n  }\n  return new Set(algorithms);\n};\n\n/*\n * @public\n */\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, {\n  crit = [],\n  complete = false,\n  keyManagementAlgorithms,\n  contentEncryptionAlgorithms,\n  maxPBES2Count = 10000\n} = {}) => {\n  key = getKey(key, true);\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms');\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms');\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n  if (!serialization) {\n    serialization = resolveSerialization(jwe);\n  }\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header;\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened';\n    const {\n      recipients,\n      ...root\n    } = jwe;\n    jwe = {\n      ...root,\n      ...recipients[0]\n    };\n  }\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') {\n      // compact serialization format\n      [prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.');\n    } else {\n      // flattened serialization format\n      ({\n        protected: prot,\n        encrypted_key: encryptedKey,\n        iv,\n        ciphertext,\n        tag,\n        unprotected,\n        aad,\n        header\n      } = jwe);\n    }\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{\n        header\n      }], true, crit);\n    }\n    opts = combineHeader(prot, unprotected, header);\n    ({\n      alg,\n      enc\n    } = opts);\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted');\n    }\n    if (key instanceof KeyStore) {\n      const keystore = key;\n      let keys;\n      if (opts.alg === 'dir') {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.enc,\n          key_ops: ['decrypt']\n        });\n      } else {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.alg,\n          key_ops: ['unwrapKey']\n        });\n      }\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n        default:\n          {\n            const errs = [];\n            for (const key of keys) {\n              try {\n                return jweDecrypt(true, serialization, jwe, key, {\n                  crit,\n                  complete,\n                  contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n                  keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n                });\n              } catch (err) {\n                errs.push(err);\n                continue;\n              }\n            }\n            const multi = new errors.JOSEMultiError(errs);\n            if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n              throw new errors.JWEDecryptionFailed();\n            }\n            throw multi;\n          }\n      }\n    }\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]));\n    if (alg.startsWith('PBES2')) {\n      if (opts && opts.p2c > maxPBES2Count) {\n        throw new errors.JWEInvalid('JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds');\n      }\n    }\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, {\n          alg: enc,\n          use: 'enc'\n        });\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc);\n    }\n    let adata;\n    if (aad) {\n      adata = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.from(aad)]);\n    } else {\n      adata = Buffer.from(prot || '');\n    }\n    try {\n      iv = base64url.decodeToBuffer(iv);\n    } catch (err) {}\n    try {\n      tag = base64url.decodeToBuffer(tag);\n    } catch (err) {}\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), {\n      iv,\n      tag,\n      aad: adata\n    });\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext);\n    }\n    if (complete) {\n      const result = {\n        cleartext,\n        key,\n        cek\n      };\n      if (aad) result.aad = aad;\n      if (header) result.header = header;\n      if (unprotected) result.unprotected = unprotected;\n      if (prot) result.protected = base64url.JSON.decode(prot);\n      return result;\n    }\n    return cleartext;\n  }\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({\n    header\n  }) => ({\n    header\n  })), true, crit);\n\n  // general serialization format\n  const {\n    recipients,\n    ...root\n  } = jwe;\n  const errs = [];\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', {\n        ...root,\n        ...recipient\n      }, key, {\n        crit,\n        complete,\n        contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n        keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n      });\n    } catch (err) {\n      errs.push(err);\n      continue;\n    }\n  }\n  const multi = new errors.JOSEMultiError(errs);\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed();\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n  throw multi;\n};\nmodule.exports = jweDecrypt.bind(undefined, false, undefined);","map":{"version":3,"names":["inflateRawSync","require","base64url","getKey","KeyStore","errors","check","decrypt","keyManagementDecrypt","JWK","createSecretKey","generateCEK","validateHeaders","detect","resolveSerialization","SINGLE_RECIPIENT","Set","combineHeader","prot","unprotected","header","JSON","decode","p2s","apu","apv","iv","tag","decodeToBuffer","undefined","validateAlgorithms","algorithms","option","Array","isArray","some","s","TypeError","jweDecrypt","skipValidateHeaders","serialization","jwe","key","crit","complete","keyManagementAlgorithms","contentEncryptionAlgorithms","maxPBES2Count","alg","ciphertext","enc","encryptedKey","opts","cek","aad","recipients","length","root","has","split","protected","encrypted_key","JOSEAlgNotWhitelisted","keystore","keys","all","kid","key_ops","JWKSNoMatchingKey","errs","err","push","multi","JOSEMultiError","e","JWEDecryptionFailed","startsWith","p2c","JWEInvalid","asKey","use","unwrapped","adata","Buffer","concat","from","cleartext","zip","result","map","recipient","every","module","exports","bind"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/jose/lib/jwe/decrypt.js"],"sourcesContent":["const { inflateRawSync } = require('zlib')\n\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, decrypt, keyManagementDecrypt } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { createSecretKey } = require('../help/key_object')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\nconst { detect: resolveSerialization } = require('./serializers')\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened'])\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot)\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s\n  const apu = prot.apu || unprotected.apu || header.apu\n  const apv = prot.apv || unprotected.apv || header.apv\n  const iv = prot.iv || unprotected.iv || header.iv\n  const tag = prot.tag || unprotected.tag || header.tag\n\n  return {\n    ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? { p2s: base64url.decodeToBuffer(p2s) } : undefined),\n    ...(typeof apu === 'string' ? { apu: base64url.decodeToBuffer(apu) } : undefined),\n    ...(typeof apv === 'string' ? { apv: base64url.decodeToBuffer(apv) } : undefined),\n    ...(typeof iv === 'string' ? { iv: base64url.decodeToBuffer(iv) } : undefined),\n    ...(typeof tag === 'string' ? { tag: base64url.decodeToBuffer(tag) } : undefined)\n  }\n}\n\nconst validateAlgorithms = (algorithms, option) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError(`\"${option}\" option must be an array of non-empty strings`)\n  }\n\n  if (!algorithms) {\n    return undefined\n  }\n\n  return new Set(algorithms)\n}\n\n/*\n * @public\n */\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, { crit = [], complete = false, keyManagementAlgorithms, contentEncryptionAlgorithms, maxPBES2Count = 10000 } = {}) => {\n  key = getKey(key, true)\n\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms')\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms')\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe)\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened'\n    const { recipients, ...root } = jwe\n    jwe = { ...root, ...recipients[0] }\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') { // compact serialization format\n      ([prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.'))\n    } else { // flattened serialization format\n      ({ protected: prot, encrypted_key: encryptedKey, iv, ciphertext, tag, unprotected, aad, header } = jwe)\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{ header }], true, crit)\n    }\n\n    opts = combineHeader(prot, unprotected, header)\n\n    ;({ alg, enc } = opts)\n\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted')\n    }\n\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      let keys\n      if (opts.alg === 'dir') {\n        keys = keystore.all({ kid: opts.kid, alg: opts.enc, key_ops: ['decrypt'] })\n      } else {\n        keys = keystore.all({ kid: opts.kid, alg: opts.alg, key_ops: ['unwrapKey'] })\n      }\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jweDecrypt(true, serialization, jwe, key, {\n                crit,\n                complete,\n                contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n                keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n              })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n            throw new errors.JWEDecryptionFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]))\n\n    if (alg.startsWith('PBES2')) {\n      if (opts && opts.p2c > maxPBES2Count) {\n        throw new errors.JWEInvalid('JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds')\n      }\n    }\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, { alg: enc, use: 'enc' })\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc)\n    }\n\n    let adata\n    if (aad) {\n      adata = Buffer.concat([\n        Buffer.from(prot || ''),\n        Buffer.from('.'),\n        Buffer.from(aad)\n      ])\n    } else {\n      adata = Buffer.from(prot || '')\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv)\n    } catch (err) {}\n    try {\n      tag = base64url.decodeToBuffer(tag)\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), { iv, tag, aad: adata })\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext)\n    }\n\n    if (complete) {\n      const result = { cleartext, key, cek }\n      if (aad) result.aad = aad\n      if (header) result.header = header\n      if (unprotected) result.unprotected = unprotected\n      if (prot) result.protected = base64url.JSON.decode(prot)\n      return result\n    }\n\n    return cleartext\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({ header }) => ({ header })), true, crit)\n\n  // general serialization format\n  const { recipients, ...root } = jwe\n  const errs = []\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root, ...recipient }, key, {\n        crit,\n        complete,\n        contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n        keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n      })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined)\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}