{"ast":null,"code":"const {\n  createPublicKey,\n  createPrivateKey,\n  createSecretKey,\n  KeyObject\n} = require('../help/key_object');\nconst base64url = require('../help/base64url');\nconst isObject = require('../help/is_object');\nconst {\n  jwkToPem\n} = require('../help/key_utils');\nconst errors = require('../errors');\nconst RSAKey = require('./key/rsa');\nconst ECKey = require('./key/ec');\nconst OKPKey = require('./key/okp');\nconst OctKey = require('./key/oct');\nconst importable = new Set(['string', 'buffer', 'object']);\nconst mergedParameters = (target = {}, source = {}) => {\n  return {\n    alg: source.alg,\n    key_ops: source.key_ops,\n    kid: source.kid,\n    use: source.use,\n    x5c: source.x5c,\n    x5t: source.x5t,\n    'x5t#S256': source['x5t#S256'],\n    ...target\n  };\n};\nconst openSSHpublicKey = /^[a-zA-Z0-9-]+ AAAA(?:[0-9A-Za-z+/])+(?:==|=)?(?: .*)?$/;\nconst asKey = (key, parameters, {\n  calculateMissingRSAPrimes = false\n} = {}) => {\n  let privateKey, publicKey, secret;\n  if (!importable.has(typeof key)) {\n    throw new TypeError('key argument must be a string, buffer or an object');\n  }\n  if (parameters !== undefined && !isObject(parameters)) {\n    throw new TypeError('parameters argument must be a plain object when provided');\n  }\n  if (key instanceof KeyObject) {\n    switch (key.type) {\n      case 'private':\n        privateKey = key;\n        break;\n      case 'public':\n        publicKey = key;\n        break;\n      case 'secret':\n        secret = key;\n        break;\n    }\n  } else if (typeof key === 'object' && key && 'kty' in key && key.kty === 'oct') {\n    // symmetric key <Object>\n    try {\n      secret = createSecretKey(base64url.decodeToBuffer(key.k));\n    } catch (err) {\n      if (!('k' in key)) {\n        secret = {\n          type: 'secret'\n        };\n      }\n    }\n    parameters = mergedParameters(parameters, key);\n  } else if (typeof key === 'object' && key && 'kty' in key) {\n    // assume JWK formatted asymmetric key <Object>\n    ({\n      calculateMissingRSAPrimes = false\n    } = parameters || {\n      calculateMissingRSAPrimes\n    });\n    let pem;\n    try {\n      pem = jwkToPem(key, {\n        calculateMissingRSAPrimes\n      });\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n    if (pem && key.d) {\n      privateKey = createPrivateKey(pem);\n    } else if (pem) {\n      publicKey = createPublicKey(pem);\n    }\n    parameters = mergedParameters({}, key);\n  } else if (key && (typeof key === 'object' || typeof key === 'string')) {\n    // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey\n    try {\n      privateKey = createPrivateKey(key);\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n    try {\n      publicKey = createPublicKey(key);\n      if (key.startsWith('-----BEGIN CERTIFICATE-----') && (!parameters || !('x5c' in parameters))) {\n        parameters = mergedParameters(parameters, {\n          x5c: [key.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '')]\n        });\n      }\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n    try {\n      // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then\n      // have them imported as symmetric \"oct\" keys\n      if (!key.includes('-----BEGIN') && !openSSHpublicKey.test(key.toString('ascii').replace(/[\\r\\n]/g, ''))) {\n        secret = createSecretKey(Buffer.isBuffer(key) ? key : Buffer.from(key));\n      }\n    } catch (err) {}\n  }\n  const keyObject = privateKey || publicKey || secret;\n  if (privateKey || publicKey) {\n    switch (keyObject.asymmetricKeyType) {\n      case 'rsa':\n        return new RSAKey(keyObject, parameters);\n      case 'ec':\n        return new ECKey(keyObject, parameters);\n      case 'ed25519':\n      case 'ed448':\n      case 'x25519':\n      case 'x448':\n        return new OKPKey(keyObject, parameters);\n      default:\n        throw new errors.JOSENotSupported('only RSA, EC and OKP asymmetric keys are supported');\n    }\n  } else if (secret) {\n    return new OctKey(keyObject, parameters);\n  }\n  throw new errors.JWKImportFailed('key import failed');\n};\nmodule.exports = asKey;","map":{"version":3,"names":["createPublicKey","createPrivateKey","createSecretKey","KeyObject","require","base64url","isObject","jwkToPem","errors","RSAKey","ECKey","OKPKey","OctKey","importable","Set","mergedParameters","target","source","alg","key_ops","kid","use","x5c","x5t","openSSHpublicKey","asKey","key","parameters","calculateMissingRSAPrimes","privateKey","publicKey","secret","has","TypeError","undefined","type","kty","decodeToBuffer","k","err","pem","JOSEError","d","startsWith","replace","includes","test","toString","Buffer","isBuffer","from","keyObject","asymmetricKeyType","JOSENotSupported","JWKImportFailed","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/jose/lib/jwk/import.js"],"sourcesContent":["const { createPublicKey, createPrivateKey, createSecretKey, KeyObject } = require('../help/key_object')\nconst base64url = require('../help/base64url')\nconst isObject = require('../help/is_object')\nconst { jwkToPem } = require('../help/key_utils')\nconst errors = require('../errors')\n\nconst RSAKey = require('./key/rsa')\nconst ECKey = require('./key/ec')\nconst OKPKey = require('./key/okp')\nconst OctKey = require('./key/oct')\n\nconst importable = new Set(['string', 'buffer', 'object'])\n\nconst mergedParameters = (target = {}, source = {}) => {\n  return {\n    alg: source.alg,\n    key_ops: source.key_ops,\n    kid: source.kid,\n    use: source.use,\n    x5c: source.x5c,\n    x5t: source.x5t,\n    'x5t#S256': source['x5t#S256'],\n    ...target\n  }\n}\n\nconst openSSHpublicKey = /^[a-zA-Z0-9-]+ AAAA(?:[0-9A-Za-z+/])+(?:==|=)?(?: .*)?$/\n\nconst asKey = (key, parameters, { calculateMissingRSAPrimes = false } = {}) => {\n  let privateKey, publicKey, secret\n\n  if (!importable.has(typeof key)) {\n    throw new TypeError('key argument must be a string, buffer or an object')\n  }\n\n  if (parameters !== undefined && !isObject(parameters)) {\n    throw new TypeError('parameters argument must be a plain object when provided')\n  }\n\n  if (key instanceof KeyObject) {\n    switch (key.type) {\n      case 'private':\n        privateKey = key\n        break\n      case 'public':\n        publicKey = key\n        break\n      case 'secret':\n        secret = key\n        break\n    }\n  } else if (typeof key === 'object' && key && 'kty' in key && key.kty === 'oct') { // symmetric key <Object>\n    try {\n      secret = createSecretKey(base64url.decodeToBuffer(key.k))\n    } catch (err) {\n      if (!('k' in key)) {\n        secret = { type: 'secret' }\n      }\n    }\n    parameters = mergedParameters(parameters, key)\n  } else if (typeof key === 'object' && key && 'kty' in key) { // assume JWK formatted asymmetric key <Object>\n    ({ calculateMissingRSAPrimes = false } = parameters || { calculateMissingRSAPrimes })\n    let pem\n\n    try {\n      pem = jwkToPem(key, { calculateMissingRSAPrimes })\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    if (pem && key.d) {\n      privateKey = createPrivateKey(pem)\n    } else if (pem) {\n      publicKey = createPublicKey(pem)\n    }\n\n    parameters = mergedParameters({}, key)\n  } else if (key && (typeof key === 'object' || typeof key === 'string')) { // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey\n    try {\n      privateKey = createPrivateKey(key)\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    try {\n      publicKey = createPublicKey(key)\n      if (key.startsWith('-----BEGIN CERTIFICATE-----') && (!parameters || !('x5c' in parameters))) {\n        parameters = mergedParameters(parameters, {\n          x5c: [key.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '')]\n        })\n      }\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    try {\n      // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then\n      // have them imported as symmetric \"oct\" keys\n      if (!key.includes('-----BEGIN') && !openSSHpublicKey.test(key.toString('ascii').replace(/[\\r\\n]/g, ''))) {\n        secret = createSecretKey(Buffer.isBuffer(key) ? key : Buffer.from(key))\n      }\n    } catch (err) {}\n  }\n\n  const keyObject = privateKey || publicKey || secret\n\n  if (privateKey || publicKey) {\n    switch (keyObject.asymmetricKeyType) {\n      case 'rsa':\n        return new RSAKey(keyObject, parameters)\n      case 'ec':\n        return new ECKey(keyObject, parameters)\n      case 'ed25519':\n      case 'ed448':\n      case 'x25519':\n      case 'x448':\n        return new OKPKey(keyObject, parameters)\n      default:\n        throw new errors.JOSENotSupported('only RSA, EC and OKP asymmetric keys are supported')\n    }\n  } else if (secret) {\n    return new OctKey(keyObject, parameters)\n  }\n\n  throw new errors.JWKImportFailed('key import failed')\n}\n\nmodule.exports = asKey\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}