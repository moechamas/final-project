{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n\nconst url = require('url');\nconst {\n  format\n} = require('util');\nconst cloneDeep = require('./helpers/deep_clone');\nconst {\n  RPError,\n  OPError\n} = require('./errors');\nconst {\n  BaseClient\n} = require('./client');\nconst {\n  random,\n  codeChallenge\n} = require('./helpers/generators');\nconst pick = require('./helpers/pick');\nconst {\n  resolveResponseType,\n  resolveRedirectUri\n} = require('./helpers/client');\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n\n/**\n * @name constructor\n * @api public\n */\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = true,\n  extras = {}\n} = {}, verify) {\n  if (!(client instanceof BaseClient)) {\n    throw new TypeError('client must be an instance of openid-client Client');\n  }\n  if (typeof verify !== 'function') {\n    throw new TypeError('verify callback must be a function');\n  }\n  if (!client.issuer || !client.issuer.issuer) {\n    throw new TypeError('client must have an issuer with an identifier');\n  }\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = cloneDeep(params);\n  this._extras = cloneDeep(extras);\n  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n  if (!this._params.scope) this._params.scope = 'openid';\n  if (this._usePKCE === true) {\n    const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported) ? this._issuer.code_challenge_methods_supported : false;\n    if (supportedMethods && supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods && supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else if (supportedMethods) {\n      throw new TypeError('neither code_challenge_method supported by the client is supported by the issuer');\n    } else {\n      this._usePKCE = 'S256';\n    }\n  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {\n    throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n  this.name = url.parse(client.issuer.issuer).hostname;\n}\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  (async () => {\n    const client = this._client;\n    if (!req.session) {\n      throw new TypeError('authentication requires session support');\n    }\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n\n    /* start authentication request */\n    if (Object.keys(reqParams).length === 0) {\n      // provide options object with extra authentication parameters\n      const params = {\n        state: random(),\n        ...this._params,\n        ...options\n      };\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');\n      if (this._usePKCE && params.response_type.includes('code')) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n        switch (this._usePKCE) {\n          // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = codeChallenge(verifier);\n            params.code_challenge_method = 'S256';\n            break;\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n    const session = req.session[sessionKey];\n    if (Object.keys(session || {}).length === 0) {\n      throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n    }\n    const {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType\n    } = session;\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n    const opts = {\n      redirect_uri: this._params.redirect_uri,\n      ...options\n    };\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType\n    };\n    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n    const args = [tokenset, verified.bind(this)];\n    if (loadUserinfo) {\n      if (!tokenset.access_token) {\n        throw new RPError({\n          message: 'expected access_token to be returned when asking for userinfo in verify callback',\n          tokenset\n        });\n      }\n      const userinfo = await client.userinfo(tokenset);\n      args.splice(1, 0, userinfo);\n    }\n    if (passReq) {\n      args.unshift(req);\n    }\n    this._verify(...args);\n    /* end authentication response */\n  })().catch(error => {\n    if (error instanceof OPError && error.error !== 'server_error' && !error.error.startsWith('invalid') || error instanceof RPError) {\n      this.fail(error);\n    } else {\n      this.error(error);\n    }\n  });\n};\nmodule.exports = OpenIDConnectStrategy;","map":{"version":3,"names":["url","require","format","cloneDeep","RPError","OPError","BaseClient","random","codeChallenge","pick","resolveResponseType","resolveRedirectUri","verified","err","user","info","error","fail","success","OpenIDConnectStrategy","client","params","passReqToCallback","sessionKey","usePKCE","extras","verify","TypeError","issuer","_client","_issuer","_verify","_passReqToCallback","_usePKCE","_key","parse","hostname","_params","_extras","response_type","call","redirect_uri","scope","supportedMethods","Array","isArray","code_challenge_methods_supported","includes","name","prototype","authenticate","req","options","session","reqParams","callbackParams","Object","keys","length","state","nonce","verifier","code_verifier","code_challenge","code_challenge_method","redirect","authorizationUrl","Error","max_age","maxAge","codeVerifier","responseType","opts","checks","tokenset","callback","passReq","loadUserinfo","userinfo_endpoint","args","bind","access_token","message","userinfo","splice","unshift","catch","startsWith","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/openid-client/lib/passport_strategy.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nconst url = require('url');\nconst { format } = require('util');\n\nconst cloneDeep = require('./helpers/deep_clone');\nconst { RPError, OPError } = require('./errors');\nconst { BaseClient } = require('./client');\nconst { random, codeChallenge } = require('./helpers/generators');\nconst pick = require('./helpers/pick');\nconst { resolveResponseType, resolveRedirectUri } = require('./helpers/client');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n\n/**\n * @name constructor\n * @api public\n */\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = true,\n  extras = {},\n} = {}, verify) {\n  if (!(client instanceof BaseClient)) {\n    throw new TypeError('client must be an instance of openid-client Client');\n  }\n\n  if (typeof verify !== 'function') {\n    throw new TypeError('verify callback must be a function');\n  }\n\n  if (!client.issuer || !client.issuer.issuer) {\n    throw new TypeError('client must have an issuer with an identifier');\n  }\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = cloneDeep(params);\n  this._extras = cloneDeep(extras);\n\n  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n  if (!this._params.scope) this._params.scope = 'openid';\n\n  if (this._usePKCE === true) {\n    const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported)\n      ? this._issuer.code_challenge_methods_supported : false;\n\n    if (supportedMethods && supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods && supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else if (supportedMethods) {\n      throw new TypeError('neither code_challenge_method supported by the client is supported by the issuer');\n    } else {\n      this._usePKCE = 'S256';\n    }\n  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {\n    throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  (async () => {\n    const client = this._client;\n    if (!req.session) {\n      throw new TypeError('authentication requires session support');\n    }\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n\n    /* start authentication request */\n    if (Object.keys(reqParams).length === 0) {\n      // provide options object with extra authentication parameters\n      const params = {\n        state: random(),\n        ...this._params,\n        ...options,\n      };\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE && params.response_type.includes('code')) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) { // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = codeChallenge(verifier);\n            params.code_challenge_method = 'S256';\n            break;\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n    const session = req.session[sessionKey];\n    if (Object.keys(session || {}).length === 0) {\n      throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n    }\n\n    const {\n      state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType,\n    } = session;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = {\n      redirect_uri: this._params.redirect_uri,\n      ...options,\n    };\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType,\n    };\n\n    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);\n\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    const args = [tokenset, verified.bind(this)];\n\n    if (loadUserinfo) {\n      if (!tokenset.access_token) {\n        throw new RPError({\n          message: 'expected access_token to be returned when asking for userinfo in verify callback',\n          tokenset,\n        });\n      }\n      const userinfo = await client.userinfo(tokenset);\n      args.splice(1, 0, userinfo);\n    }\n\n    if (passReq) {\n      args.unshift(req);\n    }\n\n    this._verify(...args);\n    /* end authentication response */\n  })().catch((error) => {\n    if (\n      (error instanceof OPError && error.error !== 'server_error' && !error.error.startsWith('invalid'))\n      || error instanceof RPError\n    ) {\n      this.fail(error);\n    } else {\n      this.error(error);\n    }\n  });\n};\n\nmodule.exports = OpenIDConnectStrategy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}