{"ast":null,"code":"const {\n  STATUS_CODES\n} = require('http');\nconst {\n  format\n} = require('util');\nconst {\n  OPError\n} = require('../errors');\nconst REGEXP = /(\\w+)=(\"[^\"]*\")/g;\nconst throwAuthenticateErrors = response => {\n  const params = {};\n  try {\n    while (REGEXP.exec(response.headers['www-authenticate']) !== null) {\n      if (RegExp.$1 && RegExp.$2) {\n        params[RegExp.$1] = RegExp.$2.slice(1, -1);\n      }\n    }\n  } catch (err) {}\n  if (params.error) {\n    throw new OPError(params, response);\n  }\n};\nconst isStandardBodyError = response => {\n  let result = false;\n  try {\n    let jsonbody;\n    if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {\n      jsonbody = JSON.parse(response.body);\n    } else {\n      jsonbody = response.body;\n    }\n    result = typeof jsonbody.error === 'string' && jsonbody.error.length;\n    if (result) response.body = jsonbody;\n  } catch (err) {}\n  return result;\n};\nfunction processResponse(response, {\n  statusCode = 200,\n  body = true,\n  bearer = false\n} = {}) {\n  if (response.statusCode !== statusCode) {\n    if (bearer) {\n      throwAuthenticateErrors(response);\n    }\n    if (isStandardBodyError(response)) {\n      throw new OPError(response.body, response);\n    }\n    throw new OPError({\n      error: format('expected %i %s, got: %i %s', statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])\n    }, response);\n  }\n  if (body && !response.body) {\n    throw new OPError({\n      error: format('expected %i %s with body but no body was returned', statusCode, STATUS_CODES[statusCode])\n    }, response);\n  }\n  return response.body;\n}\nmodule.exports = processResponse;","map":{"version":3,"names":["STATUS_CODES","require","format","OPError","REGEXP","throwAuthenticateErrors","response","params","exec","headers","RegExp","$1","$2","slice","err","error","isStandardBodyError","result","jsonbody","body","Buffer","isBuffer","JSON","parse","length","processResponse","statusCode","bearer","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/openid-client/lib/helpers/process_response.js"],"sourcesContent":["const { STATUS_CODES } = require('http');\nconst { format } = require('util');\n\nconst { OPError } = require('../errors');\n\nconst REGEXP = /(\\w+)=(\"[^\"]*\")/g;\nconst throwAuthenticateErrors = (response) => {\n  const params = {};\n  try {\n    while ((REGEXP.exec(response.headers['www-authenticate'])) !== null) {\n      if (RegExp.$1 && RegExp.$2) {\n        params[RegExp.$1] = RegExp.$2.slice(1, -1);\n      }\n    }\n  } catch (err) {}\n\n  if (params.error) {\n    throw new OPError(params, response);\n  }\n};\n\nconst isStandardBodyError = (response) => {\n  let result = false;\n  try {\n    let jsonbody;\n    if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {\n      jsonbody = JSON.parse(response.body);\n    } else {\n      jsonbody = response.body;\n    }\n    result = typeof jsonbody.error === 'string' && jsonbody.error.length;\n    if (result) response.body = jsonbody;\n  } catch (err) {}\n\n  return result;\n};\n\nfunction processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {\n  if (response.statusCode !== statusCode) {\n    if (bearer) {\n      throwAuthenticateErrors(response);\n    }\n\n    if (isStandardBodyError(response)) {\n      throw new OPError(response.body, response);\n    }\n\n    throw new OPError({\n      error: format('expected %i %s, got: %i %s', statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode]),\n    }, response);\n  }\n\n  if (body && !response.body) {\n    throw new OPError({\n      error: format('expected %i %s with body but no body was returned', statusCode, STATUS_CODES[statusCode]),\n    }, response);\n  }\n\n  return response.body;\n}\n\nmodule.exports = processResponse;\n"],"mappings":"AAAA,MAAM;EAAEA;AAAa,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AACxC,MAAM;EAAEC;AAAO,CAAC,GAAGD,OAAO,CAAC,MAAM,CAAC;AAElC,MAAM;EAAEE;AAAQ,CAAC,GAAGF,OAAO,CAAC,WAAW,CAAC;AAExC,MAAMG,MAAM,GAAG,kBAAkB;AACjC,MAAMC,uBAAuB,GAAIC,QAAQ,IAAK;EAC5C,MAAMC,MAAM,GAAG,CAAC,CAAC;EACjB,IAAI;IACF,OAAQH,MAAM,CAACI,IAAI,CAACF,QAAQ,CAACG,OAAO,CAAC,kBAAkB,CAAC,CAAC,KAAM,IAAI,EAAE;MACnE,IAAIC,MAAM,CAACC,EAAE,IAAID,MAAM,CAACE,EAAE,EAAE;QAC1BL,MAAM,CAACG,MAAM,CAACC,EAAE,CAAC,GAAGD,MAAM,CAACE,EAAE,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC5C;IACF;EACF,CAAC,CAAC,OAAOC,GAAG,EAAE,CAAC;EAEf,IAAIP,MAAM,CAACQ,KAAK,EAAE;IAChB,MAAM,IAAIZ,OAAO,CAACI,MAAM,EAAED,QAAQ,CAAC;EACrC;AACF,CAAC;AAED,MAAMU,mBAAmB,GAAIV,QAAQ,IAAK;EACxC,IAAIW,MAAM,GAAG,KAAK;EAClB,IAAI;IACF,IAAIC,QAAQ;IACZ,IAAI,OAAOZ,QAAQ,CAACa,IAAI,KAAK,QAAQ,IAAIC,MAAM,CAACC,QAAQ,CAACf,QAAQ,CAACa,IAAI,CAAC,EAAE;MACvED,QAAQ,GAAGI,IAAI,CAACC,KAAK,CAACjB,QAAQ,CAACa,IAAI,CAAC;IACtC,CAAC,MAAM;MACLD,QAAQ,GAAGZ,QAAQ,CAACa,IAAI;IAC1B;IACAF,MAAM,GAAG,OAAOC,QAAQ,CAACH,KAAK,KAAK,QAAQ,IAAIG,QAAQ,CAACH,KAAK,CAACS,MAAM;IACpE,IAAIP,MAAM,EAAEX,QAAQ,CAACa,IAAI,GAAGD,QAAQ;EACtC,CAAC,CAAC,OAAOJ,GAAG,EAAE,CAAC;EAEf,OAAOG,MAAM;AACf,CAAC;AAED,SAASQ,eAAeA,CAACnB,QAAQ,EAAE;EAAEoB,UAAU,GAAG,GAAG;EAAEP,IAAI,GAAG,IAAI;EAAEQ,MAAM,GAAG;AAAM,CAAC,GAAG,CAAC,CAAC,EAAE;EACzF,IAAIrB,QAAQ,CAACoB,UAAU,KAAKA,UAAU,EAAE;IACtC,IAAIC,MAAM,EAAE;MACVtB,uBAAuB,CAACC,QAAQ,CAAC;IACnC;IAEA,IAAIU,mBAAmB,CAACV,QAAQ,CAAC,EAAE;MACjC,MAAM,IAAIH,OAAO,CAACG,QAAQ,CAACa,IAAI,EAAEb,QAAQ,CAAC;IAC5C;IAEA,MAAM,IAAIH,OAAO,CAAC;MAChBY,KAAK,EAAEb,MAAM,CAAC,4BAA4B,EAAEwB,UAAU,EAAE1B,YAAY,CAAC0B,UAAU,CAAC,EAAEpB,QAAQ,CAACoB,UAAU,EAAE1B,YAAY,CAACM,QAAQ,CAACoB,UAAU,CAAC;IAC1I,CAAC,EAAEpB,QAAQ,CAAC;EACd;EAEA,IAAIa,IAAI,IAAI,CAACb,QAAQ,CAACa,IAAI,EAAE;IAC1B,MAAM,IAAIhB,OAAO,CAAC;MAChBY,KAAK,EAAEb,MAAM,CAAC,mDAAmD,EAAEwB,UAAU,EAAE1B,YAAY,CAAC0B,UAAU,CAAC;IACzG,CAAC,EAAEpB,QAAQ,CAAC;EACd;EAEA,OAAOA,QAAQ,CAACa,IAAI;AACtB;AAEAS,MAAM,CAACC,OAAO,GAAGJ,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}