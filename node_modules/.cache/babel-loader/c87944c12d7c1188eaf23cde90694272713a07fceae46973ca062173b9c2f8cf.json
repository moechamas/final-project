{"ast":null,"code":"const {\n  keyObjectSupported\n} = require('./runtime_support');\nlet createPublicKey;\nlet createPrivateKey;\nlet createSecretKey;\nlet KeyObject;\nlet asInput;\nif (keyObjectSupported) {\n  ({\n    createPublicKey,\n    createPrivateKey,\n    createSecretKey,\n    KeyObject\n  } = require('crypto'));\n  asInput = input => input;\n} else {\n  const {\n    EOL\n  } = require('os');\n  const errors = require('../errors');\n  const isObject = require('./is_object');\n  const asn1 = require('./asn1');\n  const toInput = Symbol('toInput');\n  const namedCurve = Symbol('namedCurve');\n  asInput = (keyObject, needsPublic) => {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic);\n    }\n    return createSecretKey(keyObject)[toInput](needsPublic);\n  };\n  const pemToDer = pem => Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64');\n  const derToPem = (der, label) => `-----BEGIN ${label}-----${EOL}${(der.toString('base64').match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END ${label}-----`;\n  const unsupported = input => {\n    const label = typeof input === 'string' ? input : `OID ${input.join('.')}`;\n    throw new errors.JOSENotSupported(`${label} is not supported in your Node.js runtime version`);\n  };\n  KeyObject = class KeyObject {\n    export({\n      cipher,\n      passphrase,\n      type,\n      format\n    } = {}) {\n      if (this._type === 'secret') {\n        return this._buffer;\n      }\n      if (this._type === 'public') {\n        if (this.asymmetricKeyType === 'rsa') {\n          switch (type) {\n            case 'pkcs1':\n              if (format === 'pem') {\n                return this._pem;\n              }\n              return pemToDer(this._pem);\n            case 'spki':\n              {\n                const PublicKeyInfo = asn1.get('PublicKeyInfo');\n                const pem = PublicKeyInfo.encode({\n                  algorithm: {\n                    algorithm: 'rsaEncryption',\n                    parameters: {\n                      type: 'null'\n                    }\n                  },\n                  publicKey: {\n                    unused: 0,\n                    data: pemToDer(this._pem)\n                  }\n                }, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                return format === 'pem' ? pem : pemToDer(pem);\n              }\n            default:\n              throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n          }\n        }\n        if (this.asymmetricKeyType === 'ec') {\n          if (type !== 'spki') {\n            throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n          }\n          if (format === 'pem') {\n            return this._pem;\n          }\n          return pemToDer(this._pem);\n        }\n      }\n      if (this._type === 'private') {\n        if (passphrase !== undefined || cipher !== undefined) {\n          throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n        }\n        if (type === 'pkcs8') {\n          if (this._pkcs8) {\n            if (format === 'der' && typeof this._pkcs8 === 'string') {\n              return pemToDer(this._pkcs8);\n            }\n            if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n              return derToPem(this._pkcs8, 'PRIVATE KEY');\n            }\n            return this._pkcs8;\n          }\n          if (this.asymmetricKeyType === 'rsa') {\n            const parsed = this._asn1;\n            const RSAPrivateKey = asn1.get('RSAPrivateKey');\n            const privateKey = RSAPrivateKey.encode(parsed);\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'rsaEncryption',\n                parameters: {\n                  type: 'null'\n                }\n              }\n            });\n            this._pkcs8 = pkcs8;\n            return this.export({\n              type,\n              format\n            });\n          }\n          if (this.asymmetricKeyType === 'ec') {\n            const parsed = this._asn1;\n            const ECPrivateKey = asn1.get('ECPrivateKey');\n            const privateKey = ECPrivateKey.encode({\n              version: parsed.version,\n              privateKey: parsed.privateKey,\n              publicKey: parsed.publicKey\n            });\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: this._asn1.parameters\n              }\n            });\n            this._pkcs8 = pkcs8;\n            return this.export({\n              type,\n              format\n            });\n          }\n        }\n        if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n          if (format === 'pem') {\n            return this._pem;\n          }\n          return pemToDer(this._pem);\n        } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n          if (format === 'pem') {\n            return this._pem;\n          }\n          return pemToDer(this._pem);\n        } else {\n          throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n        }\n      }\n    }\n    get type() {\n      return this._type;\n    }\n    get asymmetricKeyType() {\n      return this._asymmetricKeyType;\n    }\n    get symmetricKeySize() {\n      return this._symmetricKeySize;\n    }\n    [toInput](needsPublic) {\n      switch (this._type) {\n        case 'secret':\n          return this._buffer;\n        case 'public':\n          return this._pem;\n        default:\n          if (needsPublic) {\n            if (!('_pub' in this)) {\n              this._pub = createPublicKey(this);\n            }\n            return this._pub[toInput](false);\n          }\n          return this._pem;\n      }\n    }\n  };\n  createSecretKey = buffer => {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance');\n    }\n    const keyObject = new KeyObject();\n    keyObject._buffer = Buffer.from(buffer);\n    keyObject._symmetricKeySize = buffer.length;\n    keyObject._type = 'secret';\n    return keyObject;\n  };\n  createPublicKey = input => {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(`Invalid key object type ${input.type}, expected private.`);\n      }\n      switch (input.asymmetricKeyType) {\n        case 'ec':\n          {\n            const PublicKeyInfo = asn1.get('PublicKeyInfo');\n            const key = PublicKeyInfo.encode({\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: input._asn1.parameters\n              },\n              publicKey: input._asn1.publicKey\n            });\n            return createPublicKey({\n              key,\n              format: 'der',\n              type: 'spki'\n            });\n          }\n        case 'rsa':\n          {\n            const RSAPublicKey = asn1.get('RSAPublicKey');\n            const key = RSAPublicKey.encode(input._asn1);\n            return createPublicKey({\n              key,\n              format: 'der',\n              type: 'pkcs1'\n            });\n          }\n      }\n    }\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n    const {\n      format,\n      passphrase\n    } = input;\n    let {\n      key,\n      type\n    } = input;\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n    let label;\n    if (format === 'pem') {\n      key = key.toString();\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki';\n          label = 'PUBLIC KEY';\n          break;\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PUBLIC KEY';\n          break;\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version');\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return createPublicKey(createPrivateKey(key));\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n    switch (type) {\n      case 'spki':\n        {\n          const PublicKeyInfo = asn1.get('PublicKeyInfo');\n          const parsed = PublicKeyInfo.decode(key, format, {\n            label\n          });\n          let type, keyObject;\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                keyObject = new KeyObject();\n                keyObject._asn1 = parsed;\n                keyObject._asymmetricKeyType = 'ec';\n                keyObject._type = 'public';\n                keyObject._pem = PublicKeyInfo.encode(parsed, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                break;\n              }\n            case 'rsaEncryption':\n              {\n                type = 'pkcs1';\n                keyObject = createPublicKey({\n                  type,\n                  key: parsed.publicKey.data,\n                  format: 'der'\n                });\n                break;\n              }\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n          return keyObject;\n        }\n      case 'pkcs1':\n        {\n          const RSAPublicKey = asn1.get('RSAPublicKey');\n          const parsed = RSAPublicKey.decode(key, format, {\n            label\n          });\n\n          // special case when private pkcs1 PEM / DER is used with createPublicKey\n          if (parsed.n === BigInt(0)) {\n            return createPublicKey(createPrivateKey({\n              key,\n              format,\n              type,\n              passphrase\n            }));\n          }\n          const keyObject = new KeyObject();\n          keyObject._asn1 = parsed;\n          keyObject._asymmetricKeyType = 'rsa';\n          keyObject._type = 'public';\n          keyObject._pem = RSAPublicKey.encode(parsed, 'pem', {\n            label: 'RSA PUBLIC KEY'\n          });\n          return keyObject;\n        }\n      case 'pkcs8':\n      case 'sec1':\n        return createPublicKey(createPrivateKey({\n          format,\n          key,\n          type,\n          passphrase\n        }));\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n    }\n  };\n  createPrivateKey = (input, hints) => {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n    const {\n      format,\n      passphrase\n    } = input;\n    let {\n      key,\n      type\n    } = input;\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n    }\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n    let label;\n    if (format === 'pem') {\n      key = key.toString();\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8';\n          label = 'PRIVATE KEY';\n          break;\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1';\n          label = 'EC PRIVATE KEY';\n          break;\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PRIVATE KEY';\n          break;\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n    switch (type) {\n      case 'pkcs8':\n        {\n          const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n          const parsed = PrivateKeyInfo.decode(key, format, {\n            label\n          });\n          let type, keyObject;\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                type = 'sec1';\n                keyObject = createPrivateKey({\n                  type,\n                  key: parsed.privateKey,\n                  format: 'der'\n                }, {\n                  [namedCurve]: parsed.algorithm.parameters.value\n                });\n                break;\n              }\n            case 'rsaEncryption':\n              {\n                type = 'pkcs1';\n                keyObject = createPrivateKey({\n                  type,\n                  key: parsed.privateKey,\n                  format: 'der'\n                });\n                break;\n              }\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n          keyObject._pkcs8 = key;\n          return keyObject;\n        }\n      case 'pkcs1':\n        {\n          const RSAPrivateKey = asn1.get('RSAPrivateKey');\n          const parsed = RSAPrivateKey.decode(key, format, {\n            label\n          });\n          const keyObject = new KeyObject();\n          keyObject._asn1 = parsed;\n          keyObject._asymmetricKeyType = 'rsa';\n          keyObject._type = 'private';\n          keyObject._pem = RSAPrivateKey.encode(parsed, 'pem', {\n            label: 'RSA PRIVATE KEY'\n          });\n          return keyObject;\n        }\n      case 'sec1':\n        {\n          const ECPrivateKey = asn1.get('ECPrivateKey');\n          let parsed = ECPrivateKey.decode(key, format, {\n            label\n          });\n          if (!('parameters' in parsed) && !hints[namedCurve]) {\n            throw new Error('invalid sec1');\n          } else if (!('parameters' in parsed)) {\n            parsed = {\n              ...parsed,\n              parameters: {\n                type: 'namedCurve',\n                value: hints[namedCurve]\n              }\n            };\n          }\n          const keyObject = new KeyObject();\n          keyObject._asn1 = parsed;\n          keyObject._asymmetricKeyType = 'ec';\n          keyObject._type = 'private';\n          keyObject._pem = ECPrivateKey.encode(parsed, 'pem', {\n            label: 'EC PRIVATE KEY'\n          });\n          return keyObject;\n        }\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n    }\n  };\n}\nmodule.exports = {\n  createPublicKey,\n  createPrivateKey,\n  createSecretKey,\n  KeyObject,\n  asInput\n};","map":{"version":3,"names":["keyObjectSupported","require","createPublicKey","createPrivateKey","createSecretKey","KeyObject","asInput","input","EOL","errors","isObject","asn1","toInput","Symbol","namedCurve","keyObject","needsPublic","pemToDer","pem","Buffer","from","replace","derToPem","der","label","toString","match","join","unsupported","JOSENotSupported","export","cipher","passphrase","type","format","_type","_buffer","asymmetricKeyType","_pem","PublicKeyInfo","get","encode","algorithm","parameters","publicKey","unused","data","TypeError","undefined","_pkcs8","isBuffer","parsed","_asn1","RSAPrivateKey","privateKey","PrivateKeyInfo","pkcs8","version","ECPrivateKey","_asymmetricKeyType","symmetricKeySize","_symmetricKeySize","_pub","buffer","length","key","RSAPublicKey","split","decode","n","BigInt","hints","value","Error","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/jose/lib/help/key_object.js"],"sourcesContent":["const { keyObjectSupported } = require('./runtime_support')\n\nlet createPublicKey\nlet createPrivateKey\nlet createSecretKey\nlet KeyObject\nlet asInput\n\nif (keyObjectSupported) {\n  ({ createPublicKey, createPrivateKey, createSecretKey, KeyObject } = require('crypto'))\n  asInput = (input) => input\n} else {\n  const { EOL } = require('os')\n\n  const errors = require('../errors')\n  const isObject = require('./is_object')\n  const asn1 = require('./asn1')\n  const toInput = Symbol('toInput')\n\n  const namedCurve = Symbol('namedCurve')\n\n  asInput = (keyObject, needsPublic) => {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic)\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic)\n  }\n\n  const pemToDer = pem => Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64')\n  const derToPem = (der, label) => `-----BEGIN ${label}-----${EOL}${(der.toString('base64').match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END ${label}-----`\n  const unsupported = (input) => {\n    const label = typeof input === 'string' ? input : `OID ${input.join('.')}`\n    throw new errors.JOSENotSupported(`${label} is not supported in your Node.js runtime version`)\n  }\n\n  KeyObject = class KeyObject {\n    export ({ cipher, passphrase, type, format } = {}) {\n      if (this._type === 'secret') {\n        return this._buffer\n      }\n\n      if (this._type === 'public') {\n        if (this.asymmetricKeyType === 'rsa') {\n          switch (type) {\n            case 'pkcs1':\n              if (format === 'pem') {\n                return this._pem\n              }\n\n              return pemToDer(this._pem)\n            case 'spki': {\n              const PublicKeyInfo = asn1.get('PublicKeyInfo')\n              const pem = PublicKeyInfo.encode({\n                algorithm: {\n                  algorithm: 'rsaEncryption',\n                  parameters: { type: 'null' }\n                },\n                publicKey: {\n                  unused: 0,\n                  data: pemToDer(this._pem)\n                }\n              }, 'pem', { label: 'PUBLIC KEY' })\n\n              return format === 'pem' ? pem : pemToDer(pem)\n            }\n            default:\n              throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n        }\n\n        if (this.asymmetricKeyType === 'ec') {\n          if (type !== 'spki') {\n            throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        }\n      }\n\n      if (this._type === 'private') {\n        if (passphrase !== undefined || cipher !== undefined) {\n          throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n        }\n\n        if (type === 'pkcs8') {\n          if (this._pkcs8) {\n            if (format === 'der' && typeof this._pkcs8 === 'string') {\n              return pemToDer(this._pkcs8)\n            }\n\n            if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n              return derToPem(this._pkcs8, 'PRIVATE KEY')\n            }\n\n            return this._pkcs8\n          }\n\n          if (this.asymmetricKeyType === 'rsa') {\n            const parsed = this._asn1\n            const RSAPrivateKey = asn1.get('RSAPrivateKey')\n            const privateKey = RSAPrivateKey.encode(parsed)\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'rsaEncryption',\n                parameters: { type: 'null' }\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            const parsed = this._asn1\n            const ECPrivateKey = asn1.get('ECPrivateKey')\n            const privateKey = ECPrivateKey.encode({\n              version: parsed.version,\n              privateKey: parsed.privateKey,\n              publicKey: parsed.publicKey\n            })\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: this._asn1.parameters\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n        }\n\n        if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else {\n          throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n        }\n      }\n    }\n\n    get type () {\n      return this._type\n    }\n\n    get asymmetricKeyType () {\n      return this._asymmetricKeyType\n    }\n\n    get symmetricKeySize () {\n      return this._symmetricKeySize\n    }\n\n    [toInput] (needsPublic) {\n      switch (this._type) {\n        case 'secret':\n          return this._buffer\n        case 'public':\n          return this._pem\n        default:\n          if (needsPublic) {\n            if (!('_pub' in this)) {\n              this._pub = createPublicKey(this)\n            }\n\n            return this._pub[toInput](false)\n          }\n\n          return this._pem\n      }\n    }\n  }\n\n  createSecretKey = (buffer) => {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance')\n    }\n\n    const keyObject = new KeyObject()\n    keyObject._buffer = Buffer.from(buffer)\n    keyObject._symmetricKeySize = buffer.length\n    keyObject._type = 'secret'\n\n    return keyObject\n  }\n\n  createPublicKey = (input) => {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(`Invalid key object type ${input.type}, expected private.`)\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec': {\n          const PublicKeyInfo = asn1.get('PublicKeyInfo')\n          const key = PublicKeyInfo.encode({\n            algorithm: {\n              algorithm: 'ecPublicKey',\n              parameters: input._asn1.parameters\n            },\n            publicKey: input._asn1.publicKey\n          })\n\n          return createPublicKey({ key, format: 'der', type: 'spki' })\n        }\n        case 'rsa': {\n          const RSAPublicKey = asn1.get('RSAPublicKey')\n          const key = RSAPublicKey.encode(input._asn1)\n          return createPublicKey({ key, format: 'der', type: 'pkcs1' })\n        }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki'\n          label = 'PUBLIC KEY'\n          break\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PUBLIC KEY'\n          break\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version')\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return createPublicKey(createPrivateKey(key))\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'spki': {\n        const PublicKeyInfo = asn1.get('PublicKeyInfo')\n        const parsed = PublicKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            keyObject = new KeyObject()\n            keyObject._asn1 = parsed\n            keyObject._asymmetricKeyType = 'ec'\n            keyObject._type = 'public'\n            keyObject._pem = PublicKeyInfo.encode(parsed, 'pem', { label: 'PUBLIC KEY' })\n\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPublicKey({ type, key: parsed.publicKey.data, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPublicKey = asn1.get('RSAPublicKey')\n        const parsed = RSAPublicKey.decode(key, format, { label })\n\n        // special case when private pkcs1 PEM / DER is used with createPublicKey\n        if (parsed.n === BigInt(0)) {\n          return createPublicKey(createPrivateKey({ key, format, type, passphrase }))\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'public'\n        keyObject._pem = RSAPublicKey.encode(parsed, 'pem', { label: 'RSA PUBLIC KEY' })\n\n        return keyObject\n      }\n      case 'pkcs8':\n      case 'sec1':\n        return createPublicKey(createPrivateKey({ format, key, type, passphrase }))\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n\n  createPrivateKey = (input, hints) => {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8'\n          label = 'PRIVATE KEY'\n          break\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1'\n          label = 'EC PRIVATE KEY'\n          break\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PRIVATE KEY'\n          break\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8': {\n        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n        const parsed = PrivateKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            type = 'sec1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' }, { [namedCurve]: parsed.algorithm.parameters.value })\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        keyObject._pkcs8 = key\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPrivateKey = asn1.get('RSAPrivateKey')\n        const parsed = RSAPrivateKey.decode(key, format, { label })\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'private'\n        keyObject._pem = RSAPrivateKey.encode(parsed, 'pem', { label: 'RSA PRIVATE KEY' })\n\n        return keyObject\n      }\n      case 'sec1': {\n        const ECPrivateKey = asn1.get('ECPrivateKey')\n        let parsed = ECPrivateKey.decode(key, format, { label })\n\n        if (!('parameters' in parsed) && !hints[namedCurve]) {\n          throw new Error('invalid sec1')\n        } else if (!('parameters' in parsed)) {\n          parsed = { ...parsed, parameters: { type: 'namedCurve', value: hints[namedCurve] } }\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'ec'\n        keyObject._type = 'private'\n        keyObject._pem = ECPrivateKey.encode(parsed, 'pem', { label: 'EC PRIVATE KEY' })\n\n        return keyObject\n      }\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n}\n\nmodule.exports = { createPublicKey, createPrivateKey, createSecretKey, KeyObject, asInput }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}