{"ast":null,"code":"const url = require('url');\nconst urlJoin = require('url-join');\nconst {\n  JWT\n} = require('jose');\nconst {\n  TokenSet\n} = require('openid-client');\nconst clone = require('clone');\nconst {\n  strict: assert\n} = require('assert');\nconst createError = require('http-errors');\nconst debug = require('./debug')('context');\nconst {\n  once\n} = require('./once');\nconst {\n  get: getClient\n} = require('./client');\nconst {\n  encodeState,\n  decodeState\n} = require('../lib/hooks/getLoginState');\nconst onLogin = require('./hooks/backchannelLogout/onLogIn');\nconst onLogoutToken = require('./hooks/backchannelLogout/onLogoutToken');\nconst {\n  cancelSilentLogin,\n  resumeSilentLogin\n} = require('../middleware/attemptSilentLogin');\nconst weakRef = require('./weakCache');\nconst {\n  regenerateSessionStoreId,\n  replaceSession\n} = require('../lib/appSession');\nfunction isExpired() {\n  return tokenSet.call(this).expired();\n}\nasync function refresh({\n  tokenEndpointParams\n} = {}) {\n  let {\n    config,\n    req\n  } = weakRef(this);\n  const {\n    client\n  } = await getClient(config);\n  const oldTokenSet = tokenSet.call(this);\n  let extras;\n  if (config.tokenEndpointParams || tokenEndpointParams) {\n    extras = {\n      exchangeBody: {\n        ...config.tokenEndpointParams,\n        ...tokenEndpointParams\n      }\n    };\n  }\n  const newTokenSet = await client.refresh(oldTokenSet, extras);\n\n  // Update the session\n  const session = req[config.session.name];\n  Object.assign(session, {\n    id_token: newTokenSet.id_token,\n    access_token: newTokenSet.access_token,\n    // If no new refresh token assume the current refresh token is valid.\n    refresh_token: newTokenSet.refresh_token || oldTokenSet.refresh_token,\n    token_type: newTokenSet.token_type,\n    expires_at: newTokenSet.expires_at\n  });\n\n  // Delete the old token set\n  const cachedTokenSet = weakRef(session);\n  delete cachedTokenSet.value;\n  return this.accessToken;\n}\nfunction tokenSet() {\n  const contextCache = weakRef(this);\n  const session = contextCache.req[contextCache.config.session.name];\n  if (!session || !('id_token' in session)) {\n    return undefined;\n  }\n  const cachedTokenSet = weakRef(session);\n  if (!('value' in cachedTokenSet)) {\n    const {\n      id_token,\n      access_token,\n      refresh_token,\n      token_type,\n      expires_at\n    } = session;\n    cachedTokenSet.value = new TokenSet({\n      id_token,\n      access_token,\n      refresh_token,\n      token_type,\n      expires_at\n    });\n  }\n  return cachedTokenSet.value;\n}\nclass RequestContext {\n  constructor(config, req, res, next) {\n    Object.assign(weakRef(this), {\n      config,\n      req,\n      res,\n      next\n    });\n  }\n  isAuthenticated() {\n    return !!this.idTokenClaims;\n  }\n  get idToken() {\n    try {\n      return tokenSet.call(this).id_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n  get refreshToken() {\n    try {\n      return tokenSet.call(this).refresh_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n  get accessToken() {\n    try {\n      const {\n        access_token,\n        token_type,\n        expires_in\n      } = tokenSet.call(this);\n      if (!access_token || !token_type || typeof expires_in !== 'number') {\n        return undefined;\n      }\n      return {\n        access_token,\n        token_type,\n        expires_in,\n        isExpired: isExpired.bind(this),\n        refresh: refresh.bind(this)\n      };\n    } catch (err) {\n      return undefined;\n    }\n  }\n  get idTokenClaims() {\n    try {\n      const {\n        config: {\n          session\n        },\n        req\n      } = weakRef(this);\n\n      // The ID Token from Auth0's Refresh Grant doesn't contain a \"sid\"\n      // so we should check the backup sid we stored at login.\n      const {\n        sid\n      } = req[session.name];\n      return {\n        sid,\n        ...clone(tokenSet.call(this).claims())\n      };\n    } catch (err) {\n      return undefined;\n    }\n  }\n  get user() {\n    try {\n      const {\n        config: {\n          identityClaimFilter\n        }\n      } = weakRef(this);\n      const {\n        idTokenClaims\n      } = this;\n      const user = clone(idTokenClaims);\n      identityClaimFilter.forEach(claim => {\n        delete user[claim];\n      });\n      return user;\n    } catch (err) {\n      return undefined;\n    }\n  }\n  async fetchUserInfo() {\n    const {\n      config\n    } = weakRef(this);\n    const {\n      client\n    } = await getClient(config);\n    return client.userinfo(tokenSet.call(this));\n  }\n}\nclass ResponseContext {\n  constructor(config, req, res, next, transient) {\n    Object.assign(weakRef(this), {\n      config,\n      req,\n      res,\n      next,\n      transient\n    });\n  }\n  get errorOnRequiredAuth() {\n    return weakRef(this).config.errorOnRequiredAuth;\n  }\n  getRedirectUri() {\n    const {\n      config\n    } = weakRef(this);\n    if (config.routes.callback) {\n      return urlJoin(config.baseURL, config.routes.callback);\n    }\n  }\n  silentLogin(options = {}) {\n    return this.login({\n      ...options,\n      silent: true,\n      authorizationParams: {\n        ...options.authorizationParams,\n        prompt: 'none'\n      }\n    });\n  }\n  async login(options = {}) {\n    let {\n      config,\n      req,\n      res,\n      next,\n      transient\n    } = weakRef(this);\n    next = once(next);\n    try {\n      const {\n        client\n      } = await getClient(config);\n\n      // Set default returnTo value, allow passed-in options to override or use originalUrl on GET\n      let returnTo = config.baseURL;\n      if (options.returnTo) {\n        returnTo = options.returnTo;\n        debug('req.oidc.login() called with returnTo: %s', returnTo);\n      } else if (req.method === 'GET' && req.originalUrl) {\n        // Collapse any leading slashes to a single slash to prevent Open Redirects\n        returnTo = req.originalUrl.replace(/^\\/+/, '/');\n        debug('req.oidc.login() without returnTo, using: %s', returnTo);\n      }\n      options = {\n        authorizationParams: {},\n        returnTo,\n        ...options\n      };\n\n      // Ensure a redirect_uri, merge in configuration options, then passed-in options.\n      options.authorizationParams = {\n        redirect_uri: this.getRedirectUri(),\n        ...config.authorizationParams,\n        ...options.authorizationParams\n      };\n      const stateValue = await config.getLoginState(req, options);\n      if (typeof stateValue !== 'object') {\n        next(new Error('Custom state value must be an object.'));\n      }\n      if (options.silent) {\n        stateValue.attemptingSilentLogin = true;\n      }\n      const validResponseTypes = ['id_token', 'code id_token', 'code'];\n      assert(validResponseTypes.includes(options.authorizationParams.response_type), `response_type should be one of ${validResponseTypes.join(', ')}`);\n      assert(/\\bopenid\\b/.test(options.authorizationParams.scope), 'scope should contain \"openid\"');\n      const authVerification = {\n        nonce: transient.generateNonce(),\n        state: encodeState(stateValue),\n        ...(options.authorizationParams.max_age ? {\n          max_age: options.authorizationParams.max_age\n        } : undefined)\n      };\n      let authParams = {\n        ...options.authorizationParams,\n        ...authVerification\n      };\n      const usePKCE = options.authorizationParams.response_type.includes('code');\n      if (usePKCE) {\n        debug('response_type includes code, the authorization request will use PKCE');\n        authVerification.code_verifier = transient.generateCodeVerifier();\n        authParams.code_challenge_method = 'S256';\n        authParams.code_challenge = transient.calculateCodeChallenge(authVerification.code_verifier);\n      }\n      if (config.pushedAuthorizationRequests) {\n        const {\n          request_uri\n        } = await client.pushedAuthorizationRequest(authParams);\n        authParams = {\n          request_uri\n        };\n      }\n      transient.store(config.transactionCookie.name, req, res, {\n        sameSite: options.authorizationParams.response_mode === 'form_post' ? 'None' : config.transactionCookie.sameSite,\n        value: JSON.stringify(authVerification)\n      });\n      const authorizationUrl = client.authorizationUrl(authParams);\n      debug('redirecting to %s', authorizationUrl);\n      res.redirect(authorizationUrl);\n    } catch (err) {\n      next(err);\n    }\n  }\n  async logout(params = {}) {\n    let {\n      config,\n      req,\n      res,\n      next\n    } = weakRef(this);\n    next = once(next);\n    let returnURL = params.returnTo || config.routes.postLogoutRedirect;\n    debug('req.oidc.logout() with return url: %s', returnURL);\n    try {\n      const {\n        client\n      } = await getClient(config);\n      if (url.parse(returnURL).host === null) {\n        returnURL = urlJoin(config.baseURL, returnURL);\n      }\n      cancelSilentLogin(req, res);\n      if (!req.oidc.isAuthenticated()) {\n        debug('end-user already logged out, redirecting to %s', returnURL);\n        return res.redirect(returnURL);\n      }\n      const {\n        idToken: id_token_hint\n      } = req.oidc;\n      req[config.session.name] = undefined;\n      if (!config.idpLogout) {\n        debug('performing a local only logout, redirecting to %s', returnURL);\n        return res.redirect(returnURL);\n      }\n      returnURL = client.endSessionUrl({\n        ...config.logoutParams,\n        id_token_hint,\n        post_logout_redirect_uri: returnURL,\n        ...params.logoutParams\n      });\n    } catch (err) {\n      return next(err);\n    }\n    debug('logging out of identity provider, redirecting to %s', returnURL);\n    res.redirect(returnURL);\n  }\n  async callback(options = {}) {\n    let {\n      config,\n      req,\n      res,\n      transient,\n      next\n    } = weakRef(this);\n    next = once(next);\n    try {\n      const {\n        client\n      } = await getClient(config);\n      const redirectUri = options.redirectUri || this.getRedirectUri();\n      let tokenSet;\n      try {\n        const callbackParams = client.callbackParams(req);\n        const authVerification = transient.getOnce(config.transactionCookie.name, req, res);\n        const checks = authVerification ? JSON.parse(authVerification) : {};\n        req.openidState = decodeState(checks.state);\n        tokenSet = await client.callback(redirectUri, callbackParams, checks, {\n          exchangeBody: {\n            ...(config && config.tokenEndpointParams),\n            ...options.tokenEndpointParams\n          }\n        });\n      } catch (error) {\n        throw createError(400, error.message, {\n          error: error.error,\n          error_description: error.error_description\n        });\n      }\n      let session = Object.assign({}, tokenSet); // Remove non-enumerable methods from the TokenSet\n      const claims = tokenSet.claims();\n      // Must store the `sid` separately as the ID Token gets overridden by\n      // ID Token from the Refresh Grant which may not contain a sid (In Auth0 currently).\n      session.sid = claims.sid;\n      if (config.afterCallback) {\n        session = await config.afterCallback(req, res, session, req.openidState);\n      }\n      if (req.oidc.isAuthenticated()) {\n        if (req.oidc.user.sub === claims.sub) {\n          // If it's the same user logging in again, just update the existing session.\n          Object.assign(req[config.session.name], session);\n        } else {\n          // If it's a different user, replace the session to remove any custom user\n          // properties on the session\n          replaceSession(req, session, config);\n          // And regenerate the session id so the previous user wont know the new user's session id\n          await regenerateSessionStoreId(req, config);\n        }\n      } else {\n        // If a new user is replacing an anonymous session, update the existing session to keep\n        // any anonymous session state (eg. checkout basket)\n        Object.assign(req[config.session.name], session);\n        // But update the session store id so a previous anonymous user wont know the new user's session id\n        await regenerateSessionStoreId(req, config);\n      }\n      resumeSilentLogin(req, res);\n      if (req.oidc.isAuthenticated() && config.backchannelLogout && config.backchannelLogout.onLogin !== false) {\n        await (config.backchannelLogout.onLogin || onLogin)(req, config);\n      }\n    } catch (err) {\n      if (!req.openidState || !req.openidState.attemptingSilentLogin) {\n        return next(err);\n      }\n    }\n    res.redirect(req.openidState.returnTo || config.baseURL);\n  }\n  async backchannelLogout() {\n    let {\n      config,\n      req,\n      res\n    } = weakRef(this);\n    res.setHeader('cache-control', 'no-store');\n    const logoutToken = req.body.logout_token;\n    if (!logoutToken) {\n      res.status(400).json({\n        error: 'invalid_request',\n        error_description: 'Missing logout_token'\n      });\n      return;\n    }\n    const onToken = config.backchannelLogout && config.backchannelLogout.onLogoutToken || onLogoutToken;\n    let token;\n    try {\n      const {\n        issuer\n      } = await getClient(config);\n      const keyInput = await issuer.keystore();\n      token = await JWT.LogoutToken.verify(logoutToken, keyInput, {\n        issuer: issuer.issuer,\n        audience: config.clientID,\n        algorithms: [config.idTokenSigningAlg]\n      });\n    } catch (e) {\n      res.status(400).json({\n        error: 'invalid_request',\n        error_description: e.message\n      });\n      return;\n    }\n    try {\n      await onToken(token, config);\n    } catch (e) {\n      debug('req.oidc.backchannelLogout() failed with: %s', e.message);\n      res.status(400).json({\n        error: 'application_error',\n        error_description: `The application failed to invalidate the session.`\n      });\n      return;\n    }\n    res.status(204).send();\n  }\n}\nmodule.exports = {\n  RequestContext,\n  ResponseContext\n};","map":{"version":3,"names":["url","require","urlJoin","JWT","TokenSet","clone","strict","assert","createError","debug","once","get","getClient","encodeState","decodeState","onLogin","onLogoutToken","cancelSilentLogin","resumeSilentLogin","weakRef","regenerateSessionStoreId","replaceSession","isExpired","tokenSet","call","expired","refresh","tokenEndpointParams","config","req","client","oldTokenSet","extras","exchangeBody","newTokenSet","session","name","Object","assign","id_token","access_token","refresh_token","token_type","expires_at","cachedTokenSet","value","accessToken","contextCache","undefined","RequestContext","constructor","res","next","isAuthenticated","idTokenClaims","idToken","err","refreshToken","expires_in","bind","sid","claims","user","identityClaimFilter","forEach","claim","fetchUserInfo","userinfo","ResponseContext","transient","errorOnRequiredAuth","getRedirectUri","routes","callback","baseURL","silentLogin","options","login","silent","authorizationParams","prompt","returnTo","method","originalUrl","replace","redirect_uri","stateValue","getLoginState","Error","attemptingSilentLogin","validResponseTypes","includes","response_type","join","test","scope","authVerification","nonce","generateNonce","state","max_age","authParams","usePKCE","code_verifier","generateCodeVerifier","code_challenge_method","code_challenge","calculateCodeChallenge","pushedAuthorizationRequests","request_uri","pushedAuthorizationRequest","store","transactionCookie","sameSite","response_mode","JSON","stringify","authorizationUrl","redirect","logout","params","returnURL","postLogoutRedirect","parse","host","oidc","id_token_hint","idpLogout","endSessionUrl","logoutParams","post_logout_redirect_uri","redirectUri","callbackParams","getOnce","checks","openidState","error","message","error_description","afterCallback","sub","backchannelLogout","setHeader","logoutToken","body","logout_token","status","json","onToken","token","issuer","keyInput","keystore","LogoutToken","verify","audience","clientID","algorithms","idTokenSigningAlg","e","send","module","exports"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/express-openid-connect/lib/context.js"],"sourcesContent":["const url = require('url');\nconst urlJoin = require('url-join');\nconst { JWT } = require('jose');\nconst { TokenSet } = require('openid-client');\nconst clone = require('clone');\n\nconst { strict: assert } = require('assert');\nconst createError = require('http-errors');\n\nconst debug = require('./debug')('context');\nconst { once } = require('./once');\nconst { get: getClient } = require('./client');\nconst { encodeState, decodeState } = require('../lib/hooks/getLoginState');\nconst onLogin = require('./hooks/backchannelLogout/onLogIn');\nconst onLogoutToken = require('./hooks/backchannelLogout/onLogoutToken');\nconst {\n  cancelSilentLogin,\n  resumeSilentLogin,\n} = require('../middleware/attemptSilentLogin');\nconst weakRef = require('./weakCache');\nconst {\n  regenerateSessionStoreId,\n  replaceSession,\n} = require('../lib/appSession');\n\nfunction isExpired() {\n  return tokenSet.call(this).expired();\n}\n\nasync function refresh({ tokenEndpointParams } = {}) {\n  let { config, req } = weakRef(this);\n  const { client } = await getClient(config);\n  const oldTokenSet = tokenSet.call(this);\n\n  let extras;\n  if (config.tokenEndpointParams || tokenEndpointParams) {\n    extras = {\n      exchangeBody: { ...config.tokenEndpointParams, ...tokenEndpointParams },\n    };\n  }\n\n  const newTokenSet = await client.refresh(oldTokenSet, extras);\n\n  // Update the session\n  const session = req[config.session.name];\n  Object.assign(session, {\n    id_token: newTokenSet.id_token,\n    access_token: newTokenSet.access_token,\n    // If no new refresh token assume the current refresh token is valid.\n    refresh_token: newTokenSet.refresh_token || oldTokenSet.refresh_token,\n    token_type: newTokenSet.token_type,\n    expires_at: newTokenSet.expires_at,\n  });\n\n  // Delete the old token set\n  const cachedTokenSet = weakRef(session);\n  delete cachedTokenSet.value;\n\n  return this.accessToken;\n}\n\nfunction tokenSet() {\n  const contextCache = weakRef(this);\n  const session = contextCache.req[contextCache.config.session.name];\n\n  if (!session || !('id_token' in session)) {\n    return undefined;\n  }\n\n  const cachedTokenSet = weakRef(session);\n\n  if (!('value' in cachedTokenSet)) {\n    const { id_token, access_token, refresh_token, token_type, expires_at } =\n      session;\n    cachedTokenSet.value = new TokenSet({\n      id_token,\n      access_token,\n      refresh_token,\n      token_type,\n      expires_at,\n    });\n  }\n\n  return cachedTokenSet.value;\n}\n\nclass RequestContext {\n  constructor(config, req, res, next) {\n    Object.assign(weakRef(this), { config, req, res, next });\n  }\n\n  isAuthenticated() {\n    return !!this.idTokenClaims;\n  }\n\n  get idToken() {\n    try {\n      return tokenSet.call(this).id_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get refreshToken() {\n    try {\n      return tokenSet.call(this).refresh_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get accessToken() {\n    try {\n      const { access_token, token_type, expires_in } = tokenSet.call(this);\n\n      if (!access_token || !token_type || typeof expires_in !== 'number') {\n        return undefined;\n      }\n\n      return {\n        access_token,\n        token_type,\n        expires_in,\n        isExpired: isExpired.bind(this),\n        refresh: refresh.bind(this),\n      };\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get idTokenClaims() {\n    try {\n      const {\n        config: { session },\n        req,\n      } = weakRef(this);\n\n      // The ID Token from Auth0's Refresh Grant doesn't contain a \"sid\"\n      // so we should check the backup sid we stored at login.\n      const { sid } = req[session.name];\n      return { sid, ...clone(tokenSet.call(this).claims()) };\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get user() {\n    try {\n      const {\n        config: { identityClaimFilter },\n      } = weakRef(this);\n      const { idTokenClaims } = this;\n      const user = clone(idTokenClaims);\n      identityClaimFilter.forEach((claim) => {\n        delete user[claim];\n      });\n      return user;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  async fetchUserInfo() {\n    const { config } = weakRef(this);\n\n    const { client } = await getClient(config);\n    return client.userinfo(tokenSet.call(this));\n  }\n}\n\nclass ResponseContext {\n  constructor(config, req, res, next, transient) {\n    Object.assign(weakRef(this), { config, req, res, next, transient });\n  }\n\n  get errorOnRequiredAuth() {\n    return weakRef(this).config.errorOnRequiredAuth;\n  }\n\n  getRedirectUri() {\n    const { config } = weakRef(this);\n    if (config.routes.callback) {\n      return urlJoin(config.baseURL, config.routes.callback);\n    }\n  }\n\n  silentLogin(options = {}) {\n    return this.login({\n      ...options,\n      silent: true,\n      authorizationParams: { ...options.authorizationParams, prompt: 'none' },\n    });\n  }\n\n  async login(options = {}) {\n    let { config, req, res, next, transient } = weakRef(this);\n    next = once(next);\n    try {\n      const { client } = await getClient(config);\n\n      // Set default returnTo value, allow passed-in options to override or use originalUrl on GET\n      let returnTo = config.baseURL;\n      if (options.returnTo) {\n        returnTo = options.returnTo;\n        debug('req.oidc.login() called with returnTo: %s', returnTo);\n      } else if (req.method === 'GET' && req.originalUrl) {\n        // Collapse any leading slashes to a single slash to prevent Open Redirects\n        returnTo = req.originalUrl.replace(/^\\/+/, '/');\n        debug('req.oidc.login() without returnTo, using: %s', returnTo);\n      }\n\n      options = {\n        authorizationParams: {},\n        returnTo,\n        ...options,\n      };\n\n      // Ensure a redirect_uri, merge in configuration options, then passed-in options.\n      options.authorizationParams = {\n        redirect_uri: this.getRedirectUri(),\n        ...config.authorizationParams,\n        ...options.authorizationParams,\n      };\n\n      const stateValue = await config.getLoginState(req, options);\n      if (typeof stateValue !== 'object') {\n        next(new Error('Custom state value must be an object.'));\n      }\n\n      if (options.silent) {\n        stateValue.attemptingSilentLogin = true;\n      }\n\n      const validResponseTypes = ['id_token', 'code id_token', 'code'];\n      assert(\n        validResponseTypes.includes(options.authorizationParams.response_type),\n        `response_type should be one of ${validResponseTypes.join(', ')}`\n      );\n      assert(\n        /\\bopenid\\b/.test(options.authorizationParams.scope),\n        'scope should contain \"openid\"'\n      );\n\n      const authVerification = {\n        nonce: transient.generateNonce(),\n        state: encodeState(stateValue),\n        ...(options.authorizationParams.max_age\n          ? {\n              max_age: options.authorizationParams.max_age,\n            }\n          : undefined),\n      };\n\n      let authParams = {\n        ...options.authorizationParams,\n        ...authVerification,\n      };\n\n      const usePKCE =\n        options.authorizationParams.response_type.includes('code');\n      if (usePKCE) {\n        debug(\n          'response_type includes code, the authorization request will use PKCE'\n        );\n        authVerification.code_verifier = transient.generateCodeVerifier();\n\n        authParams.code_challenge_method = 'S256';\n        authParams.code_challenge = transient.calculateCodeChallenge(\n          authVerification.code_verifier\n        );\n      }\n\n      if (config.pushedAuthorizationRequests) {\n        const { request_uri } = await client.pushedAuthorizationRequest(\n          authParams\n        );\n        authParams = { request_uri };\n      }\n\n      transient.store(config.transactionCookie.name, req, res, {\n        sameSite:\n          options.authorizationParams.response_mode === 'form_post'\n            ? 'None'\n            : config.transactionCookie.sameSite,\n        value: JSON.stringify(authVerification),\n      });\n\n      const authorizationUrl = client.authorizationUrl(authParams);\n      debug('redirecting to %s', authorizationUrl);\n      res.redirect(authorizationUrl);\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async logout(params = {}) {\n    let { config, req, res, next } = weakRef(this);\n    next = once(next);\n    let returnURL = params.returnTo || config.routes.postLogoutRedirect;\n    debug('req.oidc.logout() with return url: %s', returnURL);\n\n    try {\n      const { client } = await getClient(config);\n\n      if (url.parse(returnURL).host === null) {\n        returnURL = urlJoin(config.baseURL, returnURL);\n      }\n\n      cancelSilentLogin(req, res);\n\n      if (!req.oidc.isAuthenticated()) {\n        debug('end-user already logged out, redirecting to %s', returnURL);\n        return res.redirect(returnURL);\n      }\n\n      const { idToken: id_token_hint } = req.oidc;\n      req[config.session.name] = undefined;\n\n      if (!config.idpLogout) {\n        debug('performing a local only logout, redirecting to %s', returnURL);\n        return res.redirect(returnURL);\n      }\n\n      returnURL = client.endSessionUrl({\n        ...config.logoutParams,\n        id_token_hint,\n        post_logout_redirect_uri: returnURL,\n        ...params.logoutParams,\n      });\n    } catch (err) {\n      return next(err);\n    }\n\n    debug('logging out of identity provider, redirecting to %s', returnURL);\n    res.redirect(returnURL);\n  }\n\n  async callback(options = {}) {\n    let { config, req, res, transient, next } = weakRef(this);\n    next = once(next);\n    try {\n      const { client } = await getClient(config);\n      const redirectUri = options.redirectUri || this.getRedirectUri();\n\n      let tokenSet;\n      try {\n        const callbackParams = client.callbackParams(req);\n        const authVerification = transient.getOnce(\n          config.transactionCookie.name,\n          req,\n          res\n        );\n\n        const checks = authVerification ? JSON.parse(authVerification) : {};\n\n        req.openidState = decodeState(checks.state);\n\n        tokenSet = await client.callback(redirectUri, callbackParams, checks, {\n          exchangeBody: {\n            ...(config && config.tokenEndpointParams),\n            ...options.tokenEndpointParams,\n          },\n        });\n      } catch (error) {\n        throw createError(400, error.message, {\n          error: error.error,\n          error_description: error.error_description,\n        });\n      }\n\n      let session = Object.assign({}, tokenSet); // Remove non-enumerable methods from the TokenSet\n      const claims = tokenSet.claims();\n      // Must store the `sid` separately as the ID Token gets overridden by\n      // ID Token from the Refresh Grant which may not contain a sid (In Auth0 currently).\n      session.sid = claims.sid;\n\n      if (config.afterCallback) {\n        session = await config.afterCallback(\n          req,\n          res,\n          session,\n          req.openidState\n        );\n      }\n\n      if (req.oidc.isAuthenticated()) {\n        if (req.oidc.user.sub === claims.sub) {\n          // If it's the same user logging in again, just update the existing session.\n          Object.assign(req[config.session.name], session);\n        } else {\n          // If it's a different user, replace the session to remove any custom user\n          // properties on the session\n          replaceSession(req, session, config);\n          // And regenerate the session id so the previous user wont know the new user's session id\n          await regenerateSessionStoreId(req, config);\n        }\n      } else {\n        // If a new user is replacing an anonymous session, update the existing session to keep\n        // any anonymous session state (eg. checkout basket)\n        Object.assign(req[config.session.name], session);\n        // But update the session store id so a previous anonymous user wont know the new user's session id\n        await regenerateSessionStoreId(req, config);\n      }\n      resumeSilentLogin(req, res);\n\n      if (\n        req.oidc.isAuthenticated() &&\n        config.backchannelLogout &&\n        config.backchannelLogout.onLogin !== false\n      ) {\n        await (config.backchannelLogout.onLogin || onLogin)(req, config);\n      }\n    } catch (err) {\n      if (!req.openidState || !req.openidState.attemptingSilentLogin) {\n        return next(err);\n      }\n    }\n    res.redirect(req.openidState.returnTo || config.baseURL);\n  }\n\n  async backchannelLogout() {\n    let { config, req, res } = weakRef(this);\n    res.setHeader('cache-control', 'no-store');\n    const logoutToken = req.body.logout_token;\n    if (!logoutToken) {\n      res.status(400).json({\n        error: 'invalid_request',\n        error_description: 'Missing logout_token',\n      });\n      return;\n    }\n    const onToken =\n      (config.backchannelLogout && config.backchannelLogout.onLogoutToken) ||\n      onLogoutToken;\n    let token;\n    try {\n      const { issuer } = await getClient(config);\n      const keyInput = await issuer.keystore();\n\n      token = await JWT.LogoutToken.verify(logoutToken, keyInput, {\n        issuer: issuer.issuer,\n        audience: config.clientID,\n        algorithms: [config.idTokenSigningAlg],\n      });\n    } catch (e) {\n      res.status(400).json({\n        error: 'invalid_request',\n        error_description: e.message,\n      });\n      return;\n    }\n    try {\n      await onToken(token, config);\n    } catch (e) {\n      debug('req.oidc.backchannelLogout() failed with: %s', e.message);\n      res.status(400).json({\n        error: 'application_error',\n        error_description: `The application failed to invalidate the session.`,\n      });\n      return;\n    }\n    res.status(204).send();\n  }\n}\n\nmodule.exports = { RequestContext, ResponseContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}