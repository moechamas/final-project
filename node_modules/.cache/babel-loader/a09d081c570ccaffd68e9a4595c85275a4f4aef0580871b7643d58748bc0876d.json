{"ast":null,"code":"const {\n  strict: assert,\n  AssertionError\n} = require('assert');\nconst {\n  JWE,\n  errors: {\n    JOSEError\n  }\n} = require('jose');\nconst {\n  promisify\n} = require('util');\nconst cookie = require('cookie');\nconst onHeaders = require('on-headers');\nconst COOKIES = require('./cookies');\nconst {\n  getKeyStore,\n  verifyCookie,\n  signCookie\n} = require('./crypto');\nconst debug = require('./debug')('appSession');\nconst epoch = () => Date.now() / 1000 | 0;\nconst MAX_COOKIE_SIZE = 4096;\nconst REASSIGN = Symbol('reassign');\nconst REGENERATED_SESSION_ID = Symbol('regenerated_session_id');\nfunction attachSessionObject(req, sessionName, value) {\n  Object.defineProperty(req, sessionName, {\n    enumerable: true,\n    get() {\n      return value;\n    },\n    set(arg) {\n      if (arg === null || arg === undefined || arg[REASSIGN]) {\n        value = arg;\n      } else {\n        throw new TypeError('session object cannot be reassigned');\n      }\n      return undefined;\n    }\n  });\n}\nasync function regenerateSessionStoreId(req, config) {\n  if (config.session.store) {\n    req[REGENERATED_SESSION_ID] = await config.session.genid(req);\n  }\n}\nfunction replaceSession(req, session, config) {\n  session[REASSIGN] = true;\n  req[config.session.name] = session;\n}\nmodule.exports = config => {\n  const alg = 'dir';\n  const enc = 'A256GCM';\n  const sessionName = config.session.name;\n  const cookieConfig = config.session.cookie;\n  const {\n    genid: generateId,\n    absoluteDuration,\n    rolling: rollingEnabled,\n    rollingDuration,\n    signSessionStoreCookie,\n    requireSignedSessionStoreCookie\n  } = config.session;\n  const {\n    transient: emptyTransient,\n    ...emptyCookieOptions\n  } = cookieConfig;\n  emptyCookieOptions.expires = emptyTransient ? 0 : new Date();\n  emptyCookieOptions.path = emptyCookieOptions.path || '/';\n  const emptyCookie = cookie.serialize(`${sessionName}.0`, '', emptyCookieOptions);\n  const cookieChunkSize = MAX_COOKIE_SIZE - emptyCookie.length;\n  let [current, keystore] = getKeyStore(config.secret, true);\n  if (keystore.size === 1) {\n    keystore = current;\n  }\n  function encrypt(payload, headers) {\n    return JWE.encrypt(payload, current, {\n      alg,\n      enc,\n      ...headers\n    });\n  }\n  function decrypt(jwe) {\n    return JWE.decrypt(jwe, keystore, {\n      complete: true,\n      contentEncryptionAlgorithms: [enc],\n      keyManagementAlgorithms: [alg]\n    });\n  }\n  function calculateExp(iat, uat) {\n    if (!rollingEnabled) {\n      return iat + absoluteDuration;\n    }\n    return Math.min(...[uat + rollingDuration, iat + absoluteDuration].filter(Boolean));\n  }\n  function setCookie(req, res, {\n    uat = epoch(),\n    iat = uat,\n    exp = calculateExp(iat, uat)\n  }) {\n    const cookies = req[COOKIES];\n    const {\n      transient: cookieTransient,\n      ...cookieOptions\n    } = cookieConfig;\n    cookieOptions.expires = cookieTransient ? 0 : new Date(exp * 1000);\n\n    // session was deleted or is empty, this matches all session cookies (chunked or unchunked)\n    // and clears them, essentially cleaning up what we've set in the past that is now trash\n    if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n      debug('session was deleted or is empty, clearing all matching session cookies');\n      for (const cookieName of Object.keys(cookies)) {\n        if (cookieName.match(`^${sessionName}(?:\\\\.\\\\d)?$`)) {\n          clearCookie(cookieName, res);\n        }\n      }\n    } else {\n      debug('found session, creating signed session cookie(s) with name %o(.i)', sessionName);\n      const value = encrypt(JSON.stringify(req[sessionName]), {\n        iat,\n        uat,\n        exp\n      });\n      const chunkCount = Math.ceil(value.length / cookieChunkSize);\n      if (chunkCount > 1) {\n        debug('cookie size greater than %d, chunking', cookieChunkSize);\n        for (let i = 0; i < chunkCount; i++) {\n          const chunkValue = value.slice(i * cookieChunkSize, (i + 1) * cookieChunkSize);\n          const chunkCookieName = `${sessionName}.${i}`;\n          res.cookie(chunkCookieName, chunkValue, cookieOptions);\n        }\n        if (sessionName in cookies) {\n          debug('replacing non chunked cookie with chunked cookies');\n          clearCookie(sessionName, res);\n        }\n      } else {\n        res.cookie(sessionName, value, cookieOptions);\n        for (const cookieName of Object.keys(cookies)) {\n          debug('replacing chunked cookies with non chunked cookies');\n          if (cookieName.match(`^${sessionName}\\\\.\\\\d$`)) {\n            clearCookie(cookieName, res);\n          }\n        }\n      }\n    }\n  }\n  function clearCookie(name, res) {\n    const {\n      domain,\n      path,\n      sameSite,\n      secure\n    } = cookieConfig;\n    res.clearCookie(name, {\n      domain,\n      path,\n      sameSite,\n      secure\n    });\n  }\n  class CookieStore {\n    async get(idOrVal) {\n      const {\n        protected: header,\n        cleartext\n      } = decrypt(idOrVal);\n      return {\n        header,\n        data: JSON.parse(cleartext)\n      };\n    }\n    getCookie(req) {\n      return req[COOKIES][sessionName];\n    }\n    setCookie(req, res, iat) {\n      setCookie(req, res, iat);\n    }\n  }\n  class CustomStore {\n    constructor(store) {\n      this._get = promisify(store.get).bind(store);\n      this._set = promisify(store.set).bind(store);\n      this._destroy = promisify(store.destroy).bind(store);\n      let [current, keystore] = getKeyStore(config.secret);\n      if (keystore.size === 1) {\n        keystore = current;\n      }\n      this._keyStore = keystore;\n      this._current = current;\n    }\n    async get(id) {\n      return this._get(id);\n    }\n    async set(id, req, res, {\n      uat = epoch(),\n      iat = uat,\n      exp = calculateExp(iat, uat)\n    }) {\n      const hasPrevSession = !!req[COOKIES][sessionName];\n      const replacingPrevSession = !!req[REGENERATED_SESSION_ID];\n      const hasCurrentSession = req[sessionName] && Object.keys(req[sessionName]).length;\n      if (hasPrevSession && (replacingPrevSession || !hasCurrentSession)) {\n        await this._destroy(id);\n      }\n      if (hasCurrentSession) {\n        await this._set(req[REGENERATED_SESSION_ID] || id, {\n          header: {\n            iat,\n            uat,\n            exp\n          },\n          data: req[sessionName],\n          cookie: {\n            expires: exp * 1000,\n            maxAge: exp * 1000 - Date.now()\n          }\n        });\n      }\n    }\n    getCookie(req) {\n      if (signSessionStoreCookie) {\n        const verified = verifyCookie(sessionName, req[COOKIES][sessionName], this._keyStore);\n        if (requireSignedSessionStoreCookie) {\n          return verified;\n        }\n        return verified || req[COOKIES][sessionName];\n      }\n      return req[COOKIES][sessionName];\n    }\n    setCookie(id, req, res, {\n      uat = epoch(),\n      iat = uat,\n      exp = calculateExp(iat, uat)\n    }) {\n      if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n        if (req[COOKIES][sessionName]) {\n          clearCookie(sessionName, res);\n        }\n      } else {\n        const cookieOptions = {\n          ...cookieConfig,\n          expires: cookieConfig.transient ? 0 : new Date(exp * 1000)\n        };\n        delete cookieOptions.transient;\n        let value = id;\n        if (signSessionStoreCookie) {\n          value = signCookie(sessionName, id, this._current);\n        }\n        res.cookie(sessionName, value, cookieOptions);\n      }\n    }\n  }\n  const isCustomStore = !!config.session.store;\n  const store = isCustomStore ? new CustomStore(config.session.store) : new CookieStore();\n  return async (req, res, next) => {\n    if (req.hasOwnProperty(sessionName)) {\n      debug('request object (req) already has %o property, this is indicative of a middleware setup problem', sessionName);\n      return next(new Error(`req[${sessionName}] is already set, did you run this middleware twice?`));\n    }\n    req[COOKIES] = cookie.parse(req.get('cookie') || '');\n    let iat;\n    let uat;\n    let exp;\n    let existingSessionValue;\n    try {\n      if (req[COOKIES].hasOwnProperty(sessionName)) {\n        // get JWE from unchunked session cookie\n        debug('reading session from %s cookie', sessionName);\n        existingSessionValue = store.getCookie(req);\n      } else if (req[COOKIES].hasOwnProperty(`${sessionName}.0`)) {\n        // get JWE from chunked session cookie\n        // iterate all cookie names\n        // match and filter for the ones that match sessionName.<number>\n        // sort by chunk index\n        // concat\n        existingSessionValue = Object.entries(req[COOKIES]).map(([cookie, value]) => {\n          const match = cookie.match(`^${sessionName}\\\\.(\\\\d+)$`);\n          if (match) {\n            return [match[1], value];\n          }\n        }).filter(Boolean).sort(([a], [b]) => {\n          return parseInt(a, 10) - parseInt(b, 10);\n        }).map(([i, chunk]) => {\n          debug('reading session chunk from %s.%d cookie', sessionName, i);\n          return chunk;\n        }).join('');\n      }\n      if (existingSessionValue) {\n        const {\n          header,\n          data\n        } = await store.get(existingSessionValue);\n        ({\n          iat,\n          uat,\n          exp\n        } = header);\n\n        // check that the existing session isn't expired based on options when it was established\n        assert(exp > epoch(), 'it is expired based on options when it was established');\n\n        // check that the existing session isn't expired based on current rollingDuration rules\n        if (rollingDuration) {\n          assert(uat + rollingDuration > epoch(), 'it is expired based on current rollingDuration rules');\n        }\n\n        // check that the existing session isn't expired based on current absoluteDuration rules\n        if (absoluteDuration) {\n          assert(iat + absoluteDuration > epoch(), 'it is expired based on current absoluteDuration rules');\n        }\n        attachSessionObject(req, sessionName, data);\n      }\n    } catch (err) {\n      if (err instanceof AssertionError) {\n        debug('existing session was rejected because', err.message);\n      } else if (err instanceof JOSEError) {\n        debug('existing session was rejected because it could not be decrypted', err);\n      } else {\n        debug('unexpected error handling session', err);\n      }\n    }\n    if (!req.hasOwnProperty(sessionName) || !req[sessionName]) {\n      attachSessionObject(req, sessionName, {});\n    }\n    if (isCustomStore) {\n      const id = existingSessionValue || (await generateId(req));\n      onHeaders(res, () => store.setCookie(req[REGENERATED_SESSION_ID] || id, req, res, {\n        iat\n      }));\n      const {\n        end: origEnd\n      } = res;\n      res.end = async function resEnd(...args) {\n        try {\n          await store.set(id, req, res, {\n            iat\n          });\n          origEnd.call(res, ...args);\n        } catch (e) {\n          // need to restore the original `end` so that it gets\n          // called after `next(e)` calls the express error handling mw\n          res.end = origEnd;\n          process.nextTick(() => next(e));\n        }\n      };\n    } else {\n      onHeaders(res, () => store.setCookie(req, res, {\n        iat\n      }));\n    }\n    return next();\n  };\n};\nmodule.exports.regenerateSessionStoreId = regenerateSessionStoreId;\nmodule.exports.replaceSession = replaceSession;","map":{"version":3,"names":["strict","assert","AssertionError","require","JWE","errors","JOSEError","promisify","cookie","onHeaders","COOKIES","getKeyStore","verifyCookie","signCookie","debug","epoch","Date","now","MAX_COOKIE_SIZE","REASSIGN","Symbol","REGENERATED_SESSION_ID","attachSessionObject","req","sessionName","value","Object","defineProperty","enumerable","get","set","arg","undefined","TypeError","regenerateSessionStoreId","config","session","store","genid","replaceSession","name","module","exports","alg","enc","cookieConfig","generateId","absoluteDuration","rolling","rollingEnabled","rollingDuration","signSessionStoreCookie","requireSignedSessionStoreCookie","transient","emptyTransient","emptyCookieOptions","expires","path","emptyCookie","serialize","cookieChunkSize","length","current","keystore","secret","size","encrypt","payload","headers","decrypt","jwe","complete","contentEncryptionAlgorithms","keyManagementAlgorithms","calculateExp","iat","uat","Math","min","filter","Boolean","setCookie","res","exp","cookies","cookieTransient","cookieOptions","keys","cookieName","match","clearCookie","JSON","stringify","chunkCount","ceil","i","chunkValue","slice","chunkCookieName","domain","sameSite","secure","CookieStore","idOrVal","protected","header","cleartext","data","parse","getCookie","CustomStore","constructor","_get","bind","_set","_destroy","destroy","_keyStore","_current","id","hasPrevSession","replacingPrevSession","hasCurrentSession","maxAge","verified","isCustomStore","next","hasOwnProperty","Error","existingSessionValue","entries","map","sort","a","b","parseInt","chunk","join","err","message","end","origEnd","resEnd","args","call","e","process","nextTick"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/express-openid-connect/lib/appSession.js"],"sourcesContent":["const { strict: assert, AssertionError } = require('assert');\nconst {\n  JWE,\n  errors: { JOSEError },\n} = require('jose');\nconst { promisify } = require('util');\nconst cookie = require('cookie');\nconst onHeaders = require('on-headers');\nconst COOKIES = require('./cookies');\nconst { getKeyStore, verifyCookie, signCookie } = require('./crypto');\nconst debug = require('./debug')('appSession');\n\nconst epoch = () => (Date.now() / 1000) | 0;\nconst MAX_COOKIE_SIZE = 4096;\n\nconst REASSIGN = Symbol('reassign');\nconst REGENERATED_SESSION_ID = Symbol('regenerated_session_id');\n\nfunction attachSessionObject(req, sessionName, value) {\n  Object.defineProperty(req, sessionName, {\n    enumerable: true,\n    get() {\n      return value;\n    },\n    set(arg) {\n      if (arg === null || arg === undefined || arg[REASSIGN]) {\n        value = arg;\n      } else {\n        throw new TypeError('session object cannot be reassigned');\n      }\n      return undefined;\n    },\n  });\n}\n\nasync function regenerateSessionStoreId(req, config) {\n  if (config.session.store) {\n    req[REGENERATED_SESSION_ID] = await config.session.genid(req);\n  }\n}\n\nfunction replaceSession(req, session, config) {\n  session[REASSIGN] = true;\n  req[config.session.name] = session;\n}\n\nmodule.exports = (config) => {\n  const alg = 'dir';\n  const enc = 'A256GCM';\n  const sessionName = config.session.name;\n  const cookieConfig = config.session.cookie;\n  const {\n    genid: generateId,\n    absoluteDuration,\n    rolling: rollingEnabled,\n    rollingDuration,\n    signSessionStoreCookie,\n    requireSignedSessionStoreCookie,\n  } = config.session;\n\n  const { transient: emptyTransient, ...emptyCookieOptions } = cookieConfig;\n  emptyCookieOptions.expires = emptyTransient ? 0 : new Date();\n  emptyCookieOptions.path = emptyCookieOptions.path || '/';\n\n  const emptyCookie = cookie.serialize(\n    `${sessionName}.0`,\n    '',\n    emptyCookieOptions\n  );\n  const cookieChunkSize = MAX_COOKIE_SIZE - emptyCookie.length;\n\n  let [current, keystore] = getKeyStore(config.secret, true);\n  if (keystore.size === 1) {\n    keystore = current;\n  }\n\n  function encrypt(payload, headers) {\n    return JWE.encrypt(payload, current, { alg, enc, ...headers });\n  }\n\n  function decrypt(jwe) {\n    return JWE.decrypt(jwe, keystore, {\n      complete: true,\n      contentEncryptionAlgorithms: [enc],\n      keyManagementAlgorithms: [alg],\n    });\n  }\n\n  function calculateExp(iat, uat) {\n    if (!rollingEnabled) {\n      return iat + absoluteDuration;\n    }\n\n    return Math.min(\n      ...[uat + rollingDuration, iat + absoluteDuration].filter(Boolean)\n    );\n  }\n\n  function setCookie(\n    req,\n    res,\n    { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n  ) {\n    const cookies = req[COOKIES];\n    const { transient: cookieTransient, ...cookieOptions } = cookieConfig;\n    cookieOptions.expires = cookieTransient ? 0 : new Date(exp * 1000);\n\n    // session was deleted or is empty, this matches all session cookies (chunked or unchunked)\n    // and clears them, essentially cleaning up what we've set in the past that is now trash\n    if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n      debug(\n        'session was deleted or is empty, clearing all matching session cookies'\n      );\n      for (const cookieName of Object.keys(cookies)) {\n        if (cookieName.match(`^${sessionName}(?:\\\\.\\\\d)?$`)) {\n          clearCookie(cookieName, res);\n        }\n      }\n    } else {\n      debug(\n        'found session, creating signed session cookie(s) with name %o(.i)',\n        sessionName\n      );\n\n      const value = encrypt(JSON.stringify(req[sessionName]), {\n        iat,\n        uat,\n        exp,\n      });\n\n      const chunkCount = Math.ceil(value.length / cookieChunkSize);\n\n      if (chunkCount > 1) {\n        debug('cookie size greater than %d, chunking', cookieChunkSize);\n        for (let i = 0; i < chunkCount; i++) {\n          const chunkValue = value.slice(\n            i * cookieChunkSize,\n            (i + 1) * cookieChunkSize\n          );\n\n          const chunkCookieName = `${sessionName}.${i}`;\n          res.cookie(chunkCookieName, chunkValue, cookieOptions);\n        }\n        if (sessionName in cookies) {\n          debug('replacing non chunked cookie with chunked cookies');\n          clearCookie(sessionName, res);\n        }\n      } else {\n        res.cookie(sessionName, value, cookieOptions);\n        for (const cookieName of Object.keys(cookies)) {\n          debug('replacing chunked cookies with non chunked cookies');\n          if (cookieName.match(`^${sessionName}\\\\.\\\\d$`)) {\n            clearCookie(cookieName, res);\n          }\n        }\n      }\n    }\n  }\n\n  function clearCookie(name, res) {\n    const { domain, path, sameSite, secure } = cookieConfig;\n    res.clearCookie(name, {\n      domain,\n      path,\n      sameSite,\n      secure,\n    });\n  }\n\n  class CookieStore {\n    async get(idOrVal) {\n      const { protected: header, cleartext } = decrypt(idOrVal);\n      return {\n        header,\n        data: JSON.parse(cleartext),\n      };\n    }\n\n    getCookie(req) {\n      return req[COOKIES][sessionName];\n    }\n\n    setCookie(req, res, iat) {\n      setCookie(req, res, iat);\n    }\n  }\n\n  class CustomStore {\n    constructor(store) {\n      this._get = promisify(store.get).bind(store);\n      this._set = promisify(store.set).bind(store);\n      this._destroy = promisify(store.destroy).bind(store);\n\n      let [current, keystore] = getKeyStore(config.secret);\n      if (keystore.size === 1) {\n        keystore = current;\n      }\n      this._keyStore = keystore;\n      this._current = current;\n    }\n\n    async get(id) {\n      return this._get(id);\n    }\n\n    async set(\n      id,\n      req,\n      res,\n      { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n    ) {\n      const hasPrevSession = !!req[COOKIES][sessionName];\n      const replacingPrevSession = !!req[REGENERATED_SESSION_ID];\n      const hasCurrentSession =\n        req[sessionName] && Object.keys(req[sessionName]).length;\n      if (hasPrevSession && (replacingPrevSession || !hasCurrentSession)) {\n        await this._destroy(id);\n      }\n      if (hasCurrentSession) {\n        await this._set(req[REGENERATED_SESSION_ID] || id, {\n          header: { iat, uat, exp },\n          data: req[sessionName],\n          cookie: {\n            expires: exp * 1000,\n            maxAge: exp * 1000 - Date.now(),\n          },\n        });\n      }\n    }\n\n    getCookie(req) {\n      if (signSessionStoreCookie) {\n        const verified = verifyCookie(\n          sessionName,\n          req[COOKIES][sessionName],\n          this._keyStore\n        );\n        if (requireSignedSessionStoreCookie) {\n          return verified;\n        }\n        return verified || req[COOKIES][sessionName];\n      }\n      return req[COOKIES][sessionName];\n    }\n\n    setCookie(\n      id,\n      req,\n      res,\n      { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n    ) {\n      if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n        if (req[COOKIES][sessionName]) {\n          clearCookie(sessionName, res);\n        }\n      } else {\n        const cookieOptions = {\n          ...cookieConfig,\n          expires: cookieConfig.transient ? 0 : new Date(exp * 1000),\n        };\n        delete cookieOptions.transient;\n        let value = id;\n        if (signSessionStoreCookie) {\n          value = signCookie(sessionName, id, this._current);\n        }\n        res.cookie(sessionName, value, cookieOptions);\n      }\n    }\n  }\n\n  const isCustomStore = !!config.session.store;\n  const store = isCustomStore\n    ? new CustomStore(config.session.store)\n    : new CookieStore();\n\n  return async (req, res, next) => {\n    if (req.hasOwnProperty(sessionName)) {\n      debug(\n        'request object (req) already has %o property, this is indicative of a middleware setup problem',\n        sessionName\n      );\n      return next(\n        new Error(\n          `req[${sessionName}] is already set, did you run this middleware twice?`\n        )\n      );\n    }\n\n    req[COOKIES] = cookie.parse(req.get('cookie') || '');\n\n    let iat;\n    let uat;\n    let exp;\n    let existingSessionValue;\n\n    try {\n      if (req[COOKIES].hasOwnProperty(sessionName)) {\n        // get JWE from unchunked session cookie\n        debug('reading session from %s cookie', sessionName);\n        existingSessionValue = store.getCookie(req);\n      } else if (req[COOKIES].hasOwnProperty(`${sessionName}.0`)) {\n        // get JWE from chunked session cookie\n        // iterate all cookie names\n        // match and filter for the ones that match sessionName.<number>\n        // sort by chunk index\n        // concat\n        existingSessionValue = Object.entries(req[COOKIES])\n          .map(([cookie, value]) => {\n            const match = cookie.match(`^${sessionName}\\\\.(\\\\d+)$`);\n            if (match) {\n              return [match[1], value];\n            }\n          })\n          .filter(Boolean)\n          .sort(([a], [b]) => {\n            return parseInt(a, 10) - parseInt(b, 10);\n          })\n          .map(([i, chunk]) => {\n            debug('reading session chunk from %s.%d cookie', sessionName, i);\n            return chunk;\n          })\n          .join('');\n      }\n      if (existingSessionValue) {\n        const { header, data } = await store.get(existingSessionValue);\n        ({ iat, uat, exp } = header);\n\n        // check that the existing session isn't expired based on options when it was established\n        assert(\n          exp > epoch(),\n          'it is expired based on options when it was established'\n        );\n\n        // check that the existing session isn't expired based on current rollingDuration rules\n        if (rollingDuration) {\n          assert(\n            uat + rollingDuration > epoch(),\n            'it is expired based on current rollingDuration rules'\n          );\n        }\n\n        // check that the existing session isn't expired based on current absoluteDuration rules\n        if (absoluteDuration) {\n          assert(\n            iat + absoluteDuration > epoch(),\n            'it is expired based on current absoluteDuration rules'\n          );\n        }\n\n        attachSessionObject(req, sessionName, data);\n      }\n    } catch (err) {\n      if (err instanceof AssertionError) {\n        debug('existing session was rejected because', err.message);\n      } else if (err instanceof JOSEError) {\n        debug(\n          'existing session was rejected because it could not be decrypted',\n          err\n        );\n      } else {\n        debug('unexpected error handling session', err);\n      }\n    }\n\n    if (!req.hasOwnProperty(sessionName) || !req[sessionName]) {\n      attachSessionObject(req, sessionName, {});\n    }\n\n    if (isCustomStore) {\n      const id = existingSessionValue || (await generateId(req));\n\n      onHeaders(res, () =>\n        store.setCookie(req[REGENERATED_SESSION_ID] || id, req, res, { iat })\n      );\n\n      const { end: origEnd } = res;\n      res.end = async function resEnd(...args) {\n        try {\n          await store.set(id, req, res, {\n            iat,\n          });\n          origEnd.call(res, ...args);\n        } catch (e) {\n          // need to restore the original `end` so that it gets\n          // called after `next(e)` calls the express error handling mw\n          res.end = origEnd;\n          process.nextTick(() => next(e));\n        }\n      };\n    } else {\n      onHeaders(res, () => store.setCookie(req, res, { iat }));\n    }\n\n    return next();\n  };\n};\n\nmodule.exports.regenerateSessionStoreId = regenerateSessionStoreId;\nmodule.exports.replaceSession = replaceSession;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}