{"ast":null,"code":"const {\n  EOL\n} = require('os');\nconst base64url = require('../help/base64url');\nconst isDisjoint = require('../help/is_disjoint');\nconst isObject = require('../help/is_object');\nlet validateCrit = require('../help/validate_crit');\nconst getKey = require('../help/get_key');\nconst {\n  KeyStore\n} = require('../jwks');\nconst errors = require('../errors');\nconst {\n  check,\n  verify\n} = require('../jwa');\nconst JWK = require('../jwk');\nconst {\n  detect: resolveSerialization\n} = require('./serializers');\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid);\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed']);\n\n/*\n * @public\n */\nconst jwsVerify = (skipDisjointCheck, serialization, jws, key, {\n  crit = [],\n  complete = false,\n  algorithms\n} = {}) => {\n  key = getKey(key, true);\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings');\n  } else if (algorithms) {\n    algorithms = new Set(algorithms);\n  }\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n  if (!serialization) {\n    serialization = resolveSerialization(jws);\n  }\n  let prot; // protected header\n  let header; // unprotected header\n  let payload;\n  let signature;\n  let alg;\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened';\n    const {\n      signatures,\n      ...root\n    } = jws;\n    jws = {\n      ...root,\n      ...signatures[0]\n    };\n  }\n  let decoded;\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    let parsedProt = {};\n    switch (serialization) {\n      case 'compact':\n        // compact serialization format\n        [prot, payload, signature] = jws.split('.');\n        break;\n      case 'flattened':\n        // flattened serialization format\n        ({\n          protected: prot,\n          payload,\n          signature,\n          header\n        } = jws);\n        break;\n      case 'preparsed':\n        {\n          // from the JWT module\n          ({\n            decoded\n          } = jws);\n          [prot, payload, signature] = jws.token.split('.');\n          break;\n        }\n    }\n    if (!header) {\n      skipDisjointCheck = true;\n    }\n    if (decoded) {\n      parsedProt = decoded.header;\n    } else if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot);\n      } catch (err) {\n        throw new errors.JWSInvalid('could not parse JWS protected header');\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true;\n    }\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const combinedHeader = {\n      ...parsedProt,\n      ...header\n    };\n    validateCrit(parsedProt, header, crit);\n    alg = parsedProt.alg || header && header.alg;\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm');\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted');\n    }\n    if (key instanceof KeyStore) {\n      const keystore = key;\n      const keys = keystore.all({\n        kid: combinedHeader.kid,\n        alg: combinedHeader.alg,\n        key_ops: ['verify']\n      });\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n        default:\n          {\n            const errs = [];\n            for (const key of keys) {\n              try {\n                return jwsVerify(true, serialization, jws, key, {\n                  crit,\n                  complete,\n                  algorithms: algorithms ? [...algorithms] : undefined\n                });\n              } catch (err) {\n                errs.push(err);\n                continue;\n              }\n            }\n            const multi = new errors.JOSEMultiError(errs);\n            if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n              throw new errors.JWSVerificationFailed();\n            }\n            throw multi;\n          }\n      }\n    }\n    if (key === JWK.EmbeddedJWK) {\n      if (!isObject(combinedHeader.jwk)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object');\n      }\n      key = JWK.asKey(combinedHeader.jwk);\n      if (key.type !== 'public') {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key');\n      }\n    } else if (key === JWK.EmbeddedX5C) {\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(c => typeof c !== 'string' || !c)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings');\n      }\n      key = JWK.asKey(`-----BEGIN CERTIFICATE-----${EOL}${(combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END CERTIFICATE-----`, {\n        x5c: combinedHeader.x5c\n      });\n    }\n    check(key, 'verify', alg);\n    const toBeVerified = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.isBuffer(payload) ? payload : Buffer.from(payload)]);\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed();\n    }\n    if (combinedHeader.b64 === false) {\n      payload = Buffer.from(payload);\n    } else {\n      payload = base64url.decodeToBuffer(payload);\n    }\n    if (complete) {\n      const result = {\n        payload,\n        key\n      };\n      if (prot) result.protected = parsedProt;\n      if (header) result.header = header;\n      return result;\n    }\n    return payload;\n  }\n\n  // general serialization format\n  const {\n    signatures,\n    ...root\n  } = jws;\n  const errs = [];\n  for (const recipient of signatures) {\n    try {\n      return jwsVerify(false, 'flattened', {\n        ...root,\n        ...recipient\n      }, key, {\n        crit,\n        complete,\n        algorithms: algorithms ? [...algorithms] : undefined\n      });\n    } catch (err) {\n      errs.push(err);\n      continue;\n    }\n  }\n  const multi = new errors.JOSEMultiError(errs);\n  if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n    throw new errors.JWSVerificationFailed();\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n  throw multi;\n};\nmodule.exports = {\n  bare: jwsVerify,\n  verify: jwsVerify.bind(undefined, false, undefined)\n};","map":{"version":3,"names":["EOL","require","base64url","isDisjoint","isObject","validateCrit","getKey","KeyStore","errors","check","verify","JWK","detect","resolveSerialization","bind","undefined","JWSInvalid","SINGLE_RECIPIENT","Set","jwsVerify","skipDisjointCheck","serialization","jws","key","crit","complete","algorithms","Array","isArray","some","s","TypeError","prot","header","payload","signature","alg","signatures","length","root","decoded","has","parsedProt","split","protected","token","JSON","decode","err","combinedHeader","JOSEAlgNotWhitelisted","keystore","keys","all","kid","key_ops","JWKSNoMatchingKey","errs","push","multi","JOSEMultiError","e","JWSVerificationFailed","EmbeddedJWK","jwk","asKey","type","EmbeddedX5C","x5c","c","match","join","toBeVerified","Buffer","concat","from","isBuffer","decodeToBuffer","b64","result","recipient","every","module","exports","bare"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/jose/lib/jws/verify.js"],"sourcesContent":["const { EOL } = require('os')\n\nconst base64url = require('../help/base64url')\nconst isDisjoint = require('../help/is_disjoint')\nconst isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, verify } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { detect: resolveSerialization } = require('./serializers')\n\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid)\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed'])\n\n/*\n * @public\n */\nconst jwsVerify = (skipDisjointCheck, serialization, jws, key, { crit = [], complete = false, algorithms } = {}) => {\n  key = getKey(key, true)\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings')\n  } else if (algorithms) {\n    algorithms = new Set(algorithms)\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jws)\n  }\n\n  let prot // protected header\n  let header // unprotected header\n  let payload\n  let signature\n  let alg\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened'\n    const { signatures, ...root } = jws\n    jws = { ...root, ...signatures[0] }\n  }\n\n  let decoded\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    let parsedProt = {}\n\n    switch (serialization) {\n      case 'compact': // compact serialization format\n        ([prot, payload, signature] = jws.split('.'))\n        break\n      case 'flattened': // flattened serialization format\n        ({ protected: prot, payload, signature, header } = jws)\n        break\n      case 'preparsed': { // from the JWT module\n        ({ decoded } = jws);\n        ([prot, payload, signature] = jws.token.split('.'))\n        break\n      }\n    }\n\n    if (!header) {\n      skipDisjointCheck = true\n    }\n\n    if (decoded) {\n      parsedProt = decoded.header\n    } else if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot)\n      } catch (err) {\n        throw new errors.JWSInvalid('could not parse JWS protected header')\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true\n    }\n\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')\n    }\n\n    const combinedHeader = { ...parsedProt, ...header }\n    validateCrit(parsedProt, header, crit)\n\n    alg = parsedProt.alg || (header && header.alg)\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm')\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      const keys = keystore.all({ kid: combinedHeader.kid, alg: combinedHeader.alg, key_ops: ['verify'] })\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jwsVerify(true, serialization, jws, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n            throw new errors.JWSVerificationFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    if (key === JWK.EmbeddedJWK) {\n      if (!isObject(combinedHeader.jwk)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object')\n      }\n      key = JWK.asKey(combinedHeader.jwk)\n      if (key.type !== 'public') {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key')\n      }\n    } else if (key === JWK.EmbeddedX5C) {\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(c => typeof c !== 'string' || !c)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings')\n      }\n      key = JWK.asKey(\n        `-----BEGIN CERTIFICATE-----${EOL}${(combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END CERTIFICATE-----`,\n        { x5c: combinedHeader.x5c }\n      )\n    }\n\n    check(key, 'verify', alg)\n\n    const toBeVerified = Buffer.concat([\n      Buffer.from(prot || ''),\n      Buffer.from('.'),\n      Buffer.isBuffer(payload) ? payload : Buffer.from(payload)\n    ])\n\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed()\n    }\n\n    if (combinedHeader.b64 === false) {\n      payload = Buffer.from(payload)\n    } else {\n      payload = base64url.decodeToBuffer(payload)\n    }\n\n    if (complete) {\n      const result = { payload, key }\n      if (prot) result.protected = parsedProt\n      if (header) result.header = header\n      return result\n    }\n\n    return payload\n  }\n\n  // general serialization format\n  const { signatures, ...root } = jws\n  const errs = []\n  for (const recipient of signatures) {\n    try {\n      return jwsVerify(false, 'flattened', { ...root, ...recipient }, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n    throw new errors.JWSVerificationFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = {\n  bare: jwsVerify,\n  verify: jwsVerify.bind(undefined, false, undefined)\n}\n"],"mappings":"AAAA,MAAM;EAAEA;AAAI,CAAC,GAAGC,OAAO,CAAC,IAAI,CAAC;AAE7B,MAAMC,SAAS,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AAC9C,MAAME,UAAU,GAAGF,OAAO,CAAC,qBAAqB,CAAC;AACjD,MAAMG,QAAQ,GAAGH,OAAO,CAAC,mBAAmB,CAAC;AAC7C,IAAII,YAAY,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAMK,MAAM,GAAGL,OAAO,CAAC,iBAAiB,CAAC;AACzC,MAAM;EAAEM;AAAS,CAAC,GAAGN,OAAO,CAAC,SAAS,CAAC;AACvC,MAAMO,MAAM,GAAGP,OAAO,CAAC,WAAW,CAAC;AACnC,MAAM;EAAEQ,KAAK;EAAEC;AAAO,CAAC,GAAGT,OAAO,CAAC,QAAQ,CAAC;AAC3C,MAAMU,GAAG,GAAGV,OAAO,CAAC,QAAQ,CAAC;AAE7B,MAAM;EAAEW,MAAM,EAAEC;AAAqB,CAAC,GAAGZ,OAAO,CAAC,eAAe,CAAC;AAEjEI,YAAY,GAAGA,YAAY,CAACS,IAAI,CAACC,SAAS,EAAEP,MAAM,CAACQ,UAAU,CAAC;AAC9D,MAAMC,gBAAgB,GAAG,IAAIC,GAAG,CAAC,CAAC,SAAS,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;;AAEvE;AACA;AACA;AACA,MAAMC,SAAS,GAAGA,CAACC,iBAAiB,EAAEC,aAAa,EAAEC,GAAG,EAAEC,GAAG,EAAE;EAAEC,IAAI,GAAG,EAAE;EAAEC,QAAQ,GAAG,KAAK;EAAEC;AAAW,CAAC,GAAG,CAAC,CAAC,KAAK;EAClHH,GAAG,GAAGjB,MAAM,CAACiB,GAAG,EAAE,IAAI,CAAC;EAEvB,IAAIG,UAAU,KAAKX,SAAS,KAAK,CAACY,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,IAAIA,UAAU,CAACG,IAAI,CAACC,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAI,CAACA,CAAC,CAAC,CAAC,EAAE;IACjH,MAAM,IAAIC,SAAS,CAAC,2DAA2D,CAAC;EAClF,CAAC,MAAM,IAAIL,UAAU,EAAE;IACrBA,UAAU,GAAG,IAAIR,GAAG,CAACQ,UAAU,CAAC;EAClC;EAEA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACJ,IAAI,CAAC,IAAIA,IAAI,CAACK,IAAI,CAACC,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAI,CAACA,CAAC,CAAC,EAAE;IACvE,MAAM,IAAIC,SAAS,CAAC,qDAAqD,CAAC;EAC5E;EAEA,IAAI,CAACV,aAAa,EAAE;IAClBA,aAAa,GAAGR,oBAAoB,CAACS,GAAG,CAAC;EAC3C;EAEA,IAAIU,IAAI,EAAC;EACT,IAAIC,MAAM,EAAC;EACX,IAAIC,OAAO;EACX,IAAIC,SAAS;EACb,IAAIC,GAAG;;EAEP;EACA;EACA,IAAIf,aAAa,KAAK,SAAS,IAAIC,GAAG,CAACe,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE;IAC9DjB,aAAa,GAAG,WAAW;IAC3B,MAAM;MAAEgB,UAAU;MAAE,GAAGE;IAAK,CAAC,GAAGjB,GAAG;IACnCA,GAAG,GAAG;MAAE,GAAGiB,IAAI;MAAE,GAAGF,UAAU,CAAC,CAAC;IAAE,CAAC;EACrC;EAEA,IAAIG,OAAO;EAEX,IAAIvB,gBAAgB,CAACwB,GAAG,CAACpB,aAAa,CAAC,EAAE;IACvC,IAAIqB,UAAU,GAAG,CAAC,CAAC;IAEnB,QAAQrB,aAAa;MACnB,KAAK,SAAS;QAAE;QACb,CAACW,IAAI,EAAEE,OAAO,EAAEC,SAAS,CAAC,GAAGb,GAAG,CAACqB,KAAK,CAAC,GAAG,CAAC;QAC5C;MACF,KAAK,WAAW;QAAE;QAChB,CAAC;UAAEC,SAAS,EAAEZ,IAAI;UAAEE,OAAO;UAAEC,SAAS;UAAEF;QAAO,CAAC,GAAGX,GAAG;QACtD;MACF,KAAK,WAAW;QAAE;UAAE;UAClB,CAAC;YAAEkB;UAAQ,CAAC,GAAGlB,GAAG;UACjB,CAACU,IAAI,EAAEE,OAAO,EAAEC,SAAS,CAAC,GAAGb,GAAG,CAACuB,KAAK,CAACF,KAAK,CAAC,GAAG,CAAC;UAClD;QACF;IACF;IAEA,IAAI,CAACV,MAAM,EAAE;MACXb,iBAAiB,GAAG,IAAI;IAC1B;IAEA,IAAIoB,OAAO,EAAE;MACXE,UAAU,GAAGF,OAAO,CAACP,MAAM;IAC7B,CAAC,MAAM,IAAID,IAAI,EAAE;MACf,IAAI;QACFU,UAAU,GAAGxC,SAAS,CAAC4C,IAAI,CAACC,MAAM,CAACf,IAAI,CAAC;MAC1C,CAAC,CAAC,OAAOgB,GAAG,EAAE;QACZ,MAAM,IAAIxC,MAAM,CAACQ,UAAU,CAAC,sCAAsC,CAAC;MACrE;IACF,CAAC,MAAM;MACLI,iBAAiB,GAAGA,iBAAiB,IAAI,IAAI;IAC/C;IAEA,IAAI,CAACA,iBAAiB,IAAI,CAACjB,UAAU,CAACuC,UAAU,EAAET,MAAM,CAAC,EAAE;MACzD,MAAM,IAAIzB,MAAM,CAACQ,UAAU,CAAC,2EAA2E,CAAC;IAC1G;IAEA,MAAMiC,cAAc,GAAG;MAAE,GAAGP,UAAU;MAAE,GAAGT;IAAO,CAAC;IACnD5B,YAAY,CAACqC,UAAU,EAAET,MAAM,EAAET,IAAI,CAAC;IAEtCY,GAAG,GAAGM,UAAU,CAACN,GAAG,IAAKH,MAAM,IAAIA,MAAM,CAACG,GAAI;IAC9C,IAAI,CAACA,GAAG,EAAE;MACR,MAAM,IAAI5B,MAAM,CAACQ,UAAU,CAAC,iCAAiC,CAAC;IAChE,CAAC,MAAM,IAAIU,UAAU,IAAI,CAACA,UAAU,CAACe,GAAG,CAACL,GAAG,CAAC,EAAE;MAC7C,MAAM,IAAI5B,MAAM,CAAC0C,qBAAqB,CAAC,qBAAqB,CAAC;IAC/D;IAEA,IAAI3B,GAAG,YAAYhB,QAAQ,EAAE;MAC3B,MAAM4C,QAAQ,GAAG5B,GAAG;MACpB,MAAM6B,IAAI,GAAGD,QAAQ,CAACE,GAAG,CAAC;QAAEC,GAAG,EAAEL,cAAc,CAACK,GAAG;QAAElB,GAAG,EAAEa,cAAc,CAACb,GAAG;QAAEmB,OAAO,EAAE,CAAC,QAAQ;MAAE,CAAC,CAAC;MACpG,QAAQH,IAAI,CAACd,MAAM;QACjB,KAAK,CAAC;UACJ,MAAM,IAAI9B,MAAM,CAACgD,iBAAiB,CAAC,CAAC;QACtC,KAAK,CAAC;UACJ;UACA;UACAjC,GAAG,GAAG6B,IAAI,CAAC,CAAC,CAAC;UACb;QACF;UAAS;YACP,MAAMK,IAAI,GAAG,EAAE;YACf,KAAK,MAAMlC,GAAG,IAAI6B,IAAI,EAAE;cACtB,IAAI;gBACF,OAAOjC,SAAS,CAAC,IAAI,EAAEE,aAAa,EAAEC,GAAG,EAAEC,GAAG,EAAE;kBAAEC,IAAI;kBAAEC,QAAQ;kBAAEC,UAAU,EAAEA,UAAU,GAAG,CAAC,GAAGA,UAAU,CAAC,GAAGX;gBAAU,CAAC,CAAC;cAC3H,CAAC,CAAC,OAAOiC,GAAG,EAAE;gBACZS,IAAI,CAACC,IAAI,CAACV,GAAG,CAAC;gBACd;cACF;YACF;YAEA,MAAMW,KAAK,GAAG,IAAInD,MAAM,CAACoD,cAAc,CAACH,IAAI,CAAC;YAC7C,IAAI,CAAC,GAAGE,KAAK,CAAC,CAAC9B,IAAI,CAACgC,CAAC,IAAIA,CAAC,YAAYrD,MAAM,CAACsD,qBAAqB,CAAC,EAAE;cACnE,MAAM,IAAItD,MAAM,CAACsD,qBAAqB,CAAC,CAAC;YAC1C;YACA,MAAMH,KAAK;UACb;MACF;IACF;IAEA,IAAIpC,GAAG,KAAKZ,GAAG,CAACoD,WAAW,EAAE;MAC3B,IAAI,CAAC3D,QAAQ,CAAC6C,cAAc,CAACe,GAAG,CAAC,EAAE;QACjC,MAAM,IAAIxD,MAAM,CAACQ,UAAU,CAAC,kDAAkD,CAAC;MACjF;MACAO,GAAG,GAAGZ,GAAG,CAACsD,KAAK,CAAChB,cAAc,CAACe,GAAG,CAAC;MACnC,IAAIzC,GAAG,CAAC2C,IAAI,KAAK,QAAQ,EAAE;QACzB,MAAM,IAAI1D,MAAM,CAACQ,UAAU,CAAC,iDAAiD,CAAC;MAChF;IACF,CAAC,MAAM,IAAIO,GAAG,KAAKZ,GAAG,CAACwD,WAAW,EAAE;MAClC,IAAI,CAACxC,KAAK,CAACC,OAAO,CAACqB,cAAc,CAACmB,GAAG,CAAC,IAAI,CAACnB,cAAc,CAACmB,GAAG,CAAC9B,MAAM,IAAIW,cAAc,CAACmB,GAAG,CAACvC,IAAI,CAACwC,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAI,CAACA,CAAC,CAAC,EAAE;QACjI,MAAM,IAAI7D,MAAM,CAACQ,UAAU,CAAC,8EAA8E,CAAC;MAC7G;MACAO,GAAG,GAAGZ,GAAG,CAACsD,KAAK,CACZ,8BAA6BjE,GAAI,GAAE,CAACiD,cAAc,CAACmB,GAAG,CAAC,CAAC,CAAC,CAACE,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,EAAEC,IAAI,CAACvE,GAAG,CAAE,GAAEA,GAAI,2BAA0B,EAC9H;QAAEoE,GAAG,EAAEnB,cAAc,CAACmB;MAAI,CAC5B,CAAC;IACH;IAEA3D,KAAK,CAACc,GAAG,EAAE,QAAQ,EAAEa,GAAG,CAAC;IAEzB,MAAMoC,YAAY,GAAGC,MAAM,CAACC,MAAM,CAAC,CACjCD,MAAM,CAACE,IAAI,CAAC3C,IAAI,IAAI,EAAE,CAAC,EACvByC,MAAM,CAACE,IAAI,CAAC,GAAG,CAAC,EAChBF,MAAM,CAACG,QAAQ,CAAC1C,OAAO,CAAC,GAAGA,OAAO,GAAGuC,MAAM,CAACE,IAAI,CAACzC,OAAO,CAAC,CAC1D,CAAC;IAEF,IAAI,CAACxB,MAAM,CAAC0B,GAAG,EAAEb,GAAG,EAAEiD,YAAY,EAAEtE,SAAS,CAAC2E,cAAc,CAAC1C,SAAS,CAAC,CAAC,EAAE;MACxE,MAAM,IAAI3B,MAAM,CAACsD,qBAAqB,CAAC,CAAC;IAC1C;IAEA,IAAIb,cAAc,CAAC6B,GAAG,KAAK,KAAK,EAAE;MAChC5C,OAAO,GAAGuC,MAAM,CAACE,IAAI,CAACzC,OAAO,CAAC;IAChC,CAAC,MAAM;MACLA,OAAO,GAAGhC,SAAS,CAAC2E,cAAc,CAAC3C,OAAO,CAAC;IAC7C;IAEA,IAAIT,QAAQ,EAAE;MACZ,MAAMsD,MAAM,GAAG;QAAE7C,OAAO;QAAEX;MAAI,CAAC;MAC/B,IAAIS,IAAI,EAAE+C,MAAM,CAACnC,SAAS,GAAGF,UAAU;MACvC,IAAIT,MAAM,EAAE8C,MAAM,CAAC9C,MAAM,GAAGA,MAAM;MAClC,OAAO8C,MAAM;IACf;IAEA,OAAO7C,OAAO;EAChB;;EAEA;EACA,MAAM;IAAEG,UAAU;IAAE,GAAGE;EAAK,CAAC,GAAGjB,GAAG;EACnC,MAAMmC,IAAI,GAAG,EAAE;EACf,KAAK,MAAMuB,SAAS,IAAI3C,UAAU,EAAE;IAClC,IAAI;MACF,OAAOlB,SAAS,CAAC,KAAK,EAAE,WAAW,EAAE;QAAE,GAAGoB,IAAI;QAAE,GAAGyC;MAAU,CAAC,EAAEzD,GAAG,EAAE;QAAEC,IAAI;QAAEC,QAAQ;QAAEC,UAAU,EAAEA,UAAU,GAAG,CAAC,GAAGA,UAAU,CAAC,GAAGX;MAAU,CAAC,CAAC;IAChJ,CAAC,CAAC,OAAOiC,GAAG,EAAE;MACZS,IAAI,CAACC,IAAI,CAACV,GAAG,CAAC;MACd;IACF;EACF;EAEA,MAAMW,KAAK,GAAG,IAAInD,MAAM,CAACoD,cAAc,CAACH,IAAI,CAAC;EAC7C,IAAI,CAAC,GAAGE,KAAK,CAAC,CAAC9B,IAAI,CAACgC,CAAC,IAAIA,CAAC,YAAYrD,MAAM,CAACsD,qBAAqB,CAAC,EAAE;IACnE,MAAM,IAAItD,MAAM,CAACsD,qBAAqB,CAAC,CAAC;EAC1C,CAAC,MAAM,IAAI,CAAC,GAAGH,KAAK,CAAC,CAACsB,KAAK,CAACpB,CAAC,IAAIA,CAAC,YAAYrD,MAAM,CAACgD,iBAAiB,CAAC,EAAE;IACvE,MAAM,IAAIhD,MAAM,CAACgD,iBAAiB,CAAC,CAAC;EACtC;EACA,MAAMG,KAAK;AACb,CAAC;AAEDuB,MAAM,CAACC,OAAO,GAAG;EACfC,IAAI,EAAEjE,SAAS;EACfT,MAAM,EAAES,SAAS,CAACL,IAAI,CAACC,SAAS,EAAE,KAAK,EAAEA,SAAS;AACpD,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}