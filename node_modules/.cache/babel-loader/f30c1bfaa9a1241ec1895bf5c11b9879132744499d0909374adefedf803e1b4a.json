{"ast":null,"code":"const {\n  pbkdf2Sync: pbkdf2,\n  randomBytes\n} = require('crypto');\nconst {\n  KEYOBJECT\n} = require('../help/consts');\nconst base64url = require('../help/base64url');\nconst SALT_LENGTH = 16;\nconst NULL_BUFFER = Buffer.alloc(1, 0);\nconst concatSalt = (alg, p2s) => {\n  return Buffer.concat([Buffer.from(alg, 'utf8'), NULL_BUFFER, p2s]);\n};\nconst wrapKey = (keylen, sha, concat, wrap, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  // Note that if password-based encryption is used for multiple\n  // recipients, it is expected that each recipient use different values\n  // for the PBES2 parameters \"p2s\" and \"p2c\".\n  // here we generate p2c between 2048 and 4096 and random p2s\n  const p2c = Math.floor(Math.random() * 2049 + 2048);\n  const p2s = randomBytes(SALT_LENGTH);\n  const salt = concat(p2s);\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha);\n  const result = wrap({\n    [KEYOBJECT]: derivedKey\n  }, payload);\n  result.header = result.header || {};\n  Object.assign(result.header, {\n    p2c,\n    p2s: base64url.encodeBuffer(p2s)\n  });\n  return result;\n};\nconst unwrapKey = (keylen, sha, concat, unwrap, {\n  [KEYOBJECT]: keyObject\n}, payload, header) => {\n  const {\n    p2s,\n    p2c\n  } = header;\n  const salt = concat(p2s);\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha);\n  return unwrap({\n    [KEYOBJECT]: derivedKey\n  }, payload, header);\n};\nmodule.exports = (JWA, JWK) => {\n  ['PBES2-HS256+A128KW', 'PBES2-HS384+A192KW', 'PBES2-HS512+A256KW'].forEach(jwaAlg => {\n    const kw = jwaAlg.substr(-6);\n    const kwWrap = JWA.keyManagementEncrypt.get(kw);\n    const kwUnwrap = JWA.keyManagementDecrypt.get(kw);\n    const keylen = parseInt(jwaAlg.substr(13, 3), 10) / 8;\n    const sha = `sha${jwaAlg.substr(8, 3)}`;\n    if (kwWrap && kwUnwrap) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwWrap));\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwUnwrap));\n      JWK.oct.deriveKey[jwaAlg] = key => key.use === 'enc' || key.use === undefined;\n    }\n  });\n};","map":{"version":3,"names":["pbkdf2Sync","pbkdf2","randomBytes","require","KEYOBJECT","base64url","SALT_LENGTH","NULL_BUFFER","Buffer","alloc","concatSalt","alg","p2s","concat","from","wrapKey","keylen","sha","wrap","keyObject","payload","p2c","Math","floor","random","salt","derivedKey","export","result","header","Object","assign","encodeBuffer","unwrapKey","unwrap","module","exports","JWA","JWK","forEach","jwaAlg","kw","substr","kwWrap","keyManagementEncrypt","get","kwUnwrap","keyManagementDecrypt","parseInt","set","bind","undefined","oct","deriveKey","key","use"],"sources":["/Users/chamas/Final-Project/final-project/node_modules/jose/lib/jwa/pbes2.js"],"sourcesContent":["const { pbkdf2Sync: pbkdf2, randomBytes } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst base64url = require('../help/base64url')\n\nconst SALT_LENGTH = 16\nconst NULL_BUFFER = Buffer.alloc(1, 0)\n\nconst concatSalt = (alg, p2s) => {\n  return Buffer.concat([\n    Buffer.from(alg, 'utf8'),\n    NULL_BUFFER,\n    p2s\n  ])\n}\n\nconst wrapKey = (keylen, sha, concat, wrap, { [KEYOBJECT]: keyObject }, payload) => {\n  // Note that if password-based encryption is used for multiple\n  // recipients, it is expected that each recipient use different values\n  // for the PBES2 parameters \"p2s\" and \"p2c\".\n  // here we generate p2c between 2048 and 4096 and random p2s\n  const p2c = Math.floor((Math.random() * 2049) + 2048)\n  const p2s = randomBytes(SALT_LENGTH)\n  const salt = concat(p2s)\n\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha)\n\n  const result = wrap({ [KEYOBJECT]: derivedKey }, payload)\n  result.header = result.header || {}\n  Object.assign(result.header, { p2c, p2s: base64url.encodeBuffer(p2s) })\n\n  return result\n}\n\nconst unwrapKey = (keylen, sha, concat, unwrap, { [KEYOBJECT]: keyObject }, payload, header) => {\n  const { p2s, p2c } = header\n  const salt = concat(p2s)\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha)\n  return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['PBES2-HS256+A128KW', 'PBES2-HS384+A192KW', 'PBES2-HS512+A256KW'].forEach((jwaAlg) => {\n    const kw = jwaAlg.substr(-6)\n    const kwWrap = JWA.keyManagementEncrypt.get(kw)\n    const kwUnwrap = JWA.keyManagementDecrypt.get(kw)\n    const keylen = parseInt(jwaAlg.substr(13, 3), 10) / 8\n    const sha = `sha${jwaAlg.substr(8, 3)}`\n\n    if (kwWrap && kwUnwrap) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwWrap))\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwUnwrap))\n      JWK.oct.deriveKey[jwaAlg] = key => key.use === 'enc' || key.use === undefined\n    }\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}